/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./wwwroot/vendor/libs/shepherd/shepherd.js":
/*!**************************************************!*\
  !*** ./wwwroot/vendor/libs/shepherd/shepherd.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Shepherd\": () => (/* reexport default from dynamic */ shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default.a)\n/* harmony export */ });\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shepherd.js/dist/js/shepherd */ \"./node_modules/shepherd.js/dist/js/shepherd.js\");\n/* harmony import */ var shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(shepherd_js_dist_js_shepherd__WEBPACK_IMPORTED_MODULE_0__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi93d3dyb290L3ZlbmRvci9saWJzL3NoZXBoZXJkL3NoZXBoZXJkLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvRCIsInNvdXJjZXMiOlsid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4vd3d3cm9vdC92ZW5kb3IvbGlicy9zaGVwaGVyZC9zaGVwaGVyZC5qcz9kM2UxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBTaGVwaGVyZCBmcm9tICdzaGVwaGVyZC5qcy9kaXN0L2pzL3NoZXBoZXJkJztcclxuXHJcbmV4cG9ydCB7IFNoZXBoZXJkIH07XHJcbiJdLCJuYW1lcyI6WyJTaGVwaGVyZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./wwwroot/vendor/libs/shepherd/shepherd.js\n");

/***/ }),

/***/ "./node_modules/shepherd.js/dist/js/shepherd.js":
/*!******************************************************!*\
  !*** ./node_modules/shepherd.js/dist/js/shepherd.js ***!
  \******************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0) { ; } } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*! shepherd.js 10.0.1 */\n\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict';\n\n  var isMergeableObject = function isMergeableObject(value) {\n    return isNonNullObject(value) && !isSpecial(value);\n  };\n  function isNonNullObject(value) {\n    return !!value && _typeof(value) === 'object';\n  }\n  function isSpecial(value) {\n    var stringValue = Object.prototype.toString.call(value);\n    return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);\n  } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\n\n  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;\n  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n  function isReactElement(value) {\n    return value.$$typeof === REACT_ELEMENT_TYPE;\n  }\n  function emptyTarget(val) {\n    return Array.isArray(val) ? [] : {};\n  }\n  function cloneUnlessOtherwiseSpecified(value, options) {\n    return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;\n  }\n  function defaultArrayMerge(target, source, options) {\n    return target.concat(source).map(function (element) {\n      return cloneUnlessOtherwiseSpecified(element, options);\n    });\n  }\n  function getMergeFunction(key, options) {\n    if (!options.customMerge) {\n      return deepmerge;\n    }\n    var customMerge = options.customMerge(key);\n    return typeof customMerge === 'function' ? customMerge : deepmerge;\n  }\n  function getEnumerableOwnPropertySymbols(target) {\n    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {\n      return target.propertyIsEnumerable(symbol);\n    }) : [];\n  }\n  function getKeys(target) {\n    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));\n  }\n  function propertyIsOnObject(object, property) {\n    try {\n      return property in object;\n    } catch (_) {\n      return false;\n    }\n  } // Protects from prototype poisoning and unexpected merging up the prototype chain.\n\n  function propertyIsUnsafe(target, key) {\n    return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n    && !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n    && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.\n  }\n\n  function mergeObject(target, source, options) {\n    var destination = {};\n    if (options.isMergeableObject(target)) {\n      getKeys(target).forEach(function (key) {\n        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n      });\n    }\n    getKeys(source).forEach(function (key) {\n      if (propertyIsUnsafe(target, key)) {\n        return;\n      }\n      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n      } else {\n        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n      }\n    });\n    return destination;\n  }\n  function deepmerge(target, source, options) {\n    options = options || {};\n    options.arrayMerge = options.arrayMerge || defaultArrayMerge;\n    options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n    // implementations can use it. The caller may not replace it.\n\n    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n    var sourceIsArray = Array.isArray(source);\n    var targetIsArray = Array.isArray(target);\n    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n    if (!sourceAndTargetTypesMatch) {\n      return cloneUnlessOtherwiseSpecified(source, options);\n    } else if (sourceIsArray) {\n      return options.arrayMerge(target, source, options);\n    } else {\n      return mergeObject(target, source, options);\n    }\n  }\n  deepmerge.all = function deepmergeAll(array, options) {\n    if (!Array.isArray(array)) {\n      throw new Error('first argument should be an array');\n    }\n    return array.reduce(function (prev, next) {\n      return deepmerge(prev, next, options);\n    }, {});\n  };\n  var deepmerge_1 = deepmerge;\n  var cjs = deepmerge_1;\n\n  /**\n   * Checks if `value` is classified as an `Element`.\n   * @param {*} value The param to check if it is an Element\n   */\n  function isElement$1(value) {\n    return value instanceof Element;\n  }\n  /**\n   * Checks if `value` is classified as an `HTMLElement`.\n   * @param {*} value The param to check if it is an HTMLElement\n   */\n\n  function isHTMLElement$1(value) {\n    return value instanceof HTMLElement;\n  }\n  /**\n   * Checks if `value` is classified as a `Function` object.\n   * @param {*} value The param to check if it is a function\n   */\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Checks if `value` is classified as a `String` object.\n   * @param {*} value The param to check if it is a string\n   */\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Checks if `value` is undefined.\n   * @param {*} value The param to check if it is undefined\n   */\n\n  function isUndefined(value) {\n    return value === undefined;\n  }\n  var Evented = /*#__PURE__*/function () {\n    function Evented() {\n      _classCallCheck(this, Evented);\n    }\n    _createClass(Evented, [{\n      key: \"on\",\n      value: function on(event, handler, ctx, once) {\n        if (once === void 0) {\n          once = false;\n        }\n        if (isUndefined(this.bindings)) {\n          this.bindings = {};\n        }\n        if (isUndefined(this.bindings[event])) {\n          this.bindings[event] = [];\n        }\n        this.bindings[event].push({\n          handler: handler,\n          ctx: ctx,\n          once: once\n        });\n        return this;\n      }\n    }, {\n      key: \"once\",\n      value: function once(event, handler, ctx) {\n        return this.on(event, handler, ctx, true);\n      }\n    }, {\n      key: \"off\",\n      value: function off(event, handler) {\n        var _this = this;\n        if (isUndefined(this.bindings) || isUndefined(this.bindings[event])) {\n          return this;\n        }\n        if (isUndefined(handler)) {\n          delete this.bindings[event];\n        } else {\n          this.bindings[event].forEach(function (binding, index) {\n            if (binding.handler === handler) {\n              _this.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }, {\n      key: \"trigger\",\n      value: function trigger(event) {\n        var _this2 = this;\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        if (!isUndefined(this.bindings) && this.bindings[event]) {\n          this.bindings[event].forEach(function (binding, index) {\n            var ctx = binding.ctx,\n              handler = binding.handler,\n              once = binding.once;\n            var context = ctx || _this2;\n            handler.apply(context, args);\n            if (once) {\n              _this2.bindings[event].splice(index, 1);\n            }\n          });\n        }\n        return this;\n      }\n    }]);\n    return Evented;\n  }();\n  /**\n   * Binds all the methods on a JS Class to the `this` context of the class.\n   * Adapted from https://github.com/sindresorhus/auto-bind\n   * @param {object} self The `this` context of the class\n   * @return {object} The `this` context of the class\n   */\n  function autoBind(self) {\n    var keys = Object.getOwnPropertyNames(self.constructor.prototype);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = self[key];\n      if (key !== 'constructor' && typeof val === 'function') {\n        self[key] = val.bind(self);\n      }\n    }\n    return self;\n  }\n\n  /**\n   * Sets up the handler to determine if we should advance the tour\n   * @param {string} selector\n   * @param {Step} step The step instance\n   * @return {Function}\n   * @private\n   */\n\n  function _setupAdvanceOnHandler(selector, step) {\n    return function (event) {\n      if (step.isOpen()) {\n        var targetIsEl = step.el && event.currentTarget === step.el;\n        var targetIsSelector = !isUndefined(selector) && event.currentTarget.matches(selector);\n        if (targetIsSelector || targetIsEl) {\n          step.tour.next();\n        }\n      }\n    };\n  }\n  /**\n   * Bind the event handler for advanceOn\n   * @param {Step} step The step instance\n   */\n\n  function bindAdvance(step) {\n    // An empty selector matches the step element\n    var _ref6 = step.options.advanceOn || {},\n      event = _ref6.event,\n      selector = _ref6.selector;\n    if (event) {\n      var handler = _setupAdvanceOnHandler(selector, step); // TODO: this should also bind/unbind on show/hide\n\n      var el;\n      try {\n        el = document.querySelector(selector);\n      } catch (e) {// TODO\n      }\n      if (!isUndefined(selector) && !el) {\n        return console.error(\"No element was found for the selector supplied to advanceOn: \".concat(selector));\n      } else if (el) {\n        el.addEventListener(event, handler);\n        step.on('destroy', function () {\n          return el.removeEventListener(event, handler);\n        });\n      } else {\n        document.body.addEventListener(event, handler, true);\n        step.on('destroy', function () {\n          return document.body.removeEventListener(event, handler, true);\n        });\n      }\n    } else {\n      return console.error('advanceOn was defined, but no event name was passed.');\n    }\n  }\n  var top = 'top';\n  var bottom = 'bottom';\n  var right = 'right';\n  var left = 'left';\n  var auto = 'auto';\n  var basePlacements = [top, bottom, right, left];\n  var start = 'start';\n  var end = 'end';\n  var clippingParents = 'clippingParents';\n  var viewport = 'viewport';\n  var popper = 'popper';\n  var reference = 'reference';\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n  }, []);\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n  }, []); // modifiers that need to read the DOM\n\n  var beforeRead = 'beforeRead';\n  var read = 'read';\n  var afterRead = 'afterRead'; // pure-logic modifiers\n\n  var beforeMain = 'beforeMain';\n  var main = 'main';\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\n  var beforeWrite = 'beforeWrite';\n  var write = 'write';\n  var afterWrite = 'afterWrite';\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n  function getNodeName(element) {\n    return element ? (element.nodeName || '').toLowerCase() : null;\n  }\n  function getWindow(node) {\n    if (node == null) {\n      return window;\n    }\n    if (node.toString() !== '[object Window]') {\n      var ownerDocument = node.ownerDocument;\n      return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n  }\n  function isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n  }\n  function isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n  }\n  function isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === 'undefined') {\n      return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n  }\n\n  // and applies them to the HTMLElements such as popper and arrow\n\n  function applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function (name) {\n      var style = state.styles[name] || {};\n      var attributes = state.attributes[name] || {};\n      var element = state.elements[name]; // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe[cannot-write]\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (name) {\n        var value = attributes[name];\n        if (value === false) {\n          element.removeAttribute(name);\n        } else {\n          element.setAttribute(name, value === true ? '' : value);\n        }\n      });\n    });\n  }\n  function effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function () {\n      Object.keys(state.elements).forEach(function (name) {\n        var element = state.elements[name];\n        var attributes = state.attributes[name] || {};\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n        var style = styleProperties.reduce(function (style, property) {\n          style[property] = '';\n          return style;\n        }, {}); // arrow is optional + virtual elements\n\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n          return;\n        }\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function (attribute) {\n          element.removeAttribute(attribute);\n        });\n      });\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var applyStyles$1 = {\n    name: 'applyStyles',\n    enabled: true,\n    phase: 'write',\n    fn: applyStyles,\n    effect: effect$2,\n    requires: ['computeStyles']\n  };\n  function getBasePlacement(placement) {\n    return placement.split('-')[0];\n  }\n  var max = Math.max;\n  var min = Math.min;\n  var round = Math.round;\n  function getBoundingClientRect(element, includeScale) {\n    if (includeScale === void 0) {\n      includeScale = false;\n    }\n    var rect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (isHTMLElement(element) && includeScale) {\n      var offsetHeight = element.offsetHeight;\n      var offsetWidth = element.offsetWidth; // Do not attempt to divide by 0, otherwise we get `Infinity` as scale\n      // Fallback to 1 in case both values are `0`\n\n      if (offsetWidth > 0) {\n        scaleX = round(rect.width) / offsetWidth || 1;\n      }\n      if (offsetHeight > 0) {\n        scaleY = round(rect.height) / offsetHeight || 1;\n      }\n    }\n    return {\n      width: rect.width / scaleX,\n      height: rect.height / scaleY,\n      top: rect.top / scaleY,\n      right: rect.right / scaleX,\n      bottom: rect.bottom / scaleY,\n      left: rect.left / scaleX,\n      x: rect.left / scaleX,\n      y: rect.top / scaleY\n    };\n  }\n\n  // means it doesn't take into account transforms.\n\n  function getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n      width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n      height = clientRect.height;\n    }\n    return {\n      x: element.offsetLeft,\n      y: element.offsetTop,\n      width: width,\n      height: height\n    };\n  }\n  function contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n    if (parent.contains(child)) {\n      return true;\n    } // then fallback to custom implementation with Shadow DOM support\n    else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n    return false;\n  }\n  function getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n  }\n  function isTableElement(element) {\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n  }\n  function getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument :\n    // $FlowFixMe[prop-missing]\n    element.document) || window.document).documentElement;\n  }\n  function getParentNode(element) {\n    if (getNodeName(element) === 'html') {\n      return element;\n    }\n    return (\n      // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n      // $FlowFixMe[incompatible-return]\n      // $FlowFixMe[prop-missing]\n      element.assignedSlot ||\n      // step into the shadow DOM of the parent of a slotted node\n      element.parentNode || (\n      // DOM Element detected\n      isShadowRoot(element) ? element.host : null) ||\n      // ShadowRoot detected\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n      getDocumentElement(element) // fallback\n    );\n  }\n\n  function getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) ||\n    // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === 'fixed') {\n      return null;\n    }\n    return element.offsetParent;\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n  // return the containing block\n\n  function getContainingBlock(element) {\n    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;\n    var isIE = navigator.userAgent.indexOf('Trident') !== -1;\n    if (isIE && isHTMLElement(element)) {\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n      var elementCss = getComputedStyle(element);\n      if (elementCss.position === 'fixed') {\n        return null;\n      }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n      currentNode = currentNode.host;\n    }\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n      // create a containing block.\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n        return currentNode;\n      } else {\n        currentNode = currentNode.parentNode;\n      }\n    }\n    return null;\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\n  // such as table ancestors and cross browser bugs.\n\n  function getOffsetParent(element) {\n    var window = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n      offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n      return window;\n    }\n    return offsetParent || getContainingBlock(element) || window;\n  }\n  function getMainAxisFromPlacement(placement) {\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n  }\n  function within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n  }\n  function withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n  }\n  function getFreshSideObject() {\n    return {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n  }\n  function mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n  }\n  function expandToHashMap(value, keys) {\n    return keys.reduce(function (hashMap, key) {\n      hashMap[key] = value;\n      return hashMap;\n    }, {});\n  }\n  var toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  };\n  function arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\n    var len = isVertical ? 'height' : 'width';\n    if (!arrowElement || !popperOffsets) {\n      return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === 'y' ? top : left;\n    var maxProp = axis === 'y' ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n  }\n  function effect$1(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options;\n    var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n    if (arrowElement == null) {\n      return;\n    } // CSS selector\n\n    if (typeof arrowElement === 'string') {\n      arrowElement = state.elements.popper.querySelector(arrowElement);\n      if (!arrowElement) {\n        return;\n      }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n      return;\n    }\n    state.elements.arrow = arrowElement;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var arrow$1 = {\n    name: 'arrow',\n    enabled: true,\n    phase: 'main',\n    fn: arrow,\n    effect: effect$1,\n    requires: ['popperOffsets'],\n    requiresIfExists: ['preventOverflow']\n  };\n  function getVariation(placement) {\n    return placement.split('-')[1];\n  }\n  var unsetSides = {\n    top: 'auto',\n    right: 'auto',\n    bottom: 'auto',\n    left: 'auto'\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n  // Zooming can change the DPR, but it seems to report a value that will\n  // cleanly divide the values into the appropriate subpixels.\n\n  function roundOffsetsByDPR(_ref) {\n    var x = _ref.x,\n      y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n      x: round(x * dpr) / dpr || 0,\n      y: round(y * dpr) / dpr || 0\n    };\n  }\n  function mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty('x');\n    var hasY = offsets.hasOwnProperty('y');\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n      var offsetParent = getOffsetParent(popper);\n      var heightProp = 'clientHeight';\n      var widthProp = 'clientWidth';\n      if (offsetParent === getWindow(popper)) {\n        offsetParent = getDocumentElement(popper);\n        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n          heightProp = 'scrollHeight';\n          widthProp = 'scrollWidth';\n        }\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n      offsetParent = offsetParent;\n      if (placement === top || (placement === left || placement === right) && variation === end) {\n        sideY = bottom;\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height :\n        // $FlowFixMe[prop-missing]\n        offsetParent[heightProp];\n        y -= offsetY - popperRect.height;\n        y *= gpuAcceleration ? 1 : -1;\n      }\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\n        sideX = right;\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width :\n        // $FlowFixMe[prop-missing]\n        offsetParent[widthProp];\n        x -= offsetX - popperRect.width;\n        x *= gpuAcceleration ? 1 : -1;\n      }\n    }\n    var commonStyles = Object.assign({\n      position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n      x: x,\n      y: y\n    }) : {\n      x: x,\n      y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n      var _Object$assign;\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n  }\n  function computeStyles(_ref5) {\n    var state = _ref5.state,\n      options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    var commonStyles = {\n      placement: getBasePlacement(state.placement),\n      variation: getVariation(state.placement),\n      popper: state.elements.popper,\n      popperRect: state.rects.popper,\n      gpuAcceleration: gpuAcceleration,\n      isFixed: state.options.strategy === 'fixed'\n    };\n    if (state.modifiersData.popperOffsets != null) {\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.popperOffsets,\n        position: state.options.strategy,\n        adaptive: adaptive,\n        roundOffsets: roundOffsets\n      })));\n    }\n    if (state.modifiersData.arrow != null) {\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n        roundOffsets: roundOffsets\n      })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-placement': state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var computeStyles$1 = {\n    name: 'computeStyles',\n    enabled: true,\n    phase: 'beforeWrite',\n    fn: computeStyles,\n    data: {}\n  };\n  var passive = {\n    passive: true\n  };\n  function effect(_ref) {\n    var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n    var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n    var window = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.addEventListener('scroll', instance.update, passive);\n      });\n    }\n    if (resize) {\n      window.addEventListener('resize', instance.update, passive);\n    }\n    return function () {\n      if (scroll) {\n        scrollParents.forEach(function (scrollParent) {\n          scrollParent.removeEventListener('scroll', instance.update, passive);\n        });\n      }\n      if (resize) {\n        window.removeEventListener('resize', instance.update, passive);\n      }\n    };\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var eventListeners = {\n    name: 'eventListeners',\n    enabled: true,\n    phase: 'write',\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n  };\n  var hash$1 = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n  };\n  function getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash$1[matched];\n    });\n  }\n  var hash = {\n    start: 'end',\n    end: 'start'\n  };\n  function getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  function getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    };\n  }\n  function getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n  }\n  function getViewportRect(element) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper\n    // can be obscured underneath it.\n    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even\n    // if it isn't open, so if this isn't available, the popper will be detected\n    // to overflow the bottom of the screen too early.\n\n    if (visualViewport) {\n      width = visualViewport.width;\n      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n      // errors due to floating point numbers, so we need to check precision.\n      // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n      // Feature detection fails in mobile emulation mode in Chrome.\n      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <\n      // 0.001\n      // Fallback here: \"Not Safari\" userAgent\n\n      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {\n        x = visualViewport.offsetLeft;\n        y = visualViewport.offsetTop;\n      }\n    }\n    return {\n      width: width,\n      height: height,\n      x: x + getWindowScrollBarX(element),\n      y: y\n    };\n  }\n\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n  function getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === 'rtl') {\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n      width: width,\n      height: height,\n      x: x,\n      y: y\n    };\n  }\n  function isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n  }\n  function getScrollParent(node) {\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n      // $FlowFixMe[incompatible-return]: assume body is always available\n      return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n      return node;\n    }\n    return getScrollParent(getParentNode(node));\n  }\n\n  /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */\n\n  function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n      list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList :\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    updatedList.concat(listScrollParents(getParentNode(target)));\n  }\n  function rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n      left: rect.x,\n      top: rect.y,\n      right: rect.x + rect.width,\n      bottom: rect.y + rect.height\n    });\n  }\n  function getInnerBoundingClientRect(element) {\n    var rect = getBoundingClientRect(element);\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n  }\n  function getClientRectFromMixedType(element, clippingParent) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\n  // clipping (or hiding) overflowing elements with a position different from\n  // `initial`\n\n  function getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n      return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n    return clippingParents.filter(function (clippingParent) {\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n    });\n  } // Gets the maximum area that the element is visible in due to any number of\n  // clipping parents\n\n  function getClippingRect(element, boundary, rootBoundary) {\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n      var rect = getClientRectFromMixedType(element, clippingParent);\n      accRect.top = max(rect.top, accRect.top);\n      accRect.right = min(rect.right, accRect.right);\n      accRect.bottom = min(rect.bottom, accRect.bottom);\n      accRect.left = max(rect.left, accRect.left);\n      return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n  }\n  function computeOffsets(_ref) {\n    var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch (basePlacement) {\n      case top:\n        offsets = {\n          x: commonX,\n          y: reference.y - element.height\n        };\n        break;\n      case bottom:\n        offsets = {\n          x: commonX,\n          y: reference.y + reference.height\n        };\n        break;\n      case right:\n        offsets = {\n          x: reference.x + reference.width,\n          y: commonY\n        };\n        break;\n      case left:\n        offsets = {\n          x: reference.x - element.width,\n          y: commonY\n        };\n        break;\n      default:\n        offsets = {\n          x: reference.x,\n          y: reference.y\n        };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      switch (variation) {\n        case start:\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n          break;\n        case end:\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n          break;\n      }\n    }\n    return offsets;\n  }\n  function detectOverflow(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n      reference: referenceClientRect,\n      element: popperRect,\n      strategy: 'absolute',\n      placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n\n    var overflowOffsets = {\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n    if (elementContext === popper && offsetData) {\n      var offset = offsetData[placement];\n      Object.keys(overflowOffsets).forEach(function (key) {\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n        overflowOffsets[key] += offset[axis] * multiply;\n      });\n    }\n    return overflowOffsets;\n  }\n  function computeAutoPlacement(state, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n      return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function (placement) {\n      return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n      allowedPlacements = placements$1;\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\n      acc[placement] = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding\n      })[getBasePlacement(placement)];\n      return acc;\n    }, {});\n    return Object.keys(overflows).sort(function (a, b) {\n      return overflows[a] - overflows[b];\n    });\n  }\n  function getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n      return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n  }\n  function flip(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n      return;\n    }\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        flipVariations: flipVariations,\n        allowedAutoPlacements: allowedAutoPlacements\n      }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for (var i = 0; i < placements.length; i++) {\n      var placement = placements[i];\n      var _basePlacement = getBasePlacement(placement);\n      var isStartVariation = getVariation(placement) === start;\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n      var len = isVertical ? 'width' : 'height';\n      var overflow = detectOverflow(state, {\n        placement: placement,\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        altBoundary: altBoundary,\n        padding: padding\n      });\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n      if (referenceRect[len] > popperRect[len]) {\n        mainVariationSide = getOppositePlacement(mainVariationSide);\n      }\n      var altVariationSide = getOppositePlacement(mainVariationSide);\n      var checks = [];\n      if (checkMainAxis) {\n        checks.push(overflow[_basePlacement] <= 0);\n      }\n      if (checkAltAxis) {\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n      }\n      if (checks.every(function (check) {\n        return check;\n      })) {\n        firstFittingPlacement = placement;\n        makeFallbackChecks = false;\n        break;\n      }\n      checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n      // `2` may be desired in some cases – research later\n      var numberOfChecks = flipVariations ? 3 : 1;\n      var _loop = function _loop(_i) {\n        var fittingPlacement = placements.find(function (placement) {\n          var checks = checksMap.get(placement);\n          if (checks) {\n            return checks.slice(0, _i).every(function (check) {\n              return check;\n            });\n          }\n        });\n        if (fittingPlacement) {\n          firstFittingPlacement = fittingPlacement;\n          return \"break\";\n        }\n      };\n      for (var _i = numberOfChecks; _i > 0; _i--) {\n        var _ret = _loop(_i);\n        if (_ret === \"break\") break;\n      }\n    }\n    if (state.placement !== firstFittingPlacement) {\n      state.modifiersData[name]._skip = true;\n      state.placement = firstFittingPlacement;\n      state.reset = true;\n    }\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var flip$1 = {\n    name: 'flip',\n    enabled: true,\n    phase: 'main',\n    fn: flip,\n    requiresIfExists: ['offset'],\n    data: {\n      _skip: false\n    }\n  };\n  function getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n      preventedOffsets = {\n        x: 0,\n        y: 0\n      };\n    }\n    return {\n      top: overflow.top - rect.height - preventedOffsets.y,\n      right: overflow.right - rect.width + preventedOffsets.x,\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\n      left: overflow.left - rect.width - preventedOffsets.x\n    };\n  }\n  function isAnySideFullyClipped(overflow) {\n    return [top, right, bottom, left].some(function (side) {\n      return overflow[side] >= 0;\n    });\n  }\n  function hide(_ref) {\n    var state = _ref.state,\n      name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n      elementContext: 'reference'\n    });\n    var popperAltOverflow = detectOverflow(state, {\n      altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n      referenceClippingOffsets: referenceClippingOffsets,\n      popperEscapeOffsets: popperEscapeOffsets,\n      isReferenceHidden: isReferenceHidden,\n      hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n      'data-popper-reference-hidden': isReferenceHidden,\n      'data-popper-escaped': hasPopperEscaped\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var hide$1 = {\n    name: 'hide',\n    enabled: true,\n    phase: 'main',\n    requiresIfExists: ['preventOverflow'],\n    fn: hide\n  };\n  function distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n        placement: placement\n      })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [left, right].indexOf(basePlacement) >= 0 ? {\n      x: distance,\n      y: skidding\n    } : {\n      x: skidding,\n      y: distance\n    };\n  }\n  function offset(_ref2) {\n    var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n    var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n    var data = placements.reduce(function (acc, placement) {\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n      return acc;\n    }, {});\n    var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n      state.modifiersData.popperOffsets.x += x;\n      state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var offset$1 = {\n    name: 'offset',\n    enabled: true,\n    phase: 'main',\n    requires: ['popperOffsets'],\n    fn: offset\n  };\n  function popperOffsets(_ref) {\n    var state = _ref.state,\n      name = _ref.name; // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n\n    state.modifiersData[name] = computeOffsets({\n      reference: state.rects.reference,\n      element: state.rects.popper,\n      strategy: 'absolute',\n      placement: state.placement\n    });\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var popperOffsets$1 = {\n    name: 'popperOffsets',\n    enabled: true,\n    phase: 'read',\n    fn: popperOffsets,\n    data: {}\n  };\n  function getAltAxis(axis) {\n    return axis === 'x' ? 'y' : 'x';\n  }\n  function preventOverflow(_ref) {\n    var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n    var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n      placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n      mainAxis: tetherOffsetValue,\n      altAxis: tetherOffsetValue\n    } : Object.assign({\n      mainAxis: 0,\n      altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n      x: 0,\n      y: 0\n    };\n    if (!popperOffsets) {\n      return;\n    }\n    if (checkMainAxis) {\n      var _offsetModifierState$;\n      var mainSide = mainAxis === 'y' ? top : left;\n      var altSide = mainAxis === 'y' ? bottom : right;\n      var len = mainAxis === 'y' ? 'height' : 'width';\n      var offset = popperOffsets[mainAxis];\n      var min$1 = offset + overflow[mainSide];\n      var max$1 = offset - overflow[altSide];\n      var additive = tether ? -popperRect[len] / 2 : 0;\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n      // outside the reference bounds\n\n      var arrowElement = state.elements.arrow;\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n        width: 0,\n        height: 0\n      };\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n      // to include its full size in the calculation. If the reference is small\n      // and near the edge of a boundary, the popper can overflow even if the\n      // reference is not overflowing as well (e.g. virtual elements with no\n      // width or height)\n\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n      var tetherMax = offset + maxOffset - offsetModifierValue;\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n      popperOffsets[mainAxis] = preventedOffset;\n      data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n      var _offsetModifierState$2;\n      var _mainSide = mainAxis === 'x' ? top : left;\n      var _altSide = mainAxis === 'x' ? bottom : right;\n      var _offset = popperOffsets[altAxis];\n      var _len = altAxis === 'y' ? 'height' : 'width';\n      var _min = _offset + overflow[_mainSide];\n      var _max = _offset - overflow[_altSide];\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n      popperOffsets[altAxis] = _preventedOffset;\n      data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n  } // eslint-disable-next-line import/no-unused-modules\n\n  var preventOverflow$1 = {\n    name: 'preventOverflow',\n    enabled: true,\n    phase: 'main',\n    fn: preventOverflow,\n    requiresIfExists: ['offset']\n  };\n  function getHTMLElementScroll(element) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  function getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n      return getWindowScroll(node);\n    } else {\n      return getHTMLElementScroll(node);\n    }\n  }\n  function isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n  } // Returns the composite rect of an element relative to its offsetParent.\n  // Composite means it takes into account transforms as well as layout.\n\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n      isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled);\n    var scroll = {\n      scrollLeft: 0,\n      scrollTop: 0\n    };\n    var offsets = {\n      x: 0,\n      y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n      if (getNodeName(offsetParent) !== 'body' ||\n      // https://github.com/popperjs/popper-core/issues/1078\n      isScrollParent(documentElement)) {\n        scroll = getNodeScroll(offsetParent);\n      }\n      if (isHTMLElement(offsetParent)) {\n        offsets = getBoundingClientRect(offsetParent, true);\n        offsets.x += offsetParent.clientLeft;\n        offsets.y += offsetParent.clientTop;\n      } else if (documentElement) {\n        offsets.x = getWindowScrollBarX(documentElement);\n      }\n    }\n    return {\n      x: rect.left + scroll.scrollLeft - offsets.x,\n      y: rect.top + scroll.scrollTop - offsets.y,\n      width: rect.width,\n      height: rect.height\n    };\n  }\n  function order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function (modifier) {\n      map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n\n    function sort(modifier) {\n      visited.add(modifier.name);\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n      requires.forEach(function (dep) {\n        if (!visited.has(dep)) {\n          var depModifier = map.get(dep);\n          if (depModifier) {\n            sort(depModifier);\n          }\n        }\n      });\n      result.push(modifier);\n    }\n    modifiers.forEach(function (modifier) {\n      if (!visited.has(modifier.name)) {\n        // check for visited object\n        sort(modifier);\n      }\n    });\n    return result;\n  }\n  function orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n\n    return modifierPhases.reduce(function (acc, phase) {\n      return acc.concat(orderedModifiers.filter(function (modifier) {\n        return modifier.phase === phase;\n      }));\n    }, []);\n  }\n  function debounce(fn) {\n    var pending;\n    return function () {\n      if (!pending) {\n        pending = new Promise(function (resolve) {\n          Promise.resolve().then(function () {\n            pending = undefined;\n            resolve(fn());\n          });\n        });\n      }\n      return pending;\n    };\n  }\n  function mergeByName(modifiers) {\n    var merged = modifiers.reduce(function (merged, current) {\n      var existing = merged[current.name];\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\n        options: Object.assign({}, existing.options, current.options),\n        data: Object.assign({}, existing.data, current.data)\n      }) : current;\n      return merged;\n    }, {}); // IE11 does not support Object.values\n\n    return Object.keys(merged).map(function (key) {\n      return merged[key];\n    });\n  }\n  var DEFAULT_OPTIONS = {\n    placement: 'bottom',\n    modifiers: [],\n    strategy: 'absolute'\n  };\n  function areValidElements() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return !args.some(function (element) {\n      return !(element && typeof element.getBoundingClientRect === 'function');\n    });\n  }\n  function popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n      generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n      if (options === void 0) {\n        options = defaultOptions;\n      }\n      var state = {\n        placement: 'bottom',\n        orderedModifiers: [],\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n        modifiersData: {},\n        elements: {\n          reference: reference,\n          popper: popper\n        },\n        attributes: {},\n        styles: {}\n      };\n      var effectCleanupFns = [];\n      var isDestroyed = false;\n      var instance = {\n        state: state,\n        setOptions: function setOptions(setOptionsAction) {\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n          cleanupModifierEffects();\n          state.options = Object.assign({}, defaultOptions, state.options, options);\n          state.scrollParents = {\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n            popper: listScrollParents(popper)\n          }; // Orders the modifiers based on their dependencies and `phase`\n          // properties\n\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\n            return m.enabled;\n          }); // Validate the provided modifiers so that the consumer will get warned\n\n          runModifierEffects();\n          return instance.update();\n        },\n        // Sync update – it will always be executed, even if not necessary. This\n        // is useful for low frequency updates where sync behavior simplifies the\n        // logic.\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\n        // prefer the async Popper#update method\n        forceUpdate: function forceUpdate() {\n          if (isDestroyed) {\n            return;\n          }\n          var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n          // anymore\n\n          if (!areValidElements(reference, popper)) {\n            return;\n          } // Store the reference and popper rects to be read by modifiers\n\n          state.rects = {\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n            popper: getLayoutRect(popper)\n          }; // Modifiers have the ability to reset the current update cycle. The\n          // most common use case for this is the `flip` modifier changing the\n          // placement, which then needs to re-run all the modifiers, because the\n          // logic was previously ran for the previous placement and is therefore\n          // stale/incorrect\n\n          state.reset = false;\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n          // is filled with the initial data specified by the modifier. This means\n          // it doesn't persist and is fresh on each update.\n          // To ensure persistent data, use `${name}#persistent`\n\n          state.orderedModifiers.forEach(function (modifier) {\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n          });\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\n            if (state.reset === true) {\n              state.reset = false;\n              index = -1;\n              continue;\n            }\n            var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n            if (typeof fn === 'function') {\n              state = fn({\n                state: state,\n                options: _options,\n                name: name,\n                instance: instance\n              }) || state;\n            }\n          }\n        },\n        // Async and optimistically optimized update – it will not be executed if\n        // not necessary (debounced to run at most once-per-tick)\n        update: debounce(function () {\n          return new Promise(function (resolve) {\n            instance.forceUpdate();\n            resolve(state);\n          });\n        }),\n        destroy: function destroy() {\n          cleanupModifierEffects();\n          isDestroyed = true;\n        }\n      };\n      if (!areValidElements(reference, popper)) {\n        return instance;\n      }\n      instance.setOptions(options).then(function (state) {\n        if (!isDestroyed && options.onFirstUpdate) {\n          options.onFirstUpdate(state);\n        }\n      }); // Modifiers have the ability to execute arbitrary code before the first\n      // update cycle runs. They will be executed in the same order as the update\n      // cycle. This is useful when a modifier adds some persistent data that\n      // other modifiers need to use, but the modifier is run after the dependent\n      // one.\n\n      function runModifierEffects() {\n        state.orderedModifiers.forEach(function (_ref3) {\n          var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n          if (typeof effect === 'function') {\n            var cleanupFn = effect({\n              state: state,\n              name: name,\n              instance: instance,\n              options: options\n            });\n            var noopFn = function noopFn() {};\n            effectCleanupFns.push(cleanupFn || noopFn);\n          }\n        });\n      }\n      function cleanupModifierEffects() {\n        effectCleanupFns.forEach(function (fn) {\n          return fn();\n        });\n        effectCleanupFns = [];\n      }\n      return instance;\n    };\n  }\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\n  var createPopper = /*#__PURE__*/popperGenerator({\n    defaultModifiers: defaultModifiers\n  }); // eslint-disable-next-line import/no-unused-modules\n\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _getCenteredStylePopperModifier() {\n    return [{\n      name: 'applyStyles',\n      fn: function fn(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function (name) {\n          if (name !== 'popper') {\n            return;\n          }\n          var style = {\n            position: 'fixed',\n            left: '50%',\n            top: '50%',\n            transform: 'translate(-50%, -50%)'\n          };\n          var attributes = state.attributes[name] || {};\n          var element = state.elements[name];\n          Object.assign(element.style, style);\n          Object.keys(attributes).forEach(function (name) {\n            var value = attributes[name];\n            if (value === false) {\n              element.removeAttribute(name);\n            } else {\n              element.setAttribute(name, value === true ? '' : value);\n            }\n          });\n        });\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: false\n      }\n    }];\n  }\n  /**\n   * Generates a modifier for popper that will help focus the element after it has\n   * been rendered\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The focus after render modifier configuration object\n   */\n\n  function generateFocusAfterRenderModifier(step) {\n    return {\n      name: 'focusAfterRender',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn() {\n        setTimeout(function () {\n          if (step.el) {\n            var focusOptions = {\n              preventScroll: true\n            };\n            step.el.focus(focusOptions);\n          }\n        }, 300);\n      }\n    };\n  }\n  /**\n   * Generates the array of options for a tooltip that doesn't have a\n   * target element in the DOM -- and thus is positioned in the center\n   * of the view\n   *\n   * @param {Step} step The step instance\n   * @return {Object} The final Popper options object\n   */\n\n  function makeCenteredPopper(step) {\n    var centeredStylePopperModifier = _getCenteredStylePopperModifier();\n    var popperOptions = {\n      placement: 'top',\n      strategy: 'fixed',\n      modifiers: [generateFocusAfterRenderModifier(step)]\n    };\n    popperOptions = _extends({}, popperOptions, {\n      modifiers: Array.from(new Set([].concat(_toConsumableArray(popperOptions.modifiers), _toConsumableArray(centeredStylePopperModifier))))\n    });\n    return popperOptions;\n  }\n\n  /**\n   * Ensure class prefix ends in `-`\n   * @param {string} prefix The prefix to prepend to the class names generated by nano-css\n   * @return {string} The prefix ending in `-`\n   */\n\n  function normalizePrefix(prefix) {\n    if (!isString(prefix) || prefix === '') {\n      return '';\n    }\n    return prefix.charAt(prefix.length - 1) !== '-' ? \"\".concat(prefix, \"-\") : prefix;\n  }\n  /**\n   * Resolves attachTo options, converting element option value to a qualified HTMLElement.\n   * @param {Step} step The step instance\n   * @returns {{}|{element, on}}\n   * `element` is a qualified HTML Element\n   * `on` is a string position value\n   */\n\n  function parseAttachTo(step) {\n    var options = step.options.attachTo || {};\n    var returnOpts = Object.assign({}, options);\n    if (isFunction(returnOpts.element)) {\n      // Bind the callback to step so that it has access to the object, to enable running additional logic\n      returnOpts.element = returnOpts.element.call(step);\n    }\n    if (isString(returnOpts.element)) {\n      // Can't override the element in user opts reference because we can't\n      // guarantee that the element will exist in the future.\n      try {\n        returnOpts.element = document.querySelector(returnOpts.element);\n      } catch (e) {// TODO\n      }\n      if (!returnOpts.element) {\n        console.error(\"The element for this Shepherd step was not found \".concat(options.element));\n      }\n    }\n    return returnOpts;\n  }\n  /**\n   * Checks if the step should be centered or not. Does not trigger attachTo.element evaluation, making it a pure\n   * alternative for the deprecated step.isCentered() method.\n   * @param resolvedAttachToOptions\n   * @returns {boolean}\n   */\n\n  function shouldCenterStep(resolvedAttachToOptions) {\n    if (resolvedAttachToOptions === undefined || resolvedAttachToOptions === null) {\n      return true;\n    }\n    return !resolvedAttachToOptions.element || !resolvedAttachToOptions.on;\n  }\n  /**\n   * Determines options for the tooltip and initializes\n   * `step.tooltip` as a Popper instance.\n   * @param {Step} step The step instance\n   */\n\n  function setupTooltip(step) {\n    if (step.tooltip) {\n      step.tooltip.destroy();\n    }\n    var attachToOptions = step._getResolvedAttachToOptions();\n    var target = attachToOptions.element;\n    var popperOptions = getPopperOptions(attachToOptions, step);\n    if (shouldCenterStep(attachToOptions)) {\n      target = document.body;\n      var content = step.shepherdElementComponent.getElement();\n      content.classList.add('shepherd-centered');\n    }\n    step.tooltip = createPopper(target, step.el, popperOptions);\n    step.target = attachToOptions.element;\n    return popperOptions;\n  }\n  /**\n   * Create a unique id for steps, tours, modals, etc\n   * @return {string}\n   */\n\n  function uuid() {\n    var d = Date.now();\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n      var r = (d + Math.random() * 16) % 16 | 0;\n      d = Math.floor(d / 16);\n      return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n  }\n  /**\n   * Gets the `Popper` options from a set of base `attachTo` options\n   * @param attachToOptions\n   * @param {Step} step The step instance\n   * @return {Object}\n   * @private\n   */\n\n  function getPopperOptions(attachToOptions, step) {\n    var popperOptions = {\n      modifiers: [{\n        name: 'preventOverflow',\n        options: {\n          altAxis: true,\n          tether: false\n        }\n      }, generateFocusAfterRenderModifier(step)],\n      strategy: 'absolute'\n    };\n    if (shouldCenterStep(attachToOptions)) {\n      popperOptions = makeCenteredPopper(step);\n    } else {\n      popperOptions.placement = attachToOptions.on;\n    }\n    var defaultStepOptions = step.tour && step.tour.options && step.tour.options.defaultStepOptions;\n    if (defaultStepOptions) {\n      popperOptions = _mergeModifiers(defaultStepOptions, popperOptions);\n    }\n    popperOptions = _mergeModifiers(step.options, popperOptions);\n    return popperOptions;\n  }\n  function _mergeModifiers(stepOptions, popperOptions) {\n    if (stepOptions.popperOptions) {\n      var mergedPopperOptions = Object.assign({}, popperOptions, stepOptions.popperOptions);\n      if (stepOptions.popperOptions.modifiers && stepOptions.popperOptions.modifiers.length > 0) {\n        var names = stepOptions.popperOptions.modifiers.map(function (mod) {\n          return mod.name;\n        });\n        var filteredModifiers = popperOptions.modifiers.filter(function (mod) {\n          return !names.includes(mod.name);\n        });\n        mergedPopperOptions.modifiers = Array.from(new Set([].concat(_toConsumableArray(filteredModifiers), _toConsumableArray(stepOptions.popperOptions.modifiers))));\n      }\n      return mergedPopperOptions;\n    }\n    return popperOptions;\n  }\n  function noop() {}\n  function assign(tar, src) {\n    // @ts-ignore\n    for (var k in src) {\n      tar[k] = src[k];\n    }\n    return tar;\n  }\n  function run(fn) {\n    return fn();\n  }\n  function blank_object() {\n    return Object.create(null);\n  }\n  function run_all(fns) {\n    fns.forEach(run);\n  }\n  function is_function(thing) {\n    return typeof thing === 'function';\n  }\n  function safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n  }\n  function is_empty(obj) {\n    return Object.keys(obj).length === 0;\n  }\n  function append(target, node) {\n    target.appendChild(node);\n  }\n  function insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n  }\n  function detach(node) {\n    node.parentNode.removeChild(node);\n  }\n  function destroy_each(iterations, detaching) {\n    for (var i = 0; i < iterations.length; i += 1) {\n      if (iterations[i]) iterations[i].d(detaching);\n    }\n  }\n  function element(name) {\n    return document.createElement(name);\n  }\n  function svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n  }\n  function text(data) {\n    return document.createTextNode(data);\n  }\n  function space() {\n    return text(' ');\n  }\n  function empty() {\n    return text('');\n  }\n  function listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return function () {\n      return node.removeEventListener(event, handler, options);\n    };\n  }\n  function attr(node, attribute, value) {\n    if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n  }\n  function set_attributes(node, attributes) {\n    // @ts-ignore\n    var descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (var key in attributes) {\n      if (attributes[key] == null) {\n        node.removeAttribute(key);\n      } else if (key === 'style') {\n        node.style.cssText = attributes[key];\n      } else if (key === '__value') {\n        node.value = node[key] = attributes[key];\n      } else if (descriptors[key] && descriptors[key].set) {\n        node[key] = attributes[key];\n      } else {\n        attr(node, key, attributes[key]);\n      }\n    }\n  }\n  function children(element) {\n    return Array.from(element.childNodes);\n  }\n  function toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n  }\n  var current_component;\n  function set_current_component(component) {\n    current_component = component;\n  }\n  function get_current_component() {\n    if (!current_component) throw new Error('Function called outside component initialization');\n    return current_component;\n  }\n  function onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n  }\n  function afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n  }\n  var dirty_components = [];\n  var binding_callbacks = [];\n  var render_callbacks = [];\n  var flush_callbacks = [];\n  var resolved_promise = Promise.resolve();\n  var update_scheduled = false;\n  function schedule_update() {\n    if (!update_scheduled) {\n      update_scheduled = true;\n      resolved_promise.then(flush);\n    }\n  }\n  function add_render_callback(fn) {\n    render_callbacks.push(fn);\n  }\n  // 1. All beforeUpdate callbacks, in order: parents before children\n  // 2. All bind:this callbacks, in reverse order: children before parents.\n  // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT\n  //    for afterUpdates called during the initial onMount, which are called in\n  //    reverse order: children before parents.\n  // Since callbacks might update component values, which could trigger another\n  // call to flush(), the following steps guard against this:\n  // 1. During beforeUpdate, any updated components will be added to the\n  //    dirty_components array and will cause a reentrant call to flush(). Because\n  //    the flush index is kept outside the function, the reentrant call will pick\n  //    up where the earlier call left off and go through all dirty components. The\n  //    current_component value is saved and restored so that the reentrant call will\n  //    not interfere with the \"parent\" flush() call.\n  // 2. bind:this callbacks cannot trigger new flush() calls.\n  // 3. During afterUpdate, any updated components will NOT have their afterUpdate\n  //    callback called a second time; the seen_callbacks set, outside the flush()\n  //    function, guarantees this behavior.\n\n  var seen_callbacks = new Set();\n  var flushidx = 0; // Do *not* move this inside the flush() function\n\n  function flush() {\n    var saved_component = current_component;\n    do {\n      // first, call beforeUpdate functions\n      // and update components\n      while (flushidx < dirty_components.length) {\n        var component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n      set_current_component(null);\n      dirty_components.length = 0;\n      flushidx = 0;\n      while (binding_callbacks.length) {\n        binding_callbacks.pop()();\n      } // then, once components are updated, call\n      // afterUpdate functions. This may cause\n      // subsequent updates...\n\n      for (var i = 0; i < render_callbacks.length; i += 1) {\n        var callback = render_callbacks[i];\n        if (!seen_callbacks.has(callback)) {\n          // ...so guard against infinite loops\n          seen_callbacks.add(callback);\n          callback();\n        }\n      }\n      render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n      flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    seen_callbacks.clear();\n    set_current_component(saved_component);\n  }\n  function update($$) {\n    if ($$.fragment !== null) {\n      $$.update();\n      run_all($$.before_update);\n      var dirty = $$.dirty;\n      $$.dirty = [-1];\n      $$.fragment && $$.fragment.p($$.ctx, dirty);\n      $$.after_update.forEach(add_render_callback);\n    }\n  }\n  var outroing = new Set();\n  var outros;\n  function group_outros() {\n    outros = {\n      r: 0,\n      c: [],\n      p: outros // parent group\n    };\n  }\n\n  function check_outros() {\n    if (!outros.r) {\n      run_all(outros.c);\n    }\n    outros = outros.p;\n  }\n  function transition_in(block, local) {\n    if (block && block.i) {\n      outroing.delete(block);\n      block.i(local);\n    }\n  }\n  function transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n      if (outroing.has(block)) return;\n      outroing.add(block);\n      outros.c.push(function () {\n        outroing.delete(block);\n        if (callback) {\n          if (detach) block.d(1);\n          callback();\n        }\n      });\n      block.o(local);\n    } else if (callback) {\n      callback();\n    }\n  }\n  function get_spread_update(levels, updates) {\n    var update = {};\n    var to_null_out = {};\n    var accounted_for = {\n      $$scope: 1\n    };\n    var i = levels.length;\n    while (i--) {\n      var o = levels[i];\n      var n = updates[i];\n      if (n) {\n        for (var key in o) {\n          if (!(key in n)) to_null_out[key] = 1;\n        }\n        for (var _key2 in n) {\n          if (!accounted_for[_key2]) {\n            update[_key2] = n[_key2];\n            accounted_for[_key2] = 1;\n          }\n        }\n        levels[i] = n;\n      } else {\n        for (var _key3 in o) {\n          accounted_for[_key3] = 1;\n        }\n      }\n    }\n    for (var _key4 in to_null_out) {\n      if (!(_key4 in update)) update[_key4] = undefined;\n    }\n    return update;\n  }\n  function create_component(block) {\n    block && block.c();\n  }\n  function mount_component(component, target, anchor, customElement) {\n    var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n      // onMount happens before the initial afterUpdate\n      add_render_callback(function () {\n        var new_on_destroy = on_mount.map(run).filter(is_function);\n        if (on_destroy) {\n          on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n        } else {\n          // Edge case - component was destroyed immediately,\n          // most likely as a result of a binding initialising\n          run_all(new_on_destroy);\n        }\n        component.$$.on_mount = [];\n      });\n    }\n    after_update.forEach(add_render_callback);\n  }\n  function destroy_component(component, detaching) {\n    var $$ = component.$$;\n    if ($$.fragment !== null) {\n      run_all($$.on_destroy);\n      $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n      // preserve final state?)\n\n      $$.on_destroy = $$.fragment = null;\n      $$.ctx = [];\n    }\n  }\n  function make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n      dirty_components.push(component);\n      schedule_update();\n      component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n  }\n  function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty) {\n    if (dirty === void 0) {\n      dirty = [-1];\n    }\n    var parent_component = current_component;\n    set_current_component(component);\n    var $$ = component.$$ = {\n      fragment: null,\n      ctx: null,\n      // state\n      props: props,\n      update: noop,\n      not_equal: not_equal,\n      bound: blank_object(),\n      // lifecycle\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n      // everything else\n      callbacks: blank_object(),\n      dirty: dirty,\n      skip_bound: false,\n      root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    var ready = false;\n    $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n      var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n        if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n        if (ready) make_dirty(component, i);\n      }\n      return ret;\n    }) : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update); // `false` as a special case of no DOM component\n\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n      if (options.hydrate) {\n        var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        $$.fragment && $$.fragment.l(nodes);\n        nodes.forEach(detach);\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        $$.fragment && $$.fragment.c();\n      }\n      if (options.intro) transition_in(component.$$.fragment);\n      mount_component(component, options.target, options.anchor, options.customElement);\n      flush();\n    }\n    set_current_component(parent_component);\n  }\n  /**\n   * Base class for Svelte components. Used when dev=false.\n   */\n  var SvelteComponent = /*#__PURE__*/function () {\n    function SvelteComponent() {\n      _classCallCheck(this, SvelteComponent);\n    }\n    _createClass(SvelteComponent, [{\n      key: \"$destroy\",\n      value: function $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n      }\n    }, {\n      key: \"$on\",\n      value: function $on(type, callback) {\n        var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n        callbacks.push(callback);\n        return function () {\n          var index = callbacks.indexOf(callback);\n          if (index !== -1) callbacks.splice(index, 1);\n        };\n      }\n    }, {\n      key: \"$set\",\n      value: function $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n          this.$$.skip_bound = true;\n          this.$$set($$props);\n          this.$$.skip_bound = false;\n        }\n      }\n    }]);\n    return SvelteComponent;\n  }();\n  /* src/js/components/shepherd-button.svelte generated by Svelte v3.49.0 */\n  function create_fragment$8(ctx) {\n    var button;\n    var button_aria_label_value;\n    var button_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        attr(button, \"aria-label\", button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null);\n        attr(button, \"class\", button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''));\n        button.disabled = /*disabled*/\n        ctx[2];\n        attr(button, \"tabindex\", \"0\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        button.innerHTML = /*text*/\n        ctx[5];\n        if (!mounted) {\n          dispose = listen(button, \"click\", function () {\n            if (is_function( /*action*/\n            ctx[0])) /*action*/\n              ctx[0].apply(this, arguments);\n          });\n          mounted = true;\n        }\n      },\n      p: function p(new_ctx, _ref) {\n        var _ref7 = _slicedToArray(_ref, 1),\n          dirty = _ref7[0];\n        ctx = new_ctx;\n        if (dirty & /*text*/\n        32) button.innerHTML = /*text*/\n        ctx[5];\n        if (dirty & /*label*/\n        8 && button_aria_label_value !== (button_aria_label_value = /*label*/\n        ctx[3] ? /*label*/\n        ctx[3] : null)) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n        if (dirty & /*classes, secondary*/\n        18 && button_class_value !== (button_class_value = \"\".concat( /*classes*/\n        ctx[1] || '', \" shepherd-button \").concat( /*secondary*/\n        ctx[4] ? 'shepherd-button-secondary' : ''))) {\n          attr(button, \"class\", button_class_value);\n        }\n        if (dirty & /*disabled*/\n        4) {\n          button.disabled = /*disabled*/\n          ctx[2];\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$8($$self, $$props, $$invalidate) {\n    var config = $$props.config,\n      step = $$props.step;\n    var action, classes, disabled, label, secondary, text;\n    function getConfigOption(option) {\n      if (isFunction(option)) {\n        return option = option.call(step);\n      }\n      return option;\n    }\n    $$self.$$set = function ($$props) {\n      if ('config' in $$props) $$invalidate(6, config = $$props.config);\n      if ('step' in $$props) $$invalidate(7, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*config, step*/\n      192) {\n        {\n          $$invalidate(0, action = config.action ? config.action.bind(step.tour) : null);\n          $$invalidate(1, classes = config.classes);\n          $$invalidate(2, disabled = config.disabled ? getConfigOption(config.disabled) : false);\n          $$invalidate(3, label = config.label ? getConfigOption(config.label) : null);\n          $$invalidate(4, secondary = config.secondary);\n          $$invalidate(5, text = config.text ? getConfigOption(config.text) : null);\n        }\n      }\n    };\n    return [action, classes, disabled, label, secondary, text, config, step];\n  }\n  var Shepherd_button = /*#__PURE__*/function (_SvelteComponent) {\n    _inherits(Shepherd_button, _SvelteComponent);\n    var _super = _createSuper(Shepherd_button);\n    function Shepherd_button(options) {\n      var _this3;\n      _classCallCheck(this, Shepherd_button);\n      _this3 = _super.call(this);\n      init(_assertThisInitialized(_this3), options, instance$8, create_fragment$8, safe_not_equal, {\n        config: 6,\n        step: 7\n      });\n      return _this3;\n    }\n    return _createClass(Shepherd_button);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-footer.svelte generated by Svelte v3.49.0 */\n  function get_each_context(ctx, list, i) {\n    var child_ctx = ctx.slice();\n    child_ctx[2] = list[i];\n    return child_ctx;\n  } // (24:4) {#if buttons}\n\n  function create_if_block$3(ctx) {\n    var each_1_anchor;\n    var current;\n    var each_value = /*buttons*/\n    ctx[1];\n    var each_blocks = [];\n    for (var i = 0; i < each_value.length; i += 1) {\n      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));\n    }\n    var out = function out(i) {\n      return transition_out(each_blocks[i], 1, 1, function () {\n        each_blocks[i] = null;\n      });\n    };\n    return {\n      c: function c() {\n        for (var _i2 = 0; _i2 < each_blocks.length; _i2 += 1) {\n          each_blocks[_i2].c();\n        }\n        each_1_anchor = empty();\n      },\n      m: function m(target, anchor) {\n        for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n          each_blocks[_i3].m(target, anchor);\n        }\n        insert(target, each_1_anchor, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        if (dirty & /*buttons, step*/\n        3) {\n          each_value = /*buttons*/\n          ctx[1];\n          var _i4;\n          for (_i4 = 0; _i4 < each_value.length; _i4 += 1) {\n            var child_ctx = get_each_context(ctx, each_value, _i4);\n            if (each_blocks[_i4]) {\n              each_blocks[_i4].p(child_ctx, dirty);\n              transition_in(each_blocks[_i4], 1);\n            } else {\n              each_blocks[_i4] = create_each_block(child_ctx);\n              each_blocks[_i4].c();\n              transition_in(each_blocks[_i4], 1);\n              each_blocks[_i4].m(each_1_anchor.parentNode, each_1_anchor);\n            }\n          }\n          group_outros();\n          for (_i4 = each_value.length; _i4 < each_blocks.length; _i4 += 1) {\n            out(_i4);\n          }\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n          transition_in(each_blocks[_i5]);\n        }\n        current = true;\n      },\n      o: function o(local) {\n        each_blocks = each_blocks.filter(Boolean);\n        for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n          transition_out(each_blocks[_i6]);\n        }\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_each(each_blocks, detaching);\n        if (detaching) detach(each_1_anchor);\n      }\n    };\n  } // (25:8) {#each buttons as config}\n\n  function create_each_block(ctx) {\n    var shepherdbutton;\n    var current;\n    shepherdbutton = new Shepherd_button({\n      props: {\n        config: /*config*/\n        ctx[2],\n        step: /*step*/\n        ctx[0]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdbutton.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdbutton, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdbutton_changes = {};\n        if (dirty & /*buttons*/\n        2) shepherdbutton_changes.config = /*config*/\n        ctx[2];\n        if (dirty & /*step*/\n        1) shepherdbutton_changes.step = /*step*/\n        ctx[0];\n        shepherdbutton.$set(shepherdbutton_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdbutton.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdbutton.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdbutton, detaching);\n      }\n    };\n  }\n  function create_fragment$7(ctx) {\n    var footer;\n    var current;\n    var if_block = /*buttons*/\n    ctx[1] && create_if_block$3(ctx);\n    return {\n      c: function c() {\n        footer = element(\"footer\");\n        if (if_block) if_block.c();\n        attr(footer, \"class\", \"shepherd-footer\");\n      },\n      m: function m(target, anchor) {\n        insert(target, footer, anchor);\n        if (if_block) if_block.m(footer, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref8 = _slicedToArray(_ref, 1),\n          dirty = _ref8[0];\n        if ( /*buttons*/\n        ctx[1]) {\n          if (if_block) {\n            if_block.p(ctx, dirty);\n            if (dirty & /*buttons*/\n            2) {\n              transition_in(if_block, 1);\n            }\n          } else {\n            if_block = create_if_block$3(ctx);\n            if_block.c();\n            transition_in(if_block, 1);\n            if_block.m(footer, null);\n          }\n        } else if (if_block) {\n          group_outros();\n          transition_out(if_block, 1, 1, function () {\n            if_block = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(footer);\n        if (if_block) if_block.d();\n      }\n    };\n  }\n  function instance$7($$self, $$props, $$invalidate) {\n    var buttons;\n    var step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('step' in $$props) $$invalidate(0, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      1) {\n        $$invalidate(1, buttons = step.options.buttons);\n      }\n    };\n    return [step, buttons];\n  }\n  var Shepherd_footer = /*#__PURE__*/function (_SvelteComponent2) {\n    _inherits(Shepherd_footer, _SvelteComponent2);\n    var _super2 = _createSuper(Shepherd_footer);\n    function Shepherd_footer(options) {\n      var _this4;\n      _classCallCheck(this, Shepherd_footer);\n      _this4 = _super2.call(this);\n      init(_assertThisInitialized(_this4), options, instance$7, create_fragment$7, safe_not_equal, {\n        step: 0\n      });\n      return _this4;\n    }\n    return _createClass(Shepherd_footer);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-cancel-icon.svelte generated by Svelte v3.49.0 */\n  function create_fragment$6(ctx) {\n    var button;\n    var span;\n    var button_aria_label_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        button = element(\"button\");\n        span = element(\"span\");\n        span.textContent = \"×\";\n        attr(span, \"aria-hidden\", \"true\");\n        attr(button, \"aria-label\", button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour');\n        attr(button, \"class\", \"shepherd-cancel-icon\");\n        attr(button, \"type\", \"button\");\n      },\n      m: function m(target, anchor) {\n        insert(target, button, anchor);\n        append(button, span);\n        if (!mounted) {\n          dispose = listen(button, \"click\", /*handleCancelClick*/\n          ctx[1]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref9 = _slicedToArray(_ref, 1),\n          dirty = _ref9[0];\n        if (dirty & /*cancelIcon*/\n        1 && button_aria_label_value !== (button_aria_label_value = /*cancelIcon*/\n        ctx[0].label ? /*cancelIcon*/\n        ctx[0].label : 'Close Tour')) {\n          attr(button, \"aria-label\", button_aria_label_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(button);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function instance$6($$self, $$props, $$invalidate) {\n    var cancelIcon = $$props.cancelIcon,\n      step = $$props.step;\n    /**\n    * Add a click listener to the cancel link that cancels the tour\n    */\n\n    var handleCancelClick = function handleCancelClick(e) {\n      e.preventDefault();\n      step.cancel();\n    };\n    $$self.$$set = function ($$props) {\n      if ('cancelIcon' in $$props) $$invalidate(0, cancelIcon = $$props.cancelIcon);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [cancelIcon, handleCancelClick, step];\n  }\n  var Shepherd_cancel_icon = /*#__PURE__*/function (_SvelteComponent3) {\n    _inherits(Shepherd_cancel_icon, _SvelteComponent3);\n    var _super3 = _createSuper(Shepherd_cancel_icon);\n    function Shepherd_cancel_icon(options) {\n      var _this5;\n      _classCallCheck(this, Shepherd_cancel_icon);\n      _this5 = _super3.call(this);\n      init(_assertThisInitialized(_this5), options, instance$6, create_fragment$6, safe_not_equal, {\n        cancelIcon: 0,\n        step: 2\n      });\n      return _this5;\n    }\n    return _createClass(Shepherd_cancel_icon);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-title.svelte generated by Svelte v3.49.0 */\n  function create_fragment$5(ctx) {\n    var h3;\n    return {\n      c: function c() {\n        h3 = element(\"h3\");\n        attr(h3, \"id\", /*labelId*/\n        ctx[1]);\n        attr(h3, \"class\", \"shepherd-title\");\n      },\n      m: function m(target, anchor) {\n        insert(target, h3, anchor);\n        /*h3_binding*/\n\n        ctx[3](h3);\n      },\n      p: function p(ctx, _ref) {\n        var _ref10 = _slicedToArray(_ref, 1),\n          dirty = _ref10[0];\n        if (dirty & /*labelId*/\n        2) {\n          attr(h3, \"id\", /*labelId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(h3);\n        /*h3_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$5($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      element = $$props.element,\n      title = $$props.title;\n    afterUpdate(function () {\n      if (isFunction(title)) {\n        $$invalidate(2, title = title());\n      }\n      $$invalidate(0, element.innerHTML = title, element);\n    });\n    function h3_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('title' in $$props) $$invalidate(2, title = $$props.title);\n    };\n    return [element, labelId, title, h3_binding];\n  }\n  var Shepherd_title = /*#__PURE__*/function (_SvelteComponent4) {\n    _inherits(Shepherd_title, _SvelteComponent4);\n    var _super4 = _createSuper(Shepherd_title);\n    function Shepherd_title(options) {\n      var _this6;\n      _classCallCheck(this, Shepherd_title);\n      _this6 = _super4.call(this);\n      init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n        labelId: 1,\n        element: 0,\n        title: 2\n      });\n      return _this6;\n    }\n    return _createClass(Shepherd_title);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-header.svelte generated by Svelte v3.49.0 */\n  function create_if_block_1$1(ctx) {\n    var shepherdtitle;\n    var current;\n    shepherdtitle = new Shepherd_title({\n      props: {\n        labelId: /*labelId*/\n        ctx[0],\n        title: /*title*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtitle.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtitle, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtitle_changes = {};\n        if (dirty & /*labelId*/\n        1) shepherdtitle_changes.labelId = /*labelId*/\n        ctx[0];\n        if (dirty & /*title*/\n        4) shepherdtitle_changes.title = /*title*/\n        ctx[2];\n        shepherdtitle.$set(shepherdtitle_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtitle.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtitle.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtitle, detaching);\n      }\n    };\n  } // (39:4) {#if cancelIcon && cancelIcon.enabled}\n\n  function create_if_block$2(ctx) {\n    var shepherdcancelicon;\n    var current;\n    shepherdcancelicon = new Shepherd_cancel_icon({\n      props: {\n        cancelIcon: /*cancelIcon*/\n        ctx[3],\n        step: /*step*/\n        ctx[1]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdcancelicon.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdcancelicon, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdcancelicon_changes = {};\n        if (dirty & /*cancelIcon*/\n        8) shepherdcancelicon_changes.cancelIcon = /*cancelIcon*/\n        ctx[3];\n        if (dirty & /*step*/\n        2) shepherdcancelicon_changes.step = /*step*/\n        ctx[1];\n        shepherdcancelicon.$set(shepherdcancelicon_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcancelicon.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcancelicon.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdcancelicon, detaching);\n      }\n    };\n  }\n  function create_fragment$4(ctx) {\n    var header;\n    var t;\n    var current;\n    var if_block0 = /*title*/\n    ctx[2] && create_if_block_1$1(ctx);\n    var if_block1 = /*cancelIcon*/\n    ctx[3] && /*cancelIcon*/\n    ctx[3].enabled && create_if_block$2(ctx);\n    return {\n      c: function c() {\n        header = element(\"header\");\n        if (if_block0) if_block0.c();\n        t = space();\n        if (if_block1) if_block1.c();\n        attr(header, \"class\", \"shepherd-header\");\n      },\n      m: function m(target, anchor) {\n        insert(target, header, anchor);\n        if (if_block0) if_block0.m(header, null);\n        append(header, t);\n        if (if_block1) if_block1.m(header, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref11 = _slicedToArray(_ref, 1),\n          dirty = _ref11[0];\n        if ( /*title*/\n        ctx[2]) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*title*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_1$1(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(header, t);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if ( /*cancelIcon*/\n        ctx[3] && /*cancelIcon*/\n        ctx[3].enabled) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*cancelIcon*/\n            8) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block$2(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(header, null);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(header);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n      }\n    };\n  }\n  function instance$4($$self, $$props, $$invalidate) {\n    var labelId = $$props.labelId,\n      step = $$props.step;\n    var title, cancelIcon;\n    $$self.$$set = function ($$props) {\n      if ('labelId' in $$props) $$invalidate(0, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(1, step = $$props.step);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      2) {\n        {\n          $$invalidate(2, title = step.options.title);\n          $$invalidate(3, cancelIcon = step.options.cancelIcon);\n        }\n      }\n    };\n    return [labelId, step, title, cancelIcon];\n  }\n  var Shepherd_header = /*#__PURE__*/function (_SvelteComponent5) {\n    _inherits(Shepherd_header, _SvelteComponent5);\n    var _super5 = _createSuper(Shepherd_header);\n    function Shepherd_header(options) {\n      var _this7;\n      _classCallCheck(this, Shepherd_header);\n      _this7 = _super5.call(this);\n      init(_assertThisInitialized(_this7), options, instance$4, create_fragment$4, safe_not_equal, {\n        labelId: 0,\n        step: 1\n      });\n      return _this7;\n    }\n    return _createClass(Shepherd_header);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-text.svelte generated by Svelte v3.49.0 */\n  function create_fragment$3(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-text\");\n        attr(div, \"id\", /*descriptionId*/\n        ctx[1]);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        /*div_binding*/\n\n        ctx[3](div);\n      },\n      p: function p(ctx, _ref) {\n        var _ref12 = _slicedToArray(_ref, 1),\n          dirty = _ref12[0];\n        if (dirty & /*descriptionId*/\n        2) {\n          attr(div, \"id\", /*descriptionId*/\n          ctx[1]);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        /*div_binding*/\n\n        ctx[3](null);\n      }\n    };\n  }\n  function instance$3($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      element = $$props.element,\n      step = $$props.step;\n    afterUpdate(function () {\n      var text = step.options.text;\n      if (isFunction(text)) {\n        text = text.call(step);\n      }\n      if (isHTMLElement$1(text)) {\n        element.appendChild(text);\n      } else {\n        $$invalidate(0, element.innerHTML = text, element);\n      }\n    });\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(1, descriptionId = $$props.descriptionId);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [element, descriptionId, step, div_binding];\n  }\n  var Shepherd_text = /*#__PURE__*/function (_SvelteComponent6) {\n    _inherits(Shepherd_text, _SvelteComponent6);\n    var _super6 = _createSuper(Shepherd_text);\n    function Shepherd_text(options) {\n      var _this8;\n      _classCallCheck(this, Shepherd_text);\n      _this8 = _super6.call(this);\n      init(_assertThisInitialized(_this8), options, instance$3, create_fragment$3, safe_not_equal, {\n        descriptionId: 1,\n        element: 0,\n        step: 2\n      });\n      return _this8;\n    }\n    return _createClass(Shepherd_text);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-content.svelte generated by Svelte v3.49.0 */\n  function create_if_block_2(ctx) {\n    var shepherdheader;\n    var current;\n    shepherdheader = new Shepherd_header({\n      props: {\n        labelId: /*labelId*/\n        ctx[1],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdheader.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdheader, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdheader_changes = {};\n        if (dirty & /*labelId*/\n        2) shepherdheader_changes.labelId = /*labelId*/\n        ctx[1];\n        if (dirty & /*step*/\n        4) shepherdheader_changes.step = /*step*/\n        ctx[2];\n        shepherdheader.$set(shepherdheader_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdheader.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdheader.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdheader, detaching);\n      }\n    };\n  } // (28:2) {#if !isUndefined(step.options.text)}\n\n  function create_if_block_1(ctx) {\n    var shepherdtext;\n    var current;\n    shepherdtext = new Shepherd_text({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[0],\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdtext.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdtext, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdtext_changes = {};\n        if (dirty & /*descriptionId*/\n        1) shepherdtext_changes.descriptionId = /*descriptionId*/\n        ctx[0];\n        if (dirty & /*step*/\n        4) shepherdtext_changes.step = /*step*/\n        ctx[2];\n        shepherdtext.$set(shepherdtext_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdtext.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdtext.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdtext, detaching);\n      }\n    };\n  } // (35:2) {#if Array.isArray(step.options.buttons) && step.options.buttons.length}\n\n  function create_if_block$1(ctx) {\n    var shepherdfooter;\n    var current;\n    shepherdfooter = new Shepherd_footer({\n      props: {\n        step: /*step*/\n        ctx[2]\n      }\n    });\n    return {\n      c: function c() {\n        create_component(shepherdfooter.$$.fragment);\n      },\n      m: function m(target, anchor) {\n        mount_component(shepherdfooter, target, anchor);\n        current = true;\n      },\n      p: function p(ctx, dirty) {\n        var shepherdfooter_changes = {};\n        if (dirty & /*step*/\n        4) shepherdfooter_changes.step = /*step*/\n        ctx[2];\n        shepherdfooter.$set(shepherdfooter_changes);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdfooter.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdfooter.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        destroy_component(shepherdfooter, detaching);\n      }\n    };\n  }\n  function create_fragment$2(ctx) {\n    var div;\n    var show_if_2 = !isUndefined( /*step*/\n    ctx[2].options.title) || /*step*/\n    ctx[2].options.cancelIcon && /*step*/\n    ctx[2].options.cancelIcon.enabled;\n    var t0;\n    var show_if_1 = !isUndefined( /*step*/\n    ctx[2].options.text);\n    var t1;\n    var show_if = Array.isArray( /*step*/\n    ctx[2].options.buttons) && /*step*/\n    ctx[2].options.buttons.length;\n    var current;\n    var if_block0 = show_if_2 && create_if_block_2(ctx);\n    var if_block1 = show_if_1 && create_if_block_1(ctx);\n    var if_block2 = show_if && create_if_block$1(ctx);\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block0) if_block0.c();\n        t0 = space();\n        if (if_block1) if_block1.c();\n        t1 = space();\n        if (if_block2) if_block2.c();\n        attr(div, \"class\", \"shepherd-content\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block0) if_block0.m(div, null);\n        append(div, t0);\n        if (if_block1) if_block1.m(div, null);\n        append(div, t1);\n        if (if_block2) if_block2.m(div, null);\n        current = true;\n      },\n      p: function p(ctx, _ref) {\n        var _ref13 = _slicedToArray(_ref, 1),\n          dirty = _ref13[0];\n        if (dirty & /*step*/\n        4) show_if_2 = !isUndefined( /*step*/\n        ctx[2].options.title) || /*step*/\n        ctx[2].options.cancelIcon && /*step*/\n        ctx[2].options.cancelIcon.enabled;\n        if (show_if_2) {\n          if (if_block0) {\n            if_block0.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block0, 1);\n            }\n          } else {\n            if_block0 = create_if_block_2(ctx);\n            if_block0.c();\n            transition_in(if_block0, 1);\n            if_block0.m(div, t0);\n          }\n        } else if (if_block0) {\n          group_outros();\n          transition_out(if_block0, 1, 1, function () {\n            if_block0 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if_1 = !isUndefined( /*step*/\n        ctx[2].options.text);\n        if (show_if_1) {\n          if (if_block1) {\n            if_block1.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block1, 1);\n            }\n          } else {\n            if_block1 = create_if_block_1(ctx);\n            if_block1.c();\n            transition_in(if_block1, 1);\n            if_block1.m(div, t1);\n          }\n        } else if (if_block1) {\n          group_outros();\n          transition_out(if_block1, 1, 1, function () {\n            if_block1 = null;\n          });\n          check_outros();\n        }\n        if (dirty & /*step*/\n        4) show_if = Array.isArray( /*step*/\n        ctx[2].options.buttons) && /*step*/\n        ctx[2].options.buttons.length;\n        if (show_if) {\n          if (if_block2) {\n            if_block2.p(ctx, dirty);\n            if (dirty & /*step*/\n            4) {\n              transition_in(if_block2, 1);\n            }\n          } else {\n            if_block2 = create_if_block$1(ctx);\n            if_block2.c();\n            transition_in(if_block2, 1);\n            if_block2.m(div, null);\n          }\n        } else if (if_block2) {\n          group_outros();\n          transition_out(if_block2, 1, 1, function () {\n            if_block2 = null;\n          });\n          check_outros();\n        }\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(if_block0);\n        transition_in(if_block1);\n        transition_in(if_block2);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(if_block0);\n        transition_out(if_block1);\n        transition_out(if_block2);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block0) if_block0.d();\n        if (if_block1) if_block1.d();\n        if (if_block2) if_block2.d();\n      }\n    };\n  }\n  function instance$2($$self, $$props, $$invalidate) {\n    var descriptionId = $$props.descriptionId,\n      labelId = $$props.labelId,\n      step = $$props.step;\n    $$self.$$set = function ($$props) {\n      if ('descriptionId' in $$props) $$invalidate(0, descriptionId = $$props.descriptionId);\n      if ('labelId' in $$props) $$invalidate(1, labelId = $$props.labelId);\n      if ('step' in $$props) $$invalidate(2, step = $$props.step);\n    };\n    return [descriptionId, labelId, step];\n  }\n  var Shepherd_content = /*#__PURE__*/function (_SvelteComponent7) {\n    _inherits(Shepherd_content, _SvelteComponent7);\n    var _super7 = _createSuper(Shepherd_content);\n    function Shepherd_content(options) {\n      var _this9;\n      _classCallCheck(this, Shepherd_content);\n      _this9 = _super7.call(this);\n      init(_assertThisInitialized(_this9), options, instance$2, create_fragment$2, safe_not_equal, {\n        descriptionId: 0,\n        labelId: 1,\n        step: 2\n      });\n      return _this9;\n    }\n    return _createClass(Shepherd_content);\n  }(SvelteComponent);\n  /* src/js/components/shepherd-element.svelte generated by Svelte v3.49.0 */\n  function create_if_block(ctx) {\n    var div;\n    return {\n      c: function c() {\n        div = element(\"div\");\n        attr(div, \"class\", \"shepherd-arrow\");\n        attr(div, \"data-popper-arrow\", \"\");\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n      }\n    };\n  }\n  function create_fragment$1(ctx) {\n    var div;\n    var t;\n    var shepherdcontent;\n    var div_aria_describedby_value;\n    var div_aria_labelledby_value;\n    var current;\n    var mounted;\n    var dispose;\n    var if_block = /*step*/\n    ctx[4].options.arrow && /*step*/\n    ctx[4].options.attachTo && /*step*/\n    ctx[4].options.attachTo.element && /*step*/\n    ctx[4].options.attachTo.on && create_if_block();\n    shepherdcontent = new Shepherd_content({\n      props: {\n        descriptionId: /*descriptionId*/\n        ctx[2],\n        labelId: /*labelId*/\n        ctx[3],\n        step: /*step*/\n        ctx[4]\n      }\n    });\n    var div_levels = [{\n      \"aria-describedby\": div_aria_describedby_value = !isUndefined( /*step*/\n      ctx[4].options.text) ? /*descriptionId*/\n      ctx[2] : null\n    }, {\n      \"aria-labelledby\": div_aria_labelledby_value = /*step*/\n      ctx[4].options.title ? /*labelId*/\n      ctx[3] : null\n    }, /*dataStepId*/\n    ctx[1], {\n      role: \"dialog\"\n    }, {\n      tabindex: \"0\"\n    }];\n    var div_data = {};\n    for (var i = 0; i < div_levels.length; i += 1) {\n      div_data = assign(div_data, div_levels[i]);\n    }\n    return {\n      c: function c() {\n        div = element(\"div\");\n        if (if_block) if_block.c();\n        t = space();\n        create_component(shepherdcontent.$$.fragment);\n        set_attributes(div, div_data);\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      m: function m(target, anchor) {\n        insert(target, div, anchor);\n        if (if_block) if_block.m(div, null);\n        append(div, t);\n        mount_component(shepherdcontent, div, null);\n        /*div_binding*/\n\n        ctx[13](div);\n        current = true;\n        if (!mounted) {\n          dispose = listen(div, \"keydown\", /*handleKeyDown*/\n          ctx[7]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref14 = _slicedToArray(_ref, 1),\n          dirty = _ref14[0];\n        if ( /*step*/\n        ctx[4].options.arrow && /*step*/\n        ctx[4].options.attachTo && /*step*/\n        ctx[4].options.attachTo.element && /*step*/\n        ctx[4].options.attachTo.on) {\n          if (if_block) ;else {\n            if_block = create_if_block();\n            if_block.c();\n            if_block.m(div, t);\n          }\n        } else if (if_block) {\n          if_block.d(1);\n          if_block = null;\n        }\n        var shepherdcontent_changes = {};\n        if (dirty & /*descriptionId*/\n        4) shepherdcontent_changes.descriptionId = /*descriptionId*/\n        ctx[2];\n        if (dirty & /*labelId*/\n        8) shepherdcontent_changes.labelId = /*labelId*/\n        ctx[3];\n        if (dirty & /*step*/\n        16) shepherdcontent_changes.step = /*step*/\n        ctx[4];\n        shepherdcontent.$set(shepherdcontent_changes);\n        set_attributes(div, div_data = get_spread_update(div_levels, [(!current || dirty & /*step, descriptionId*/\n        20 && div_aria_describedby_value !== (div_aria_describedby_value = !isUndefined( /*step*/\n        ctx[4].options.text) ? /*descriptionId*/\n        ctx[2] : null)) && {\n          \"aria-describedby\": div_aria_describedby_value\n        }, (!current || dirty & /*step, labelId*/\n        24 && div_aria_labelledby_value !== (div_aria_labelledby_value = /*step*/\n        ctx[4].options.title ? /*labelId*/\n        ctx[3] : null)) && {\n          \"aria-labelledby\": div_aria_labelledby_value\n        }, dirty & /*dataStepId*/\n        2 && /*dataStepId*/\n        ctx[1], {\n          role: \"dialog\"\n        }, {\n          tabindex: \"0\"\n        }]));\n        toggle_class(div, \"shepherd-has-cancel-icon\", /*hasCancelIcon*/\n        ctx[5]);\n        toggle_class(div, \"shepherd-has-title\", /*hasTitle*/\n        ctx[6]);\n        toggle_class(div, \"shepherd-element\", true);\n      },\n      i: function i(local) {\n        if (current) return;\n        transition_in(shepherdcontent.$$.fragment, local);\n        current = true;\n      },\n      o: function o(local) {\n        transition_out(shepherdcontent.$$.fragment, local);\n        current = false;\n      },\n      d: function d(detaching) {\n        if (detaching) detach(div);\n        if (if_block) if_block.d();\n        destroy_component(shepherdcontent);\n        /*div_binding*/\n\n        ctx[13](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  var KEY_TAB = 9;\n  var KEY_ESC = 27;\n  var LEFT_ARROW = 37;\n  var RIGHT_ARROW = 39;\n  function getClassesArray(classes) {\n    return classes.split(' ').filter(function (className) {\n      return !!className.length;\n    });\n  }\n  function instance$1($$self, $$props, $$invalidate) {\n    var classPrefix = $$props.classPrefix,\n      element = $$props.element,\n      descriptionId = $$props.descriptionId,\n      firstFocusableElement = $$props.firstFocusableElement,\n      focusableElements = $$props.focusableElements,\n      labelId = $$props.labelId,\n      lastFocusableElement = $$props.lastFocusableElement,\n      step = $$props.step,\n      dataStepId = $$props.dataStepId;\n    var hasCancelIcon, hasTitle, classes;\n    var getElement = function getElement() {\n      return element;\n    };\n    onMount(function () {\n      // Get all elements that are focusable\n      $$invalidate(1, dataStepId = _defineProperty({}, \"data-\".concat(classPrefix, \"shepherd-step-id\"), step.id));\n      $$invalidate(9, focusableElements = element.querySelectorAll('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), [tabindex=\"0\"]'));\n      $$invalidate(8, firstFocusableElement = focusableElements[0]);\n      $$invalidate(10, lastFocusableElement = focusableElements[focusableElements.length - 1]);\n    });\n    afterUpdate(function () {\n      if (classes !== step.options.classes) {\n        updateDynamicClasses();\n      }\n    });\n    function updateDynamicClasses() {\n      removeClasses(classes);\n      classes = step.options.classes;\n      addClasses(classes);\n    }\n    function removeClasses(classes) {\n      if (isString(classes)) {\n        var oldClasses = getClassesArray(classes);\n        if (oldClasses.length) {\n          var _element$classList;\n          (_element$classList = element.classList).remove.apply(_element$classList, _toConsumableArray(oldClasses));\n        }\n      }\n    }\n    function addClasses(classes) {\n      if (isString(classes)) {\n        var newClasses = getClassesArray(classes);\n        if (newClasses.length) {\n          var _element$classList2;\n          (_element$classList2 = element.classList).add.apply(_element$classList2, _toConsumableArray(newClasses));\n        }\n      }\n    }\n    /**\n    * Setup keydown events to allow closing the modal with ESC\n    *\n    * Borrowed from this great post! https://bitsofco.de/accessible-modal-dialog/\n    *\n    * @private\n    */\n\n    var handleKeyDown = function handleKeyDown(e) {\n      var _step = step,\n        tour = _step.tour;\n      switch (e.keyCode) {\n        case KEY_TAB:\n          if (focusableElements.length === 0) {\n            e.preventDefault();\n            break;\n          } // Backward tab\n\n          if (e.shiftKey) {\n            if (document.activeElement === firstFocusableElement || document.activeElement.classList.contains('shepherd-element')) {\n              e.preventDefault();\n              lastFocusableElement.focus();\n            }\n          } else {\n            if (document.activeElement === lastFocusableElement) {\n              e.preventDefault();\n              firstFocusableElement.focus();\n            }\n          }\n          break;\n        case KEY_ESC:\n          if (tour.options.exitOnEsc) {\n            step.cancel();\n          }\n          break;\n        case LEFT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.back();\n          }\n          break;\n        case RIGHT_ARROW:\n          if (tour.options.keyboardNavigation) {\n            tour.next();\n          }\n          break;\n      }\n    };\n    function div_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('classPrefix' in $$props) $$invalidate(11, classPrefix = $$props.classPrefix);\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('descriptionId' in $$props) $$invalidate(2, descriptionId = $$props.descriptionId);\n      if ('firstFocusableElement' in $$props) $$invalidate(8, firstFocusableElement = $$props.firstFocusableElement);\n      if ('focusableElements' in $$props) $$invalidate(9, focusableElements = $$props.focusableElements);\n      if ('labelId' in $$props) $$invalidate(3, labelId = $$props.labelId);\n      if ('lastFocusableElement' in $$props) $$invalidate(10, lastFocusableElement = $$props.lastFocusableElement);\n      if ('step' in $$props) $$invalidate(4, step = $$props.step);\n      if ('dataStepId' in $$props) $$invalidate(1, dataStepId = $$props.dataStepId);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*step*/\n      16) {\n        {\n          $$invalidate(5, hasCancelIcon = step.options && step.options.cancelIcon && step.options.cancelIcon.enabled);\n          $$invalidate(6, hasTitle = step.options && step.options.title);\n        }\n      }\n    };\n    return [element, dataStepId, descriptionId, labelId, step, hasCancelIcon, hasTitle, handleKeyDown, firstFocusableElement, focusableElements, lastFocusableElement, classPrefix, getElement, div_binding];\n  }\n  var Shepherd_element = /*#__PURE__*/function (_SvelteComponent8) {\n    _inherits(Shepherd_element, _SvelteComponent8);\n    var _super8 = _createSuper(Shepherd_element);\n    function Shepherd_element(options) {\n      var _this10;\n      _classCallCheck(this, Shepherd_element);\n      _this10 = _super8.call(this);\n      init(_assertThisInitialized(_this10), options, instance$1, create_fragment$1, safe_not_equal, {\n        classPrefix: 11,\n        element: 0,\n        descriptionId: 2,\n        firstFocusableElement: 8,\n        focusableElements: 9,\n        labelId: 3,\n        lastFocusableElement: 10,\n        step: 4,\n        dataStepId: 1,\n        getElement: 12\n      });\n      return _this10;\n    }\n    _createClass(Shepherd_element, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[12];\n      }\n    }]);\n    return Shepherd_element;\n  }(SvelteComponent);\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n  var smoothscroll = createCommonjsModule(function (module, exports) {\n    /* smoothscroll v0.4.4 - 2019 - Dustan Kasten, Jeremias Menichelli - MIT License */\n    (function () {\n      function polyfill() {\n        // aliases\n        var w = window;\n        var d = document; // return if scroll behavior is supported and polyfill is not forced\n\n        if ('scrollBehavior' in d.documentElement.style && w.__forceSmoothScrollPolyfill__ !== true) {\n          return;\n        } // globals\n\n        var Element = w.HTMLElement || w.Element;\n        var SCROLL_TIME = 468; // object gathering original scroll methods\n\n        var original = {\n          scroll: w.scroll || w.scrollTo,\n          scrollBy: w.scrollBy,\n          elementScroll: Element.prototype.scroll || scrollElement,\n          scrollIntoView: Element.prototype.scrollIntoView\n        }; // define timing method\n\n        var now = w.performance && w.performance.now ? w.performance.now.bind(w.performance) : Date.now;\n        /**\n         * indicates if a the current browser is made by Microsoft\n         * @method isMicrosoftBrowser\n         * @param {String} userAgent\n         * @returns {Boolean}\n         */\n\n        function isMicrosoftBrowser(userAgent) {\n          var userAgentPatterns = ['MSIE ', 'Trident/', 'Edge/'];\n          return new RegExp(userAgentPatterns.join('|')).test(userAgent);\n        }\n        /*\n         * IE has rounding bug rounding down clientHeight and clientWidth and\n         * rounding up scrollHeight and scrollWidth causing false positives\n         * on hasScrollableSpace\n         */\n\n        var ROUNDING_TOLERANCE = isMicrosoftBrowser(w.navigator.userAgent) ? 1 : 0;\n        /**\n         * changes scroll position inside an element\n         * @method scrollElement\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function scrollElement(x, y) {\n          this.scrollLeft = x;\n          this.scrollTop = y;\n        }\n        /**\n         * returns result of applying ease math function to a number\n         * @method ease\n         * @param {Number} k\n         * @returns {Number}\n         */\n\n        function ease(k) {\n          return 0.5 * (1 - Math.cos(Math.PI * k));\n        }\n        /**\n         * indicates if a smooth behavior should be applied\n         * @method shouldBailOut\n         * @param {Number|Object} firstArg\n         * @returns {Boolean}\n         */\n\n        function shouldBailOut(firstArg) {\n          if (firstArg === null || _typeof(firstArg) !== 'object' || firstArg.behavior === undefined || firstArg.behavior === 'auto' || firstArg.behavior === 'instant') {\n            // first argument is not an object/null\n            // or behavior is auto, instant or undefined\n            return true;\n          }\n          if (_typeof(firstArg) === 'object' && firstArg.behavior === 'smooth') {\n            // first argument is an object and behavior is smooth\n            return false;\n          } // throw error when behavior is not supported\n\n          throw new TypeError('behavior member of ScrollOptions ' + firstArg.behavior + ' is not a valid value for enumeration ScrollBehavior.');\n        }\n        /**\n         * indicates if an element has scrollable space in the provided axis\n         * @method hasScrollableSpace\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function hasScrollableSpace(el, axis) {\n          if (axis === 'Y') {\n            return el.clientHeight + ROUNDING_TOLERANCE < el.scrollHeight;\n          }\n          if (axis === 'X') {\n            return el.clientWidth + ROUNDING_TOLERANCE < el.scrollWidth;\n          }\n        }\n        /**\n         * indicates if an element has a scrollable overflow property in the axis\n         * @method canOverflow\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function canOverflow(el, axis) {\n          var overflowValue = w.getComputedStyle(el, null)['overflow' + axis];\n          return overflowValue === 'auto' || overflowValue === 'scroll';\n        }\n        /**\n         * indicates if an element can be scrolled in either axis\n         * @method isScrollable\n         * @param {Node} el\n         * @param {String} axis\n         * @returns {Boolean}\n         */\n\n        function isScrollable(el) {\n          var isScrollableY = hasScrollableSpace(el, 'Y') && canOverflow(el, 'Y');\n          var isScrollableX = hasScrollableSpace(el, 'X') && canOverflow(el, 'X');\n          return isScrollableY || isScrollableX;\n        }\n        /**\n         * finds scrollable parent of an element\n         * @method findScrollableParent\n         * @param {Node} el\n         * @returns {Node} el\n         */\n\n        function findScrollableParent(el) {\n          while (el !== d.body && isScrollable(el) === false) {\n            el = el.parentNode || el.host;\n          }\n          return el;\n        }\n        /**\n         * self invoked function that, given a context, steps through scrolling\n         * @method step\n         * @param {Object} context\n         * @returns {undefined}\n         */\n\n        function step(context) {\n          var time = now();\n          var value;\n          var currentX;\n          var currentY;\n          var elapsed = (time - context.startTime) / SCROLL_TIME; // avoid elapsed times higher than one\n\n          elapsed = elapsed > 1 ? 1 : elapsed; // apply easing to elapsed time\n\n          value = ease(elapsed);\n          currentX = context.startX + (context.x - context.startX) * value;\n          currentY = context.startY + (context.y - context.startY) * value;\n          context.method.call(context.scrollable, currentX, currentY); // scroll more if we have not reached our destination\n\n          if (currentX !== context.x || currentY !== context.y) {\n            w.requestAnimationFrame(step.bind(w, context));\n          }\n        }\n        /**\n         * scrolls window or element with a smooth behavior\n         * @method smoothScroll\n         * @param {Object|Node} el\n         * @param {Number} x\n         * @param {Number} y\n         * @returns {undefined}\n         */\n\n        function smoothScroll(el, x, y) {\n          var scrollable;\n          var startX;\n          var startY;\n          var method;\n          var startTime = now(); // define scroll context\n\n          if (el === d.body) {\n            scrollable = w;\n            startX = w.scrollX || w.pageXOffset;\n            startY = w.scrollY || w.pageYOffset;\n            method = original.scroll;\n          } else {\n            scrollable = el;\n            startX = el.scrollLeft;\n            startY = el.scrollTop;\n            method = scrollElement;\n          } // scroll looping over a frame\n\n          step({\n            scrollable: scrollable,\n            method: method,\n            startTime: startTime,\n            startX: startX,\n            startY: startY,\n            x: x,\n            y: y\n          });\n        } // ORIGINAL METHODS OVERRIDES\n        // w.scroll and w.scrollTo\n\n        w.scroll = w.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scroll.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : w.scrollX || w.pageXOffset,\n            // use top prop, second argument if present or fallback to scrollY\n            arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : w.scrollY || w.pageYOffset);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, arguments[0].left !== undefined ? ~~arguments[0].left : w.scrollX || w.pageXOffset, arguments[0].top !== undefined ? ~~arguments[0].top : w.scrollY || w.pageYOffset);\n        }; // w.scrollBy\n\n        w.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0])) {\n            original.scrollBy.call(w, arguments[0].left !== undefined ? arguments[0].left : _typeof(arguments[0]) !== 'object' ? arguments[0] : 0, arguments[0].top !== undefined ? arguments[0].top : arguments[1] !== undefined ? arguments[1] : 0);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(w, d.body, ~~arguments[0].left + (w.scrollX || w.pageXOffset), ~~arguments[0].top + (w.scrollY || w.pageYOffset));\n        }; // Element.prototype.scroll and Element.prototype.scrollTo\n\n        Element.prototype.scroll = Element.prototype.scrollTo = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            // if one number is passed, throw error to match Firefox implementation\n            if (typeof arguments[0] === 'number' && arguments[1] === undefined) {\n              throw new SyntaxError('Value could not be converted');\n            }\n            original.elementScroll.call(this,\n            // use left prop, first number argument or fallback to scrollLeft\n            arguments[0].left !== undefined ? ~~arguments[0].left : _typeof(arguments[0]) !== 'object' ? ~~arguments[0] : this.scrollLeft,\n            // use top prop, second argument or fallback to scrollTop\n            arguments[0].top !== undefined ? ~~arguments[0].top : arguments[1] !== undefined ? ~~arguments[1] : this.scrollTop);\n            return;\n          }\n          var left = arguments[0].left;\n          var top = arguments[0].top; // LET THE SMOOTHNESS BEGIN!\n\n          smoothScroll.call(this, this, typeof left === 'undefined' ? this.scrollLeft : ~~left, typeof top === 'undefined' ? this.scrollTop : ~~top);\n        }; // Element.prototype.scrollBy\n\n        Element.prototype.scrollBy = function () {\n          // avoid action when no arguments are passed\n          if (arguments[0] === undefined) {\n            return;\n          } // avoid smooth behavior if not required\n\n          if (shouldBailOut(arguments[0]) === true) {\n            original.elementScroll.call(this, arguments[0].left !== undefined ? ~~arguments[0].left + this.scrollLeft : ~~arguments[0] + this.scrollLeft, arguments[0].top !== undefined ? ~~arguments[0].top + this.scrollTop : ~~arguments[1] + this.scrollTop);\n            return;\n          }\n          this.scroll({\n            left: ~~arguments[0].left + this.scrollLeft,\n            top: ~~arguments[0].top + this.scrollTop,\n            behavior: arguments[0].behavior\n          });\n        }; // Element.prototype.scrollIntoView\n\n        Element.prototype.scrollIntoView = function () {\n          // avoid smooth behavior if not required\n          if (shouldBailOut(arguments[0]) === true) {\n            original.scrollIntoView.call(this, arguments[0] === undefined ? true : arguments[0]);\n            return;\n          } // LET THE SMOOTHNESS BEGIN!\n\n          var scrollableParent = findScrollableParent(this);\n          var parentRects = scrollableParent.getBoundingClientRect();\n          var clientRects = this.getBoundingClientRect();\n          if (scrollableParent !== d.body) {\n            // reveal element inside parent\n            smoothScroll.call(this, scrollableParent, scrollableParent.scrollLeft + clientRects.left - parentRects.left, scrollableParent.scrollTop + clientRects.top - parentRects.top); // reveal parent in viewport unless is fixed\n\n            if (w.getComputedStyle(scrollableParent).position !== 'fixed') {\n              w.scrollBy({\n                left: parentRects.left,\n                top: parentRects.top,\n                behavior: 'smooth'\n              });\n            }\n          } else {\n            // reveal element in viewport\n            w.scrollBy({\n              left: clientRects.left,\n              top: clientRects.top,\n              behavior: 'smooth'\n            });\n          }\n        };\n      }\n      {\n        // commonjs\n        module.exports = {\n          polyfill: polyfill\n        };\n      }\n    })();\n  });\n  smoothscroll.polyfill;\n  smoothscroll.polyfill();\n  /**\n   * A class representing steps to be added to a tour.\n   * @extends {Evented}\n   */\n  var Step = /*#__PURE__*/function (_Evented) {\n    _inherits(Step, _Evented);\n    var _super9 = _createSuper(Step);\n    /**\n     * Create a step\n     * @param {Tour} tour The tour for the step\n     * @param {object} options The options for the step\n     * @param {boolean} options.arrow Whether to display the arrow for the tooltip or not. Defaults to `true`.\n     * @param {object} options.attachTo The element the step should be attached to on the page.\n     * An object with properties `element` and `on`.\n     *\n     * ```js\n     * const step = new Step(tour, {\n     *   attachTo: { element: '.some .selector-path', on: 'left' },\n     *   ...moreOptions\n     * });\n     * ```\n     *\n     * If you don’t specify an `attachTo` the element will appear in the middle of the screen. The same will happen if your `attachTo.element` callback returns `null`, `undefined`, or a selector that does not exist in the DOM.\n     * If you omit the `on` portion of `attachTo`, the element will still be highlighted, but the tooltip will appear\n     * in the middle of the screen, without an arrow pointing to the target.\n     * If the element to highlight does not yet exist while instantiating tour steps, you may use lazy evaluation by supplying a function to `attachTo.element`. The function will be called in the `before-show` phase.\n     * @param {string|HTMLElement|function} options.attachTo.element An element selector string, DOM element, or a function (returning a selector, a DOM element, `null` or `undefined`).\n     * @param {string} options.attachTo.on The optional direction to place the Popper tooltip relative to the element.\n     *   - Possible string values: 'auto', 'auto-start', 'auto-end', 'top', 'top-start', 'top-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end', 'left', 'left-start', 'left-end'\n     * @param {Object} options.advanceOn An action on the page which should advance shepherd to the next step.\n     * It should be an object with a string `selector` and an `event` name\n     * ```js\n     * const step = new Step(tour, {\n     *   advanceOn: { selector: '.some .selector-path', event: 'click' },\n     *   ...moreOptions\n     * });\n     * ```\n     * `event` doesn’t have to be an event inside the tour, it can be any event fired on any element on the page.\n     * You can also always manually advance the Tour by calling `myTour.next()`.\n     * @param {function} options.beforeShowPromise A function that returns a promise.\n     * When the promise resolves, the rest of the `show` code for the step will execute.\n     * @param {Object[]} options.buttons An array of buttons to add to the step. These will be rendered in a\n     * footer below the main body text.\n     * @param {function} options.buttons.button.action A function executed when the button is clicked on.\n     * It is automatically bound to the `tour` the step is associated with, so things like `this.next` will\n     * work inside the action.\n     * You can use action to skip steps or navigate to specific steps, with something like:\n     * ```js\n     * action() {\n     *   return this.show('some_step_name');\n     * }\n     * ```\n     * @param {string} options.buttons.button.classes Extra classes to apply to the `<a>`\n     * @param {boolean} options.buttons.button.disabled Should the button be disabled?\n     * @param {string} options.buttons.button.label The aria-label text of the button\n     * @param {boolean} options.buttons.button.secondary If true, a shepherd-button-secondary class is applied to the button\n     * @param {string} options.buttons.button.text The HTML text of the button\n     * @param {boolean} options.canClickTarget A boolean, that when set to false, will set `pointer-events: none` on the target\n     * @param {object} options.cancelIcon Options for the cancel icon\n     * @param {boolean} options.cancelIcon.enabled Should a cancel “✕” be shown in the header of the step?\n     * @param {string} options.cancelIcon.label The label to add for `aria-label`\n     * @param {string} options.classes A string of extra classes to add to the step's content element.\n     * @param {string} options.highlightClass An extra class to apply to the `attachTo` element when it is\n     * highlighted (that is, when its step is active). You can then target that selector in your CSS.\n     * @param {string} options.id The string to use as the `id` for the step.\n     * @param {number} options.modalOverlayOpeningPadding An amount of padding to add around the modal overlay opening\n     * @param {number} options.modalOverlayOpeningRadius An amount of border radius to add around the modal overlay opening\n     * @param {object} options.popperOptions Extra options to pass to Popper\n     * @param {boolean|Object} options.scrollTo Should the element be scrolled to when this step is shown? If true, uses the default `scrollIntoView`,\n     * if an object, passes that object as the params to `scrollIntoView` i.e. `{behavior: 'smooth', block: 'center'}`\n     * @param {function} options.scrollToHandler A function that lets you override the default scrollTo behavior and\n     * define a custom action to do the scrolling, and possibly other logic.\n     * @param {function} options.showOn A function that, when it returns `true`, will show the step.\n     * If it returns false, the step will be skipped.\n     * @param {string} options.text The text in the body of the step. It can be one of three types:\n     * ```\n     * - HTML string\n     * - `HTMLElement` object\n     * - `Function` to be executed when the step is built. It must return one the two options above.\n     * ```\n     * @param {string} options.title The step's title. It becomes an `h3` at the top of the step. It can be one of two types:\n     * ```\n     * - HTML string\n     * - `Function` to be executed when the step is built. It must return HTML string.\n     * ```\n     * @param {object} options.when You can define `show`, `hide`, etc events inside `when`. For example:\n     * ```js\n     * when: {\n     *   show: function() {\n     *     window.scrollTo(0, 0);\n     *   }\n     * }\n     * ```\n     * @return {Step} The newly created Step instance\n     */\n    function Step(tour, options) {\n      var _this11;\n      _classCallCheck(this, Step);\n      if (options === void 0) {\n        options = {};\n      }\n      _this11 = _super9.call(this, tour, options);\n      _this11.tour = tour;\n      _this11.classPrefix = _this11.tour.options ? normalizePrefix(_this11.tour.options.classPrefix) : '';\n      _this11.styles = tour.styles;\n      /**\n       * Resolved attachTo options. Due to lazy evaluation, we only resolve the options during `before-show` phase.\n       * Do not use this directly, use the _getResolvedAttachToOptions method instead.\n       * @type {null|{}|{element, to}}\n       * @private\n       */\n\n      _this11._resolvedAttachTo = null;\n      autoBind(_assertThisInitialized(_this11));\n      _this11._setOptions(options);\n      return _possibleConstructorReturn(_this11, _assertThisInitialized(_this11));\n    }\n    /**\n     * Cancel the tour\n     * Triggers the `cancel` event\n     */\n    _createClass(Step, [{\n      key: \"cancel\",\n      value: function cancel() {\n        this.tour.cancel();\n        this.trigger('cancel');\n      }\n      /**\n       * Complete the tour\n       * Triggers the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this.tour.complete();\n        this.trigger('complete');\n      }\n      /**\n       * Remove the step, delete the step's element, and destroy the Popper instance for the step.\n       * Triggers `destroy` event\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.tooltip) {\n          this.tooltip.destroy();\n          this.tooltip = null;\n        }\n        if (isHTMLElement$1(this.el) && this.el.parentNode) {\n          this.el.parentNode.removeChild(this.el);\n          this.el = null;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('destroy');\n      }\n      /**\n       * Returns the tour for the step\n       * @return {Tour} The tour instance\n       */\n    }, {\n      key: \"getTour\",\n      value: function getTour() {\n        return this.tour;\n      }\n      /**\n       * Hide the step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.tour.modal.hide();\n        this.trigger('before-hide');\n        if (this.el) {\n          this.el.hidden = true;\n        }\n        this._updateStepTargetOnHide();\n        this.trigger('hide');\n      }\n      /**\n       * Resolves attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_resolveAttachToOptions\",\n      value: function _resolveAttachToOptions() {\n        this._resolvedAttachTo = parseAttachTo(this);\n        return this._resolvedAttachTo;\n      }\n      /**\n       * A selector for resolved attachTo options.\n       * @returns {{}|{element, on}}\n       * @private\n       */\n    }, {\n      key: \"_getResolvedAttachToOptions\",\n      value: function _getResolvedAttachToOptions() {\n        if (this._resolvedAttachTo === null) {\n          return this._resolveAttachToOptions();\n        }\n        return this._resolvedAttachTo;\n      }\n      /**\n       * Check if the step is open and visible\n       * @return {boolean} True if the step is open and visible\n       */\n    }, {\n      key: \"isOpen\",\n      value: function isOpen() {\n        return Boolean(this.el && !this.el.hidden);\n      }\n      /**\n       * Wraps `_show` and ensures `beforeShowPromise` resolves before calling show\n       * @return {*|Promise}\n       */\n    }, {\n      key: \"show\",\n      value: function show() {\n        var _this12 = this;\n        if (isFunction(this.options.beforeShowPromise)) {\n          var beforeShowPromise = this.options.beforeShowPromise();\n          if (!isUndefined(beforeShowPromise)) {\n            return beforeShowPromise.then(function () {\n              return _this12._show();\n            });\n          }\n        }\n        this._show();\n      }\n      /**\n       * Updates the options of the step.\n       *\n       * @param {Object} options The options for the step\n       */\n    }, {\n      key: \"updateStepOptions\",\n      value: function updateStepOptions(options) {\n        Object.assign(this.options, options);\n        if (this.shepherdElementComponent) {\n          this.shepherdElementComponent.$set({\n            step: this\n          });\n        }\n      }\n      /**\n       * Returns the element for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if it has been destroyed\n       */\n    }, {\n      key: \"getElement\",\n      value: function getElement() {\n        return this.el;\n      }\n      /**\n       * Returns the target for the step\n       * @return {HTMLElement|null|undefined} The element instance. undefined if it has never been shown, null if query string has not been found\n       */\n    }, {\n      key: \"getTarget\",\n      value: function getTarget() {\n        return this.target;\n      }\n      /**\n       * Creates Shepherd element for step based on options\n       *\n       * @return {Element} The DOM element for the step tooltip\n       * @private\n       */\n    }, {\n      key: \"_createTooltipContent\",\n      value: function _createTooltipContent() {\n        var descriptionId = \"\".concat(this.id, \"-description\");\n        var labelId = \"\".concat(this.id, \"-label\");\n        this.shepherdElementComponent = new Shepherd_element({\n          target: this.tour.options.stepsContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            descriptionId: descriptionId,\n            labelId: labelId,\n            step: this,\n            styles: this.styles\n          }\n        });\n        return this.shepherdElementComponent.getElement();\n      }\n      /**\n       * If a custom scrollToHandler is defined, call that, otherwise do the generic\n       * scrollIntoView call.\n       *\n       * @param {boolean|Object} scrollToOptions If true, uses the default `scrollIntoView`,\n       * if an object, passes that object as the params to `scrollIntoView` i.e. `{ behavior: 'smooth', block: 'center' }`\n       * @private\n       */\n    }, {\n      key: \"_scrollTo\",\n      value: function _scrollTo(scrollToOptions) {\n        var _this$_getResolvedAtt = this._getResolvedAttachToOptions(),\n          element = _this$_getResolvedAtt.element;\n        if (isFunction(this.options.scrollToHandler)) {\n          this.options.scrollToHandler(element);\n        } else if (isElement$1(element) && typeof element.scrollIntoView === 'function') {\n          element.scrollIntoView(scrollToOptions);\n        }\n      }\n      /**\n       * _getClassOptions gets all possible classes for the step\n       * @param {Object} stepOptions The step specific options\n       * @returns {String} unique string from array of classes\n       * @private\n       */\n    }, {\n      key: \"_getClassOptions\",\n      value: function _getClassOptions(stepOptions) {\n        var defaultStepOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        var stepClasses = stepOptions.classes ? stepOptions.classes : '';\n        var defaultStepOptionsClasses = defaultStepOptions && defaultStepOptions.classes ? defaultStepOptions.classes : '';\n        var allClasses = [].concat(_toConsumableArray(stepClasses.split(' ')), _toConsumableArray(defaultStepOptionsClasses.split(' ')));\n        var uniqClasses = new Set(allClasses);\n        return Array.from(uniqClasses).join(' ').trim();\n      }\n      /**\n       * Sets the options for the step, maps `when` to events, sets up buttons\n       * @param {Object} options The options for the step\n       * @private\n       */\n    }, {\n      key: \"_setOptions\",\n      value: function _setOptions(options) {\n        var _this13 = this;\n        if (options === void 0) {\n          options = {};\n        }\n        var tourOptions = this.tour && this.tour.options && this.tour.options.defaultStepOptions;\n        tourOptions = cjs({}, tourOptions || {});\n        this.options = Object.assign({\n          arrow: true\n        }, tourOptions, options);\n        var when = this.options.when;\n        this.options.classes = this._getClassOptions(options);\n        this.destroy();\n        this.id = this.options.id || \"step-\".concat(uuid());\n        if (when) {\n          Object.keys(when).forEach(function (event) {\n            _this13.on(event, when[event], _this13);\n          });\n        }\n      }\n      /**\n       * Create the element and set up the Popper instance\n       * @private\n       */\n    }, {\n      key: \"_setupElements\",\n      value: function _setupElements() {\n        if (!isUndefined(this.el)) {\n          this.destroy();\n        }\n        this.el = this._createTooltipContent();\n        if (this.options.advanceOn) {\n          bindAdvance(this);\n        }\n        setupTooltip(this);\n      }\n      /**\n       * Triggers `before-show`, generates the tooltip DOM content,\n       * sets up a Popper instance for the tooltip, then triggers `show`.\n       * @private\n       */\n    }, {\n      key: \"_show\",\n      value: function _show() {\n        var _this14 = this;\n        this.trigger('before-show'); // Force resolve to make sure the options are updated on subsequent shows.\n\n        this._resolveAttachToOptions();\n        this._setupElements();\n        if (!this.tour.modal) {\n          this.tour._setupModal();\n        }\n        this.tour.modal.setupForStep(this);\n        this._styleTargetElementForStep(this);\n        this.el.hidden = false; // start scrolling to target before showing the step\n\n        if (this.options.scrollTo) {\n          setTimeout(function () {\n            _this14._scrollTo(_this14.options.scrollTo);\n          });\n        }\n        this.el.hidden = false;\n        var content = this.shepherdElementComponent.getElement();\n        var target = this.target || document.body;\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-enabled\"));\n        target.classList.add(\"\".concat(this.classPrefix, \"shepherd-target\"));\n        content.classList.add('shepherd-enabled');\n        this.trigger('show');\n      }\n      /**\n       * Modulates the styles of the passed step's target element, based on the step's options and\n       * the tour's `modal` option, to visually emphasize the element\n       *\n       * @param step The step object that attaches to the element\n       * @private\n       */\n    }, {\n      key: \"_styleTargetElementForStep\",\n      value: function _styleTargetElementForStep(step) {\n        var targetElement = step.target;\n        if (!targetElement) {\n          return;\n        }\n        if (step.options.highlightClass) {\n          targetElement.classList.add(step.options.highlightClass);\n        }\n        targetElement.classList.remove('shepherd-target-click-disabled');\n        if (step.options.canClickTarget === false) {\n          targetElement.classList.add('shepherd-target-click-disabled');\n        }\n      }\n      /**\n       * When a step is hidden, remove the highlightClass and 'shepherd-enabled'\n       * and 'shepherd-target' classes\n       * @private\n       */\n    }, {\n      key: \"_updateStepTargetOnHide\",\n      value: function _updateStepTargetOnHide() {\n        var target = this.target || document.body;\n        if (this.options.highlightClass) {\n          target.classList.remove(this.options.highlightClass);\n        }\n        target.classList.remove('shepherd-target-click-disabled', \"\".concat(this.classPrefix, \"shepherd-enabled\"), \"\".concat(this.classPrefix, \"shepherd-target\"));\n      }\n    }]);\n    return Step;\n  }(Evented);\n  /**\n   * Cleanup the steps and set pointerEvents back to 'auto'\n   * @param tour The tour object\n   */\n  function cleanupSteps(tour) {\n    if (tour) {\n      var steps = tour.steps;\n      steps.forEach(function (step) {\n        if (step.options && step.options.canClickTarget === false && step.options.attachTo) {\n          if (step.target instanceof HTMLElement) {\n            step.target.classList.remove('shepherd-target-click-disabled');\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * Generates the svg path data for a rounded rectangle overlay\n   * @param {Object} dimension - Dimensions of rectangle.\n   * @param {number} width - Width.\n   * @param {number} height - Height.\n   * @param {number} [x=0] - Offset from top left corner in x axis. default 0.\n   * @param {number} [y=0] - Offset from top left corner in y axis. default 0.\n   * @param {number} [r=0] - Corner Radius. Keep this smaller than  half of width or height.\n   * @returns {string} - Rounded rectangle overlay path data.\n   */\n  function makeOverlayPath(_ref) {\n    var width = _ref.width,\n      height = _ref.height,\n      _ref$x = _ref.x,\n      x = _ref$x === void 0 ? 0 : _ref$x,\n      _ref$y = _ref.y,\n      y = _ref$y === void 0 ? 0 : _ref$y,\n      _ref$r = _ref.r,\n      r = _ref$r === void 0 ? 0 : _ref$r;\n    var _window = window,\n      w = _window.innerWidth,\n      h = _window.innerHeight;\n    return \"M\".concat(w, \",\").concat(h, \"H0V0H\").concat(w, \"V\").concat(h, \"ZM\").concat(x + r, \",\").concat(y, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \",\").concat(r, \"V\").concat(height + y - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \",\").concat(r, \"H\").concat(width + x - r, \"a\").concat(r, \",\").concat(r, \",0,0,0,\").concat(r, \"-\").concat(r, \"V\").concat(y + r, \"a\").concat(r, \",\").concat(r, \",0,0,0-\").concat(r, \"-\").concat(r, \"Z\");\n  }\n\n  /* src/js/components/shepherd-modal.svelte generated by Svelte v3.49.0 */\n\n  function create_fragment(ctx) {\n    var svg;\n    var path;\n    var svg_class_value;\n    var mounted;\n    var dispose;\n    return {\n      c: function c() {\n        svg = svg_element(\"svg\");\n        path = svg_element(\"path\");\n        attr(path, \"d\", /*pathDefinition*/\n        ctx[2]);\n        attr(svg, \"class\", svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"));\n      },\n      m: function m(target, anchor) {\n        insert(target, svg, anchor);\n        append(svg, path);\n        /*svg_binding*/\n\n        ctx[11](svg);\n        if (!mounted) {\n          dispose = listen(svg, \"touchmove\", /*_preventModalOverlayTouch*/\n          ctx[3]);\n          mounted = true;\n        }\n      },\n      p: function p(ctx, _ref) {\n        var _ref15 = _slicedToArray(_ref, 1),\n          dirty = _ref15[0];\n        if (dirty & /*pathDefinition*/\n        4) {\n          attr(path, \"d\", /*pathDefinition*/\n          ctx[2]);\n        }\n        if (dirty & /*modalIsVisible*/\n        2 && svg_class_value !== (svg_class_value = \"\".concat( /*modalIsVisible*/\n        ctx[1] ? 'shepherd-modal-is-visible' : '', \" shepherd-modal-overlay-container\"))) {\n          attr(svg, \"class\", svg_class_value);\n        }\n      },\n      i: noop,\n      o: noop,\n      d: function d(detaching) {\n        if (detaching) detach(svg);\n        /*svg_binding*/\n\n        ctx[11](null);\n        mounted = false;\n        dispose();\n      }\n    };\n  }\n  function _getScrollParent(element) {\n    if (!element) {\n      return null;\n    }\n    var isHtmlElement = element instanceof HTMLElement;\n    var overflowY = isHtmlElement && window.getComputedStyle(element).overflowY;\n    var isScrollable = overflowY !== 'hidden' && overflowY !== 'visible';\n    if (isScrollable && element.scrollHeight >= element.clientHeight) {\n      return element;\n    }\n    return _getScrollParent(element.parentElement);\n  }\n  /**\n   * Get the visible height of the target element relative to its scrollParent.\n   * If there is no scroll parent, the height of the element is returned.\n   *\n   * @param {HTMLElement} element The target element\n   * @param {HTMLElement} [scrollParent] The scrollable parent element\n   * @returns {{y: number, height: number}}\n   * @private\n   */\n\n  function _getVisibleHeight(element, scrollParent) {\n    var elementRect = element.getBoundingClientRect();\n    var top = elementRect.y || elementRect.top;\n    var bottom = elementRect.bottom || top + elementRect.height;\n    if (scrollParent) {\n      var scrollRect = scrollParent.getBoundingClientRect();\n      var scrollTop = scrollRect.y || scrollRect.top;\n      var scrollBottom = scrollRect.bottom || scrollTop + scrollRect.height;\n      top = Math.max(top, scrollTop);\n      bottom = Math.min(bottom, scrollBottom);\n    }\n    var height = Math.max(bottom - top, 0); // Default to 0 if height is negative\n\n    return {\n      y: top,\n      height: height\n    };\n  }\n  function instance($$self, $$props, $$invalidate) {\n    var element = $$props.element,\n      openingProperties = $$props.openingProperties;\n    uuid();\n    var modalIsVisible = false;\n    var rafId = undefined;\n    var pathDefinition;\n    closeModalOpening();\n    var getElement = function getElement() {\n      return element;\n    };\n    function closeModalOpening() {\n      $$invalidate(4, openingProperties = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0,\n        r: 0\n      });\n    }\n    function hide() {\n      $$invalidate(1, modalIsVisible = false); // Ensure we cleanup all event listeners when we hide the modal\n\n      _cleanupStepEventListeners();\n    }\n    function positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, targetElement) {\n      if (modalOverlayOpeningPadding === void 0) {\n        modalOverlayOpeningPadding = 0;\n      }\n      if (modalOverlayOpeningRadius === void 0) {\n        modalOverlayOpeningRadius = 0;\n      }\n      if (targetElement) {\n        var _getVisibleHeight2 = _getVisibleHeight(targetElement, scrollParent),\n          y = _getVisibleHeight2.y,\n          height = _getVisibleHeight2.height;\n        var _targetElement$getBou = targetElement.getBoundingClientRect(),\n          x = _targetElement$getBou.x,\n          width = _targetElement$getBou.width,\n          _left = _targetElement$getBou.left; // getBoundingClientRect is not consistent. Some browsers use x and y, while others use left and top\n\n        $$invalidate(4, openingProperties = {\n          width: width + modalOverlayOpeningPadding * 2,\n          height: height + modalOverlayOpeningPadding * 2,\n          x: (x || _left) - modalOverlayOpeningPadding,\n          y: y - modalOverlayOpeningPadding,\n          r: modalOverlayOpeningRadius\n        });\n      } else {\n        closeModalOpening();\n      }\n    }\n    function setupForStep(step) {\n      // Ensure we move listeners from the previous step, before we setup new ones\n      _cleanupStepEventListeners();\n      if (step.tour.options.useModalOverlay) {\n        _styleForStep(step);\n        show();\n      } else {\n        hide();\n      }\n    }\n    function show() {\n      $$invalidate(1, modalIsVisible = true);\n    }\n    var _preventModalBodyTouch = function _preventModalBodyTouch(e) {\n      e.preventDefault();\n    };\n    var _preventModalOverlayTouch = function _preventModalOverlayTouch(e) {\n      e.stopPropagation();\n    };\n    /**\n    * Add touchmove event listener\n    * @private\n    */\n\n    function _addStepEventListeners() {\n      // Prevents window from moving on touch.\n      window.addEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Cancel the requestAnimationFrame loop and remove touchmove event listeners\n    * @private\n    */\n\n    function _cleanupStepEventListeners() {\n      if (rafId) {\n        cancelAnimationFrame(rafId);\n        rafId = undefined;\n      }\n      window.removeEventListener('touchmove', _preventModalBodyTouch, {\n        passive: false\n      });\n    }\n    /**\n    * Style the modal for the step\n    * @param {Step} step The step to style the opening for\n    * @private\n    */\n\n    function _styleForStep(step) {\n      var _step$options = step.options,\n        modalOverlayOpeningPadding = _step$options.modalOverlayOpeningPadding,\n        modalOverlayOpeningRadius = _step$options.modalOverlayOpeningRadius;\n      var scrollParent = _getScrollParent(step.target); // Setup recursive function to call requestAnimationFrame to update the modal opening position\n\n      var rafLoop = function rafLoop() {\n        rafId = undefined;\n        positionModal(modalOverlayOpeningPadding, modalOverlayOpeningRadius, scrollParent, step.target);\n        rafId = requestAnimationFrame(rafLoop);\n      };\n      rafLoop();\n      _addStepEventListeners();\n    }\n    function svg_binding($$value) {\n      binding_callbacks[$$value ? 'unshift' : 'push'](function () {\n        element = $$value;\n        $$invalidate(0, element);\n      });\n    }\n    $$self.$$set = function ($$props) {\n      if ('element' in $$props) $$invalidate(0, element = $$props.element);\n      if ('openingProperties' in $$props) $$invalidate(4, openingProperties = $$props.openingProperties);\n    };\n    $$self.$$.update = function () {\n      if ($$self.$$.dirty & /*openingProperties*/\n      16) {\n        $$invalidate(2, pathDefinition = makeOverlayPath(openingProperties));\n      }\n    };\n    return [element, modalIsVisible, pathDefinition, _preventModalOverlayTouch, openingProperties, getElement, closeModalOpening, hide, positionModal, setupForStep, show, svg_binding];\n  }\n  var Shepherd_modal = /*#__PURE__*/function (_SvelteComponent9) {\n    _inherits(Shepherd_modal, _SvelteComponent9);\n    var _super10 = _createSuper(Shepherd_modal);\n    function Shepherd_modal(options) {\n      var _this15;\n      _classCallCheck(this, Shepherd_modal);\n      _this15 = _super10.call(this);\n      init(_assertThisInitialized(_this15), options, instance, create_fragment, safe_not_equal, {\n        element: 0,\n        openingProperties: 4,\n        getElement: 5,\n        closeModalOpening: 6,\n        hide: 7,\n        positionModal: 8,\n        setupForStep: 9,\n        show: 10\n      });\n      return _this15;\n    }\n    _createClass(Shepherd_modal, [{\n      key: \"getElement\",\n      get: function get() {\n        return this.$$.ctx[5];\n      }\n    }, {\n      key: \"closeModalOpening\",\n      get: function get() {\n        return this.$$.ctx[6];\n      }\n    }, {\n      key: \"hide\",\n      get: function get() {\n        return this.$$.ctx[7];\n      }\n    }, {\n      key: \"positionModal\",\n      get: function get() {\n        return this.$$.ctx[8];\n      }\n    }, {\n      key: \"setupForStep\",\n      get: function get() {\n        return this.$$.ctx[9];\n      }\n    }, {\n      key: \"show\",\n      get: function get() {\n        return this.$$.ctx[10];\n      }\n    }]);\n    return Shepherd_modal;\n  }(SvelteComponent);\n  var Shepherd = new Evented();\n  /**\n   * Class representing the site tour\n   * @extends {Evented}\n   */\n  var Tour = /*#__PURE__*/function (_Evented2) {\n    _inherits(Tour, _Evented2);\n    var _super11 = _createSuper(Tour);\n    /**\n     * @param {Object} options The options for the tour\n     * @param {boolean} options.confirmCancel If true, will issue a `window.confirm` before cancelling\n     * @param {string} options.confirmCancelMessage The message to display in the confirm dialog\n     * @param {string} options.classPrefix The prefix to add to the `shepherd-enabled` and `shepherd-target` class names as well as the `data-shepherd-step-id`.\n     * @param {Object} options.defaultStepOptions Default options for Steps ({@link Step#constructor}), created through `addStep`\n     * @param {boolean} options.exitOnEsc Exiting the tour with the escape key will be enabled unless this is explicitly\n     * set to false.\n     * @param {boolean} options.keyboardNavigation Navigating the tour via left and right arrow keys will be enabled\n     * unless this is explicitly set to false.\n     * @param {HTMLElement} options.stepsContainer An optional container element for the steps.\n     * If not set, the steps will be appended to `document.body`.\n     * @param {HTMLElement} options.modalContainer An optional container element for the modal.\n     * If not set, the modal will be appended to `document.body`.\n     * @param {object[] | Step[]} options.steps An array of step options objects or Step instances to initialize the tour with\n     * @param {string} options.tourName An optional \"name\" for the tour. This will be appended to the the tour's\n     * dynamically generated `id` property -- which is also set on the `body` element as the `data-shepherd-active-tour` attribute\n     * whenever the tour becomes active.\n     * @param {boolean} options.useModalOverlay Whether or not steps should be placed above a darkened\n     * modal overlay. If true, the overlay will create an opening around the target element so that it\n     * can remain interactive\n     * @returns {Tour}\n     */\n    function Tour(options) {\n      var _this16;\n      _classCallCheck(this, Tour);\n      if (options === void 0) {\n        options = {};\n      }\n      _this16 = _super11.call(this, options);\n      autoBind(_assertThisInitialized(_this16));\n      var defaultTourOptions = {\n        exitOnEsc: true,\n        keyboardNavigation: true\n      };\n      _this16.options = Object.assign({}, defaultTourOptions, options);\n      _this16.classPrefix = normalizePrefix(_this16.options.classPrefix);\n      _this16.steps = [];\n      _this16.addSteps(_this16.options.steps); // Pass these events onto the global Shepherd object\n\n      var events = ['active', 'cancel', 'complete', 'inactive', 'show', 'start'];\n      events.map(function (event) {\n        (function (e) {\n          _this16.on(e, function (opts) {\n            opts = opts || {};\n            opts.tour = _assertThisInitialized(_this16);\n            Shepherd.trigger(e, opts);\n          });\n        })(event);\n      });\n      _this16._setTourID();\n      return _possibleConstructorReturn(_this16, _assertThisInitialized(_this16));\n    }\n    /**\n     * Adds a new step to the tour\n     * @param {Object|Step} options An object containing step options or a Step instance\n     * @param {number} index The optional index to insert the step at. If undefined, the step\n     * is added to the end of the array.\n     * @return {Step} The newly added step\n     */\n    _createClass(Tour, [{\n      key: \"addStep\",\n      value: function addStep(options, index) {\n        var step = options;\n        if (!(step instanceof Step)) {\n          step = new Step(this, step);\n        } else {\n          step.tour = this;\n        }\n        if (!isUndefined(index)) {\n          this.steps.splice(index, 0, step);\n        } else {\n          this.steps.push(step);\n        }\n        return step;\n      }\n      /**\n       * Add multiple steps to the tour\n       * @param {Array<object> | Array<Step>} steps The steps to add to the tour\n       */\n    }, {\n      key: \"addSteps\",\n      value: function addSteps(steps) {\n        var _this17 = this;\n        if (Array.isArray(steps)) {\n          steps.forEach(function (step) {\n            _this17.addStep(step);\n          });\n        }\n        return this;\n      }\n      /**\n       * Go to the previous step in the tour\n       */\n    }, {\n      key: \"back\",\n      value: function back() {\n        var index = this.steps.indexOf(this.currentStep);\n        this.show(index - 1, false);\n      }\n      /**\n       * Calls _done() triggering the 'cancel' event\n       * If `confirmCancel` is true, will show a window.confirm before cancelling\n       */\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        if (this.options.confirmCancel) {\n          var cancelMessage = this.options.confirmCancelMessage || 'Are you sure you want to stop the tour?';\n          var stopTour = window.confirm(cancelMessage);\n          if (stopTour) {\n            this._done('cancel');\n          }\n        } else {\n          this._done('cancel');\n        }\n      }\n      /**\n       * Calls _done() triggering the `complete` event\n       */\n    }, {\n      key: \"complete\",\n      value: function complete() {\n        this._done('complete');\n      }\n      /**\n       * Gets the step from a given id\n       * @param {Number|String} id The id of the step to retrieve\n       * @return {Step} The step corresponding to the `id`\n       */\n    }, {\n      key: \"getById\",\n      value: function getById(id) {\n        return this.steps.find(function (step) {\n          return step.id === id;\n        });\n      }\n      /**\n       * Gets the current step\n       * @returns {Step|null}\n       */\n    }, {\n      key: \"getCurrentStep\",\n      value: function getCurrentStep() {\n        return this.currentStep;\n      }\n      /**\n       * Hide the current step\n       */\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        var currentStep = this.getCurrentStep();\n        if (currentStep) {\n          return currentStep.hide();\n        }\n      }\n      /**\n       * Check if the tour is active\n       * @return {boolean}\n       */\n    }, {\n      key: \"isActive\",\n      value: function isActive() {\n        return Shepherd.activeTour === this;\n      }\n      /**\n       * Go to the next step in the tour\n       * If we are at the end, call `complete`\n       */\n    }, {\n      key: \"next\",\n      value: function next() {\n        var index = this.steps.indexOf(this.currentStep);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          this.show(index + 1, true);\n        }\n      }\n      /**\n       * Removes the step from the tour\n       * @param {String} name The id for the step to remove\n       */\n    }, {\n      key: \"removeStep\",\n      value: function removeStep(name) {\n        var _this18 = this;\n        var current = this.getCurrentStep(); // Find the step, destroy it and remove it from this.steps\n\n        this.steps.some(function (step, i) {\n          if (step.id === name) {\n            if (step.isOpen()) {\n              step.hide();\n            }\n            step.destroy();\n            _this18.steps.splice(i, 1);\n            return true;\n          }\n        });\n        if (current && current.id === name) {\n          this.currentStep = undefined; // If we have steps left, show the first one, otherwise just cancel the tour\n\n          this.steps.length ? this.show(0) : this.cancel();\n        }\n      }\n      /**\n       * Show a specific step in the tour\n       * @param {Number|String} key The key to look up the step by\n       * @param {Boolean} forward True if we are going forward, false if backward\n       */\n    }, {\n      key: \"show\",\n      value: function show(key, forward) {\n        if (key === void 0) {\n          key = 0;\n        }\n        if (forward === void 0) {\n          forward = true;\n        }\n        var step = isString(key) ? this.getById(key) : this.steps[key];\n        if (step) {\n          this._updateStateBeforeShow();\n          var shouldSkipStep = isFunction(step.options.showOn) && !step.options.showOn(); // If `showOn` returns false, we want to skip the step, otherwise, show the step like normal\n\n          if (shouldSkipStep) {\n            this._skipStep(step, forward);\n          } else {\n            this.trigger('show', {\n              step: step,\n              previous: this.currentStep\n            });\n            this.currentStep = step;\n            step.show();\n          }\n        }\n      }\n      /**\n       * Start the tour\n       */\n    }, {\n      key: \"start\",\n      value: function start() {\n        this.trigger('start'); // Save the focused element before the tour opens\n\n        this.focusedElBeforeOpen = document.activeElement;\n        this.currentStep = null;\n        this._setupModal();\n        this._setupActiveTour();\n        this.next();\n      }\n      /**\n       * Called whenever the tour is cancelled or completed, basically anytime we exit the tour\n       * @param {String} event The event name to trigger\n       * @private\n       */\n    }, {\n      key: \"_done\",\n      value: function _done(event) {\n        var index = this.steps.indexOf(this.currentStep);\n        if (Array.isArray(this.steps)) {\n          this.steps.forEach(function (step) {\n            return step.destroy();\n          });\n        }\n        cleanupSteps(this);\n        this.trigger(event, {\n          index: index\n        });\n        Shepherd.activeTour = null;\n        this.trigger('inactive', {\n          tour: this\n        });\n        if (this.modal) {\n          this.modal.hide();\n        }\n        if (event === 'cancel' || event === 'complete') {\n          if (this.modal) {\n            var modalContainer = document.querySelector('.shepherd-modal-overlay-container');\n            if (modalContainer) {\n              modalContainer.remove();\n            }\n          }\n        } // Focus the element that was focused before the tour started\n\n        if (isHTMLElement$1(this.focusedElBeforeOpen)) {\n          this.focusedElBeforeOpen.focus();\n        }\n      }\n      /**\n       * Make this tour \"active\"\n       * @private\n       */\n    }, {\n      key: \"_setupActiveTour\",\n      value: function _setupActiveTour() {\n        this.trigger('active', {\n          tour: this\n        });\n        Shepherd.activeTour = this;\n      }\n      /**\n       * _setupModal create the modal container and instance\n       * @private\n       */\n    }, {\n      key: \"_setupModal\",\n      value: function _setupModal() {\n        this.modal = new Shepherd_modal({\n          target: this.options.modalContainer || document.body,\n          props: {\n            classPrefix: this.classPrefix,\n            styles: this.styles\n          }\n        });\n      }\n      /**\n       * Called when `showOn` evaluates to false, to skip the step or complete the tour if it's the last step\n       * @param {Step} step The step to skip\n       * @param {Boolean} forward True if we are going forward, false if backward\n       * @private\n       */\n    }, {\n      key: \"_skipStep\",\n      value: function _skipStep(step, forward) {\n        var index = this.steps.indexOf(step);\n        if (index === this.steps.length - 1) {\n          this.complete();\n        } else {\n          var nextIndex = forward ? index + 1 : index - 1;\n          this.show(nextIndex, forward);\n        }\n      }\n      /**\n       * Before showing, hide the current step and if the tour is not\n       * already active, call `this._setupActiveTour`.\n       * @private\n       */\n    }, {\n      key: \"_updateStateBeforeShow\",\n      value: function _updateStateBeforeShow() {\n        if (this.currentStep) {\n          this.currentStep.hide();\n        }\n        if (!this.isActive()) {\n          this._setupActiveTour();\n        }\n      }\n      /**\n       * Sets this.id to `${tourName}--${uuid}`\n       * @private\n       */\n    }, {\n      key: \"_setTourID\",\n      value: function _setTourID() {\n        var tourName = this.options.tourName || 'tour';\n        this.id = \"\".concat(tourName, \"--\").concat(uuid());\n      }\n    }]);\n    return Tour;\n  }(Evented);\n  Object.assign(Shepherd, {\n    Tour: Tour,\n    Step: Step\n  });\n  return Shepherd;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2hlcGhlcmQuanMvZGlzdC9qcy9zaGVwaGVyZC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQUVBLElBQUlBLGlCQUFpQixHQUFHLFNBQVNBLGlCQUFULENBQTJCQyxLQUEzQixFQUFrQztJQUN6RCxPQUFPQyxlQUFlLENBQUNELEtBQUQsQ0FBZixJQUNILENBQUNFLFNBQVMsQ0FBQ0YsS0FBRCxDQURkO0VBRUEsQ0FIRDtFQUtBLFNBQVNDLGVBQVQsQ0FBeUJELEtBQXpCLEVBQWdDO0lBQy9CLE9BQU8sQ0FBQyxDQUFDQSxLQUFGLElBQVcsUUFBT0EsS0FBUCxNQUFpQixRQUFuQztFQUNBO0VBRUQsU0FBU0UsU0FBVCxDQUFtQkYsS0FBbkIsRUFBMEI7SUFDekIsSUFBSUcsV0FBVyxHQUFHQyxNQUFNLENBQUNDLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCQyxJQUExQixDQUErQlAsS0FBL0IsQ0FBbEI7SUFFQSxPQUFPRyxXQUFXLEtBQUssaUJBQWhCLElBQ0hBLFdBQVcsS0FBSyxlQURiLElBRUhLLGNBQWMsQ0FBQ1IsS0FBRCxDQUZsQjtFQUdBOztFQUdELElBQUlTLFlBQVksR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxNQUFNLENBQUNDLEdBQTFEO0VBQ0EsSUFBSUMsa0JBQWtCLEdBQUdILFlBQVksR0FBR0MsTUFBTSxDQUFDQyxHQUFQLENBQVcsZUFBWCxDQUFILEdBQWlDLE1BQXRFO0VBRUEsU0FBU0gsY0FBVCxDQUF3QlIsS0FBeEIsRUFBK0I7SUFDOUIsT0FBT0EsS0FBSyxDQUFDYSxRQUFOLEtBQW1CRCxrQkFBMUI7RUFDQTtFQUVELFNBQVNFLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCO0lBQ3pCLE9BQU9DLEtBQUssQ0FBQ0MsT0FBTixDQUFjRixHQUFkLENBQXFCLEtBQXJCLEdBQTBCLEVBQWpDO0VBQ0E7RUFFRCxTQUFTRyw2QkFBVCxDQUF1Q2xC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Q3BCLElBQUtBLFlBQUwsQ0FBaUIzYixJQUFqQjtRQUNEO1FBRUQsSUFBSSxDQUFDLEtBQUtvYyxRQUFMLEVBQUwsRUFBc0I7VUFDcEIsS0FBS1UsZ0JBQUw7UUFDRDtNQUNGO01BRUQ7QUFDRjtBQUNBO0FBQ0E7SUFIRTtNQUFBO01BQUEsT0FJQXJCLHNCQUFhO1FBQ1gsSUFBTXlCLFFBQVEsR0FBRyxLQUFLejJCLE9BQUwsQ0FBYXkyQixRQUFiLElBQXlCLE1BQTFDO1FBRUEsS0FBS3RLLEVBQUwsYUFBYXNLLFFBQVMsZUFBSTNVLElBQUksRUFBRyxDQUFqQztNQUNEO0lBQUE7SUFBQTtFQUFBLEVBOVd1QjllLE9BQW5CO0VDaEJQL0QsTUFBTSxDQUFDdUosTUFBUCxDQUFja3NCLFFBQWQsRUFBd0I7SUFBRUMsSUFBRixFQUFFQSxJQUFGO0lBQVFuRTtFQUFSLENBQXhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL2RlZXBtZXJnZS9kaXN0L2Nqcy5qcz81YWQxIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL3NyYy9qcy91dGlscy90eXBlLWNoZWNrLmpzPzFmZDMiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL2V2ZW50ZWQuanM/OTczZCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvdXRpbHMvYXV0by1iaW5kLmpzPzdiMTYiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL3V0aWxzL2JpbmQuanM/YTUxNSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2VudW1zLmpzPzQ2OTciLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/OTA2MCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/OWE5NCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzPzdjZjgiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/MTJlYiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanM/MTU3ZCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21hdGguanM/M2I4YyIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanM/ZGQxNCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzPzc4MDMiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvY29udGFpbnMuanM/NTgxMCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wdXRlZFN0eWxlLmpzPzA5MDgiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNUYWJsZUVsZW1lbnQuanM/MzdkNCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanM/Mzg0OCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzP2UwODkiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzPzU4MmEiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanM/NWQwYiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL3dpdGhpbi5qcz9kMDkzIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzP2QwN2YiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZVBhZGRpbmdPYmplY3QuanM/ODBmNSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2V4cGFuZFRvSGFzaE1hcC5qcz81NDExIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzP2QxMzAiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanM/YzAxZiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzYzOTEiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/NzkzNSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzP2EwMDYiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz9mODFlIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcz84YTcwIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanM/NjZkMyIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRWaWV3cG9ydFJlY3QuanM/ZDdmZSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudFJlY3QuanM/MzMxZSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1Njcm9sbFBhcmVudC5qcz83ODYzIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz9hMzJhIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzPzZmNTkiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzPzljMzkiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzP2QxNmQiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcz80ZTc1Iiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanM/YjUzNCIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzJlYTEiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZmxpcC5qcz9kYjQ4Iiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanM/YWI5NyIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/YzM2OSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzPzU4MDEiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzP2Q4YzciLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2Y5OGUiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/YjdlNiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzPzY2Y2YiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kZDJhIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanM/Y2ZhYiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzP2I4MGIiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9iMDY5Iiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzP2E5MDAiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanM/NTE1ZSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvdXRpbHMvcG9wcGVyLW9wdGlvbnMuanM/YzY5YiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvdXRpbHMvZ2VuZXJhbC5qcz9iNDJkIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvaW50ZXJuYWwvaW5kZXgubWpzPzA0ZjciLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtYnV0dG9uLnN2ZWx0ZT83OGM1Iiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWZvb3Rlci5zdmVsdGU/YWY0NyIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1jYW5jZWwtaWNvbi5zdmVsdGU/NzljMSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC10aXRsZS5zdmVsdGU/Y2FjMiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1oZWFkZXIuc3ZlbHRlPzJmMjciLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtdGV4dC5zdmVsdGU/YWNlZiIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvY29tcG9uZW50cy9zaGVwaGVyZC1jb250ZW50LnN2ZWx0ZT9mMDdlIiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL3NyYy9qcy9jb21wb25lbnRzL3NoZXBoZXJkLWVsZW1lbnQuc3ZlbHRlP2I1ODYiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vbm9kZV9tb2R1bGVzL3Ntb290aHNjcm9sbC1wb2x5ZmlsbC9kaXN0L3Ntb290aHNjcm9sbC5qcz9lNmM4Iiwid2VicGFjazovL1Z1ZXh5LWFzcG5ldC1jb3JlLWFkbWluLXRlbXBsYXRlLy4uLy4uL3NyYy9qcy9zdGVwLmpzP2FkOGQiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL3V0aWxzL2NsZWFudXAuanM/NmRjYSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvdXRpbHMvb3ZlcmxheS1wYXRoLmpzP2NkNTMiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL2NvbXBvbmVudHMvc2hlcGhlcmQtbW9kYWwuc3ZlbHRlP2Y1NGIiLCJ3ZWJwYWNrOi8vVnVleHktYXNwbmV0LWNvcmUtYWRtaW4tdGVtcGxhdGUvLi4vLi4vc3JjL2pzL3RvdXIuanM/Mzk1MSIsIndlYnBhY2s6Ly9WdWV4eS1hc3BuZXQtY29yZS1hZG1pbi10ZW1wbGF0ZS8uLi8uLi9zcmMvanMvc2hlcGhlcmQuanM/NTE0NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiB0YXJnZXQucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEVsZW1lbnRgLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYW4gRWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgSFRNTEVsZW1lbnRgLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYW4gSFRNTEVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgYSBmdW5jdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3RyaW5nYCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwYXJhbSB0byBjaGVjayBpZiBpdCBpcyBhIHN0cmluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgcGFyYW0gdG8gY2hlY2sgaWYgaXQgaXMgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrJztcblxuZXhwb3J0IGNsYXNzIEV2ZW50ZWQge1xuICBvbihldmVudCwgaGFuZGxlciwgY3R4LCBvbmNlID0gZmFsc2UpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykpIHtcbiAgICAgIHRoaXMuYmluZGluZ3MgPSB7fTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmluZGluZ3NbZXZlbnRdKSkge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0gPSBbXTtcbiAgICB9XG4gICAgdGhpcy5iaW5kaW5nc1tldmVudF0ucHVzaCh7IGhhbmRsZXIsIGN0eCwgb25jZSB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgb25jZShldmVudCwgaGFuZGxlciwgY3R4KSB7XG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIGhhbmRsZXIsIGN0eCwgdHJ1ZSk7XG4gIH1cblxuICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcbiAgICBpZiAoaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykgfHwgaXNVbmRlZmluZWQodGhpcy5iaW5kaW5nc1tldmVudF0pKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmJpbmRpbmdzW2V2ZW50XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uZm9yRWFjaCgoYmluZGluZywgaW5kZXgpID0+IHtcbiAgICAgICAgaWYgKGJpbmRpbmcuaGFuZGxlciA9PT0gaGFuZGxlcikge1xuICAgICAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdHJpZ2dlcihldmVudCwgLi4uYXJncykge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5iaW5kaW5ncykgJiYgdGhpcy5iaW5kaW5nc1tldmVudF0pIHtcbiAgICAgIHRoaXMuYmluZGluZ3NbZXZlbnRdLmZvckVhY2goKGJpbmRpbmcsIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBoYW5kbGVyLCBvbmNlIH0gPSBiaW5kaW5nO1xuXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBjdHggfHwgdGhpcztcblxuICAgICAgICBoYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuXG4gICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgdGhpcy5iaW5kaW5nc1tldmVudF0uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbiIsIi8qKlxuICogQmluZHMgYWxsIHRoZSBtZXRob2RzIG9uIGEgSlMgQ2xhc3MgdG8gdGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBjbGFzcy5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL2F1dG8tYmluZFxuICogQHBhcmFtIHtvYmplY3R9IHNlbGYgVGhlIGB0aGlzYCBjb250ZXh0IG9mIHRoZSBjbGFzc1xuICogQHJldHVybiB7b2JqZWN0fSBUaGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIGNsYXNzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGF1dG9CaW5kKHNlbGYpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNlbGYuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpXTtcbiAgICBjb25zdCB2YWwgPSBzZWxmW2tleV07XG4gICAgaWYgKGtleSAhPT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzZWxmW2tleV0gPSB2YWwuYmluZChzZWxmKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cbiIsImltcG9ydCB7IGlzVW5kZWZpbmVkIH0gZnJvbSAnLi90eXBlLWNoZWNrJztcblxuLyoqXG4gKiBTZXRzIHVwIHRoZSBoYW5kbGVyIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgYWR2YW5jZSB0aGUgdG91clxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gX3NldHVwQWR2YW5jZU9uSGFuZGxlcihzZWxlY3Rvciwgc3RlcCkge1xuICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgaWYgKHN0ZXAuaXNPcGVuKCkpIHtcbiAgICAgIGNvbnN0IHRhcmdldElzRWwgPSBzdGVwLmVsICYmIGV2ZW50LmN1cnJlbnRUYXJnZXQgPT09IHN0ZXAuZWw7XG4gICAgICBjb25zdCB0YXJnZXRJc1NlbGVjdG9yID1cbiAgICAgICAgIWlzVW5kZWZpbmVkKHNlbGVjdG9yKSAmJiBldmVudC5jdXJyZW50VGFyZ2V0Lm1hdGNoZXMoc2VsZWN0b3IpO1xuXG4gICAgICBpZiAodGFyZ2V0SXNTZWxlY3RvciB8fCB0YXJnZXRJc0VsKSB7XG4gICAgICAgIHN0ZXAudG91ci5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEJpbmQgdGhlIGV2ZW50IGhhbmRsZXIgZm9yIGFkdmFuY2VPblxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5kQWR2YW5jZShzdGVwKSB7XG4gIC8vIEFuIGVtcHR5IHNlbGVjdG9yIG1hdGNoZXMgdGhlIHN0ZXAgZWxlbWVudFxuICBjb25zdCB7IGV2ZW50LCBzZWxlY3RvciB9ID0gc3RlcC5vcHRpb25zLmFkdmFuY2VPbiB8fCB7fTtcbiAgaWYgKGV2ZW50KSB7XG4gICAgY29uc3QgaGFuZGxlciA9IF9zZXR1cEFkdmFuY2VPbkhhbmRsZXIoc2VsZWN0b3IsIHN0ZXApO1xuXG4gICAgLy8gVE9ETzogdGhpcyBzaG91bGQgYWxzbyBiaW5kL3VuYmluZCBvbiBzaG93L2hpZGVcbiAgICBsZXQgZWw7XG4gICAgdHJ5IHtcbiAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICBpZiAoIWlzVW5kZWZpbmVkKHNlbGVjdG9yKSAmJiAhZWwpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKFxuICAgICAgICBgTm8gZWxlbWVudCB3YXMgZm91bmQgZm9yIHRoZSBzZWxlY3RvciBzdXBwbGllZCB0byBhZHZhbmNlT246ICR7c2VsZWN0b3J9YFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgIHN0ZXAub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIHRydWUpO1xuICAgICAgc3RlcC5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXG4gICAgICAnYWR2YW5jZU9uIHdhcyBkZWZpbmVkLCBidXQgbm8gZXZlbnQgbmFtZSB3YXMgcGFzc2VkLidcbiAgICApO1xuICB9XG59XG4iLCJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICBpZiAobm9kZS50b1N0cmluZygpICE9PSAnW29iamVjdCBXaW5kb3ddJykge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuZXhwb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImV4cG9ydCB2YXIgbWF4ID0gTWF0aC5tYXg7XG5leHBvcnQgdmFyIG1pbiA9IE1hdGgubWluO1xuZXhwb3J0IHZhciByb3VuZCA9IE1hdGgucm91bmQ7IiwiaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBzY2FsZVggPSAxO1xuICB2YXIgc2NhbGVZID0gMTtcblxuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSAmJiBpbmNsdWRlU2NhbGUpIHtcbiAgICB2YXIgb2Zmc2V0SGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIG9mZnNldFdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDsgLy8gRG8gbm90IGF0dGVtcHQgdG8gZGl2aWRlIGJ5IDAsIG90aGVyd2lzZSB3ZSBnZXQgYEluZmluaXR5YCBhcyBzY2FsZVxuICAgIC8vIEZhbGxiYWNrIHRvIDEgaW4gY2FzZSBib3RoIHZhbHVlcyBhcmUgYDBgXG5cbiAgICBpZiAob2Zmc2V0V2lkdGggPiAwKSB7XG4gICAgICBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIG9mZnNldFdpZHRoIHx8IDE7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldEhlaWdodCA+IDApIHtcbiAgICAgIHNjYWxlWSA9IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIG9mZnNldEhlaWdodCB8fCAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggLyBzY2FsZVgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodCAvIHNjYWxlWSxcbiAgICB0b3A6IHJlY3QudG9wIC8gc2NhbGVZLFxuICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC8gc2NhbGVYLFxuICAgIGJvdHRvbTogcmVjdC5ib3R0b20gLyBzY2FsZVksXG4gICAgbGVmdDogcmVjdC5sZWZ0IC8gc2NhbGVYLFxuICAgIHg6IHJlY3QubGVmdCAvIHNjYWxlWCxcbiAgICB5OiByZWN0LnRvcCAvIHNjYWxlWVxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgeyBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIHZhciByb290Tm9kZSA9IGNoaWxkLmdldFJvb3ROb2RlICYmIGNoaWxkLmdldFJvb3ROb2RlKCk7IC8vIEZpcnN0LCBhdHRlbXB0IHdpdGggZmFzdGVyIG5hdGl2ZSBtZXRob2RcblxuICBpZiAocGFyZW50LmNvbnRhaW5zKGNoaWxkKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIHRoZW4gZmFsbGJhY2sgdG8gY3VzdG9tIGltcGxlbWVudGF0aW9uIHdpdGggU2hhZG93IERPTSBzdXBwb3J0XG4gIGVsc2UgaWYgKHJvb3ROb2RlICYmIGlzU2hhZG93Um9vdChyb290Tm9kZSkpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG5cblxuICAgICAgICBuZXh0ID0gbmV4dC5wYXJlbnROb2RlIHx8IG5leHQuaG9zdDtcbiAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgIH0gLy8gR2l2ZSB1cCwgdGhlIHJlc3VsdCBpcyBmYWxzZVxuXG5cbiAgcmV0dXJuIGZhbHNlO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgZWxlbWVudC5kb2N1bWVudCkgfHwgd2luZG93LmRvY3VtZW50KS5kb2N1bWVudEVsZW1lbnQ7XG59IiwiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCwgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGlzVGFibGVFbGVtZW50IGZyb20gXCIuL2lzVGFibGVFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0UGFyZW50Tm9kZSBmcm9tIFwiLi9nZXRQYXJlbnROb2RlLmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdmaXJlZm94JykgIT09IC0xO1xuICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignVHJpZGVudCcpICE9PSAtMTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iLCJpbXBvcnQgeyBtYXggYXMgbWF0aE1heCwgbWluIGFzIG1hdGhNaW4gfSBmcm9tIFwiLi9tYXRoLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gd2l0aGluKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gbWF0aE1heChtaW4sIG1hdGhNaW4odmFsdWUsIG1heCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSIsImltcG9ydCBnZXRGcmVzaFNpZGVPYmplY3QgZnJvbSBcIi4vZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4cGFuZFRvSGFzaE1hcCh2YWx1ZSwga2V5cykge1xuICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgIGhhc2hNYXBba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBoYXNoTWFwO1xuICB9LCB7fSk7XG59IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnYXJyb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogYXJyb3csXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J11cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG59IiwiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBlbmQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1bnNldFNpZGVzID0ge1xuICB0b3A6ICdhdXRvJyxcbiAgcmlnaHQ6ICdhdXRvJyxcbiAgYm90dG9tOiAnYXV0bycsXG4gIGxlZnQ6ICdhdXRvJ1xufTsgLy8gUm91bmQgdGhlIG9mZnNldHMgdG8gdGhlIG5lYXJlc3Qgc3VpdGFibGUgc3VicGl4ZWwgYmFzZWQgb24gdGhlIERQUi5cbi8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4vLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cblxuZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9KSA6IHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfTtcblxuICB4ID0gX3JlZjQueDtcbiAgeSA9IF9yZWY0Lnk7XG5cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjtcblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjUpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjUuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlLFxuICAgICAgX29wdGlvbnMkcm91bmRPZmZzZXRzID0gb3B0aW9ucy5yb3VuZE9mZnNldHMsXG4gICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciB0cmFuc2l0aW9uUHJvcGVydHkgPSBnZXRDb21wdXRlZFN0eWxlKHN0YXRlLmVsZW1lbnRzLnBvcHBlcikudHJhbnNpdGlvblByb3BlcnR5IHx8ICcnO1xuXG4gICAgaWYgKGFkYXB0aXZlICYmIFsndHJhbnNmb3JtJywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLnNvbWUoZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdHJhbnNpdGlvblByb3BlcnR5LmluZGV4T2YocHJvcGVydHkpID49IDA7XG4gICAgfSkpIHtcbiAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogRGV0ZWN0ZWQgQ1NTIHRyYW5zaXRpb25zIG9uIGF0IGxlYXN0IG9uZSBvZiB0aGUgZm9sbG93aW5nJywgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsICdcXG5cXG4nLCAnRGlzYWJsZSB0aGUgXCJjb21wdXRlU3R5bGVzXCIgbW9kaWZpZXJcXCdzIGBhZGFwdGl2ZWAgb3B0aW9uIHRvIGFsbG93JywgJ2ZvciBzbW9vdGggdHJhbnNpdGlvbnMsIG9yIHJlbW92ZSB0aGVzZSBwcm9wZXJ0aWVzIGZyb20gdGhlIENTUycsICd0cmFuc2l0aW9uIGRlY2xhcmF0aW9uIG9uIHRoZSBwb3BwZXIgZWxlbWVudCBpZiBvbmx5IHRyYW5zaXRpb25pbmcnLCAnb3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLicsICdcXG5cXG4nLCAnV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyJywgJ2VsZW1lbnQgdGhhdCBjYW4gaGF2ZSBhbnkgQ1NTIHByb3BlcnR5IHRyYW5zaXRpb25lZCBmb3IgYW5pbWF0aW9ucy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSB7XG4gICAgcGxhY2VtZW50OiBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICBwb3BwZXI6IHN0YXRlLmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgaXNGaXhlZDogc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJ1xuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcbiAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICByb3VuZE9mZnNldHM6IHJvdW5kT2Zmc2V0c1xuICAgIH0pKSk7XG4gIH1cblxuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCc6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcbiAgZm46IGNvbXB1dGVTdHlsZXMsXG4gIGRhdGE6IHt9XG59OyIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgcGFzc2l2ZSA9IHtcbiAgcGFzc2l2ZTogdHJ1ZVxufTtcblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIGluc3RhbmNlID0gX3JlZi5pbnN0YW5jZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcbiAgICAgIHNjcm9sbCA9IF9vcHRpb25zJHNjcm9sbCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHNjcm9sbCxcbiAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xuICB2YXIgd2luZG93ID0gZ2V0V2luZG93KHN0YXRlLmVsZW1lbnRzLnBvcHBlcik7XG4gIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgaWYgKHNjcm9sbCkge1xuICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNpemUpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICB9XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdldmVudExpc3RlbmVycycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogZnVuY3Rpb24gZm4oKSB7fSxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIGRhdGE6IHt9XG59OyIsInZhciBoYXNoID0ge1xuICBsZWZ0OiAncmlnaHQnLFxuICByaWdodDogJ2xlZnQnLFxuICBib3R0b206ICd0b3AnLFxuICB0b3A6ICdib3R0b20nXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsInZhciBoYXNoID0ge1xuICBzdGFydDogJ2VuZCcsXG4gIGVuZDogJ3N0YXJ0J1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7IC8vIE5COiBUaGlzIGlzbid0IHN1cHBvcnRlZCBvbiBpT1MgPD0gMTIuIElmIHRoZSBrZXlib2FyZCBpcyBvcGVuLCB0aGUgcG9wcGVyXG4gIC8vIGNhbiBiZSBvYnNjdXJlZCB1bmRlcm5lYXRoIGl0LlxuICAvLyBBbHNvLCBgaHRtbC5jbGllbnRIZWlnaHRgIGFkZHMgdGhlIGJvdHRvbSBiYXIgaGVpZ2h0IGluIFNhZmFyaSBpT1MsIGV2ZW5cbiAgLy8gaWYgaXQgaXNuJ3Qgb3Blbiwgc28gaWYgdGhpcyBpc24ndCBhdmFpbGFibGUsIHRoZSBwb3BwZXIgd2lsbCBiZSBkZXRlY3RlZFxuICAvLyB0byBvdmVyZmxvdyB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gdG9vIGVhcmx5LlxuXG4gIGlmICh2aXN1YWxWaWV3cG9ydCkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0OyAvLyBVc2VzIExheW91dCBWaWV3cG9ydCAobGlrZSBDaHJvbWU7IFNhZmFyaSBkb2VzIG5vdCBjdXJyZW50bHkpXG4gICAgLy8gSW4gQ2hyb21lLCBpdCByZXR1cm5zIGEgdmFsdWUgdmVyeSBjbG9zZSB0byAwICgrLy0pIGJ1dCBjb250YWlucyByb3VuZGluZ1xuICAgIC8vIGVycm9ycyBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgbnVtYmVycywgc28gd2UgbmVlZCB0byBjaGVjayBwcmVjaXNpb24uXG4gICAgLy8gU2FmYXJpIHJldHVybnMgYSBudW1iZXIgPD0gMCwgdXN1YWxseSA8IC0xIHdoZW4gcGluY2gtem9vbWVkXG4gICAgLy8gRmVhdHVyZSBkZXRlY3Rpb24gZmFpbHMgaW4gbW9iaWxlIGVtdWxhdGlvbiBtb2RlIGluIENocm9tZS5cbiAgICAvLyBNYXRoLmFicyh3aW4uaW5uZXJXaWR0aCAvIHZpc3VhbFZpZXdwb3J0LnNjYWxlIC0gdmlzdWFsVmlld3BvcnQud2lkdGgpIDxcbiAgICAvLyAwLjAwMVxuICAgIC8vIEZhbGxiYWNrIGhlcmU6IFwiTm90IFNhZmFyaVwiIHVzZXJBZ2VudFxuXG4gICAgaWYgKCEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSIsImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgIGxlZnQ6IHJlY3QueCxcbiAgICB0b3A6IHJlY3QueSxcbiAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICBib3R0b206IHJlY3QueSArIHJlY3QuaGVpZ2h0XG4gIH0pO1xufSIsImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50KSkgOiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpID8gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xuICAgIGFjY1JlY3QucmlnaHQgPSBtaW4ocmVjdC5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xuICAgIHJldHVybiBhY2NSZWN0O1xuICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCwgc3RhcnQsIGVuZCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICB2YXIgcmVmZXJlbmNlID0gX3JlZi5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50ID0gX3JlZi5lbGVtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50ID8gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudCA/IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIDogbnVsbDtcbiAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgdmFyIGNvbW1vblkgPSByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHQgLyAyIC0gZWxlbWVudC5oZWlnaHQgLyAyO1xuICB2YXIgb2Zmc2V0cztcblxuICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICBjYXNlIHRvcDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgYm90dG9tOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHJpZ2h0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgbGVmdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICB5OiByZWZlcmVuY2UueVxuICAgICAgfTtcbiAgfVxuXG4gIHZhciBtYWluQXhpcyA9IGJhc2VQbGFjZW1lbnQgPyBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCkgOiBudWxsO1xuXG4gIGlmIChtYWluQXhpcyAhPSBudWxsKSB7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICBzd2l0Y2ggKHZhcmlhdGlvbikge1xuICAgICAgY2FzZSBzdGFydDpcbiAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCJpbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSk7XG4gIHZhciByZWZlcmVuY2VDbGllbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICBlbGVtZW50OiBwb3BwZXJSZWN0LFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pO1xuICB2YXIgcG9wcGVyQ2xpZW50UmVjdCA9IHJlY3RUb0NsaWVudFJlY3QoT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyUmVjdCwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnknLCAncGxhY2VtZW50cy4gRW5zdXJlIHRoZSBgcGxhY2VtZW50YCBvcHRpb24gbWF0Y2hlcyB0aGUgdmFyaWF0aW9uJywgJ29mIHRoZSBhbGxvd2VkIHBsYWNlbWVudHMuJywgJ0ZvciBleGFtcGxlLCBcImF1dG9cIiBjYW5ub3QgYmUgdXNlZCB0byBhbGxvdyBcImJvdHRvbS1zdGFydFwiLicsICdVc2UgXCJhdXRvLXN0YXJ0XCIgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImltcG9ydCB7IHRvcCwgYm90dG9tLCBsZWZ0LCByaWdodCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdoaWRlJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXSxcbiAgZm46IGhpZGVcbn07IiwiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIHBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgaW52ZXJ0RGlzdGFuY2UgPSBbbGVmdCwgdG9wXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyAtMSA6IDE7XG5cbiAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSkpIDogb2Zmc2V0LFxuICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgZGlzdGFuY2UgPSBfcmVmWzFdO1xuXG4gIHNraWRkaW5nID0gc2tpZGRpbmcgfHwgMDtcbiAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgcmV0dXJuIFtsZWZ0LCByaWdodF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8ge1xuICAgIHg6IGRpc3RhbmNlLFxuICAgIHk6IHNraWRkaW5nXG4gIH0gOiB7XG4gICAgeDogc2tpZGRpbmcsXG4gICAgeTogZGlzdGFuY2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxuICAgICAgb2Zmc2V0ID0gX29wdGlvbnMkb2Zmc2V0ID09PSB2b2lkIDAgPyBbMCwgMF0gOiBfb3B0aW9ucyRvZmZzZXQ7XG4gIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcbiAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcbiAgICAgIHggPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueCxcbiAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ29mZnNldCcsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgZm46IG9mZnNldFxufTsiLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn0iLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHN0YXJ0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0QWx0QXhpcyBmcm9tIFwiLi4vdXRpbHMvZ2V0QWx0QXhpcy5qc1wiO1xuaW1wb3J0IHsgd2l0aGluLCB3aXRoaW5NYXhDbGFtcCB9IGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmltcG9ydCB7IG1pbiBhcyBtYXRoTWluLCBtYXggYXMgbWF0aE1heCB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIF9vcHRpb25zJHRldGhlciA9IG9wdGlvbnMudGV0aGVyLFxuICAgICAgdGV0aGVyID0gX29wdGlvbnMkdGV0aGVyID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkdGV0aGVyLFxuICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICB0ZXRoZXJPZmZzZXQgPSBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQ7XG4gIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gIH0pO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gIXZhcmlhdGlvbjtcbiAgdmFyIG1haW5BeGlzID0gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpO1xuICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cztcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgdGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gdGV0aGVyT2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICB2YXIgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldFZhbHVlID09PSAnbnVtYmVyJyA/IHtcbiAgICBtYWluQXhpczogdGV0aGVyT2Zmc2V0VmFsdWUsXG4gICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgdGV0aGVyT2Zmc2V0VmFsdWUpO1xuICB2YXIgb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XSA6IG51bGw7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcblxuICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgIHZhciBhbHRTaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICAgIHZhciBsZW4gPSBtYWluQXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICB2YXIgbWluID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xuICAgIHZhciBtYXggPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWF0aE1pbihtaW4sIHRldGhlck1pbikgOiBtaW4sIG9mZnNldCwgdGV0aGVyID8gbWF0aE1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0SFRNTEVsZW1lbnRTY3JvbGwoZWxlbWVudCkge1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IGVsZW1lbnQuc2Nyb2xsVG9wXG4gIH07XG59IiwiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59IiwiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59IiwiaW1wb3J0IHsgbW9kaWZpZXJQaGFzZXMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gc291cmNlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80OTg3NTI1NVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlYm91bmNlKGZuKSB7XG4gIHZhciBwZW5kaW5nO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHBlbmRpbmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZShmbigpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGVuZGluZztcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn0iLCJpbXBvcnQgZ2V0Q29tcG9zaXRlUmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgdmFsaWRhdGVNb2RpZmllcnMgZnJvbSBcIi4vdXRpbHMvdmFsaWRhdGVNb2RpZmllcnMuanNcIjtcbmltcG9ydCB1bmlxdWVCeSBmcm9tIFwiLi91dGlscy91bmlxdWVCeS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IG1lcmdlQnlOYW1lIGZyb20gXCIuL3V0aWxzL21lcmdlQnlOYW1lLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbnZhciBJTlZBTElEX0VMRU1FTlRfRVJST1IgPSAnUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuJztcbnZhciBJTkZJTklURV9MT09QX0VSUk9SID0gJ1BvcHBlcjogQW4gaW5maW5pdGUgbG9vcCBpbiB0aGUgbW9kaWZpZXJzIGN5Y2xlIGhhcyBiZWVuIGRldGVjdGVkISBUaGUgY3ljbGUgaGFzIGJlZW4gaW50ZXJydXB0ZWQgdG8gcHJldmVudCBhIGJyb3dzZXIgY3Jhc2guJztcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTsgLy8gVmFsaWRhdGUgdGhlIHByb3ZpZGVkIG1vZGlmaWVycyBzbyB0aGF0IHRoZSBjb25zdW1lciB3aWxsIGdldCB3YXJuZWRcbiAgICAgICAgLy8gaWYgb25lIG9mIHRoZSBtb2RpZmllcnMgaXMgaW52YWxpZCBmb3IgYW55IHJlYXNvblxuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgbW9kaWZpZXJzID0gdW5pcXVlQnkoW10uY29uY2F0KG9yZGVyZWRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKTtcblxuICAgICAgICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHN0YXRlLm9wdGlvbnMucGxhY2VtZW50KSA9PT0gYXV0bykge1xuICAgICAgICAgICAgdmFyIGZsaXBNb2RpZmllciA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmMi5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gbmFtZSA9PT0gJ2ZsaXAnO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghZmxpcE1vZGlmaWVyKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXV0b1wiIHBsYWNlbWVudHMgcmVxdWlyZSB0aGUgXCJmbGlwXCIgbW9kaWZpZXIgYmUnLCAncHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShwb3BwZXIpLFxuICAgICAgICAgICAgICBtYXJnaW5Ub3AgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Ub3AsXG4gICAgICAgICAgICAgIG1hcmdpblJpZ2h0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luUmlnaHQsXG4gICAgICAgICAgICAgIG1hcmdpbkJvdHRvbSA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkJvdHRvbSxcbiAgICAgICAgICAgICAgbWFyZ2luTGVmdCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpbkxlZnQ7IC8vIFdlIG5vIGxvbmdlciB0YWtlIGludG8gYWNjb3VudCBgbWFyZ2luc2Agb24gdGhlIHBvcHBlciwgYW5kIGl0IGNhblxuICAgICAgICAgIC8vIGNhdXNlIGJ1Z3Mgd2l0aCBwb3NpdGlvbmluZywgc28gd2UnbGwgd2FybiB0aGUgY29uc3VtZXJcblxuXG4gICAgICAgICAgaWYgKFttYXJnaW5Ub3AsIG1hcmdpblJpZ2h0LCBtYXJnaW5Cb3R0b20sIG1hcmdpbkxlZnRdLnNvbWUoZnVuY3Rpb24gKG1hcmdpbikge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobWFyZ2luKTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFsnUG9wcGVyOiBDU1MgXCJtYXJnaW5cIiBzdHlsZXMgY2Fubm90IGJlIHVzZWQgdG8gYXBwbHkgcGFkZGluZycsICdiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS4nLCAnVG8gcmVwbGljYXRlIG1hcmdpbiwgdXNlIHRoZSBgb2Zmc2V0YCBtb2RpZmllciwgYXMgd2VsbCBhcycsICd0aGUgYHBhZGRpbmdgIG9wdGlvbiBpbiB0aGUgYHByZXZlbnRPdmVyZmxvd2AgYW5kIGBmbGlwYCcsICdtb2RpZmllcnMuJ10uam9pbignICcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBydW5Nb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKGlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxuICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgIHBvcHBlciA9IF9zdGF0ZSRlbGVtZW50cy5wb3BwZXI7IC8vIERvbid0IHByb2NlZWQgaWYgYHJlZmVyZW5jZWAgb3IgYHBvcHBlcmAgYXJlIG5vdCB2YWxpZCBlbGVtZW50c1xuICAgICAgICAvLyBhbnltb3JlXG5cbiAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBfX2RlYnVnX2xvb3BzX18gPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIF9fZGVidWdfbG9vcHNfXyArPSAxO1xuXG4gICAgICAgICAgICBpZiAoX19kZWJ1Z19sb29wc19fID4gMTAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoSU5GSU5JVEVfTE9PUF9FUlJPUik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxuICAgICAgICAgICAgICBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm9wdGlvbnMsXG4gICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlXG4gICAgICAgICAgICB9KSB8fCBzdGF0ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgIC8vIG5vdCBuZWNlc3NhcnkgKGRlYm91bmNlZCB0byBydW4gYXQgbW9zdCBvbmNlLXBlci10aWNrKVxuICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSksXG4gICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIGlzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zZXRPcHRpb25zKG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICBvcHRpb25zLm9uRmlyc3RVcGRhdGUoc3RhdGUpO1xuICAgICAgfVxuICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAvLyB1cGRhdGUgY3ljbGUgcnVucy4gVGhleSB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZSB1cGRhdGVcbiAgICAvLyBjeWNsZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG1vZGlmaWVyIGFkZHMgc29tZSBwZXJzaXN0ZW50IGRhdGEgdGhhdFxuICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgIC8vIG9uZS5cblxuICAgIGZ1bmN0aW9uIHJ1bk1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmMy5uYW1lLFxuICAgICAgICAgICAgX3JlZjMkb3B0aW9ucyA9IF9yZWYzLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZjMkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmMyRvcHRpb25zLFxuICAgICAgICAgICAgZWZmZWN0ID0gX3JlZjMuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07IiwiaW1wb3J0IHsgcG9wcGVyR2VuZXJhdG9yLCBkZXRlY3RPdmVyZmxvdyB9IGZyb20gXCIuL2NyZWF0ZVBvcHBlci5qc1wiO1xuaW1wb3J0IGV2ZW50TGlzdGVuZXJzIGZyb20gXCIuL21vZGlmaWVycy9ldmVudExpc3RlbmVycy5qc1wiO1xuaW1wb3J0IHBvcHBlck9mZnNldHMgZnJvbSBcIi4vbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanNcIjtcbmltcG9ydCBjb21wdXRlU3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzXCI7XG5pbXBvcnQgYXBwbHlTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzXCI7XG5pbXBvcnQgb2Zmc2V0IGZyb20gXCIuL21vZGlmaWVycy9vZmZzZXQuanNcIjtcbmltcG9ydCBmbGlwIGZyb20gXCIuL21vZGlmaWVycy9mbGlwLmpzXCI7XG5pbXBvcnQgcHJldmVudE92ZXJmbG93IGZyb20gXCIuL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBhcnJvdyBmcm9tIFwiLi9tb2RpZmllcnMvYXJyb3cuanNcIjtcbmltcG9ydCBoaWRlIGZyb20gXCIuL21vZGlmaWVycy9oaWRlLmpzXCI7XG52YXIgZGVmYXVsdE1vZGlmaWVycyA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cywgY29tcHV0ZVN0eWxlcywgYXBwbHlTdHlsZXMsIG9mZnNldCwgZmxpcCwgcHJldmVudE92ZXJmbG93LCBhcnJvdywgaGlkZV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciwgcG9wcGVyR2VuZXJhdG9yLCBkZWZhdWx0TW9kaWZpZXJzLCBkZXRlY3RPdmVyZmxvdyB9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGNyZWF0ZVBvcHBlciBhcyBjcmVhdGVQb3BwZXJMaXRlIH0gZnJvbSBcIi4vcG9wcGVyLWxpdGUuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgKiBmcm9tIFwiLi9tb2RpZmllcnMvaW5kZXguanNcIjsiLCJmdW5jdGlvbiBfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyKCkge1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gICAgICBmbih7IHN0YXRlIH0pIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICBpZiAobmFtZSAhPT0gJ3BvcHBlcicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc3R5bGUgPSB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgICAgICAgICAgIGxlZnQ6ICc1MCUnLFxuICAgICAgICAgICAgdG9wOiAnNTAlJyxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSdcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XG4gICAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBhZGFwdGl2ZTogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIF07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbW9kaWZpZXIgZm9yIHBvcHBlciB0aGF0IHdpbGwgaGVscCBmb2N1cyB0aGUgZWxlbWVudCBhZnRlciBpdCBoYXNcbiAqIGJlZW4gcmVuZGVyZWRcbiAqXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIGZvY3VzIGFmdGVyIHJlbmRlciBtb2RpZmllciBjb25maWd1cmF0aW9uIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIoc3RlcCkge1xuICByZXR1cm4ge1xuICAgIG5hbWU6ICdmb2N1c0FmdGVyUmVuZGVyJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnYWZ0ZXJXcml0ZScsXG4gICAgZm4oKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHN0ZXAuZWwpIHtcbiAgICAgICAgICBjb25zdCBmb2N1c09wdGlvbnMgPSB7XG4gICAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHN0ZXAuZWwuZm9jdXMoZm9jdXNPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIHRoZSBhcnJheSBvZiBvcHRpb25zIGZvciBhIHRvb2x0aXAgdGhhdCBkb2Vzbid0IGhhdmUgYVxuICogdGFyZ2V0IGVsZW1lbnQgaW4gdGhlIERPTSAtLSBhbmQgdGh1cyBpcyBwb3NpdGlvbmVkIGluIHRoZSBjZW50ZXJcbiAqIG9mIHRoZSB2aWV3XG4gKlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmaW5hbCBQb3BwZXIgb3B0aW9ucyBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VDZW50ZXJlZFBvcHBlcihzdGVwKSB7XG4gIGNvbnN0IGNlbnRlcmVkU3R5bGVQb3BwZXJNb2RpZmllciA9IF9nZXRDZW50ZXJlZFN0eWxlUG9wcGVyTW9kaWZpZXIoKTtcblxuICBsZXQgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHN0cmF0ZWd5OiAnZml4ZWQnLFxuICAgIG1vZGlmaWVyczogW2dlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyKHN0ZXApXVxuICB9O1xuXG4gIHBvcHBlck9wdGlvbnMgPSB7XG4gICAgLi4ucG9wcGVyT3B0aW9ucyxcbiAgICBtb2RpZmllcnM6IEFycmF5LmZyb20oXG4gICAgICBuZXcgU2V0KFsuLi5wb3BwZXJPcHRpb25zLm1vZGlmaWVycywgLi4uY2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyXSlcbiAgICApXG4gIH07XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVQb3BwZXIgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc1N0cmluZyB9IGZyb20gJy4vdHlwZS1jaGVjayc7XG5pbXBvcnQgeyBtYWtlQ2VudGVyZWRQb3BwZXIsIGdlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyIH0gZnJvbSAnLi9wb3BwZXItb3B0aW9ucyc7XG5cbi8qKlxuICogRW5zdXJlIGNsYXNzIHByZWZpeCBlbmRzIGluIGAtYFxuICogQHBhcmFtIHtzdHJpbmd9IHByZWZpeCBUaGUgcHJlZml4IHRvIHByZXBlbmQgdG8gdGhlIGNsYXNzIG5hbWVzIGdlbmVyYXRlZCBieSBuYW5vLWNzc1xuICogQHJldHVybiB7c3RyaW5nfSBUaGUgcHJlZml4IGVuZGluZyBpbiBgLWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVByZWZpeChwcmVmaXgpIHtcbiAgaWYgKCFpc1N0cmluZyhwcmVmaXgpIHx8IHByZWZpeCA9PT0gJycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gcHJlZml4LmNoYXJBdChwcmVmaXgubGVuZ3RoIC0gMSkgIT09ICctJyA/IGAke3ByZWZpeH0tYCA6IHByZWZpeDtcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhdHRhY2hUbyBvcHRpb25zLCBjb252ZXJ0aW5nIGVsZW1lbnQgb3B0aW9uIHZhbHVlIHRvIGEgcXVhbGlmaWVkIEhUTUxFbGVtZW50LlxuICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gKiBAcmV0dXJucyB7e318e2VsZW1lbnQsIG9ufX1cbiAqIGBlbGVtZW50YCBpcyBhIHF1YWxpZmllZCBIVE1MIEVsZW1lbnRcbiAqIGBvbmAgaXMgYSBzdHJpbmcgcG9zaXRpb24gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXR0YWNoVG8oc3RlcCkge1xuICBjb25zdCBvcHRpb25zID0gc3RlcC5vcHRpb25zLmF0dGFjaFRvIHx8IHt9O1xuICBjb25zdCByZXR1cm5PcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG5cbiAgaWYgKGlzRnVuY3Rpb24ocmV0dXJuT3B0cy5lbGVtZW50KSkge1xuICAgIC8vIEJpbmQgdGhlIGNhbGxiYWNrIHRvIHN0ZXAgc28gdGhhdCBpdCBoYXMgYWNjZXNzIHRvIHRoZSBvYmplY3QsIHRvIGVuYWJsZSBydW5uaW5nIGFkZGl0aW9uYWwgbG9naWNcbiAgICByZXR1cm5PcHRzLmVsZW1lbnQgPSByZXR1cm5PcHRzLmVsZW1lbnQuY2FsbChzdGVwKTtcbiAgfVxuXG4gIGlmIChpc1N0cmluZyhyZXR1cm5PcHRzLmVsZW1lbnQpKSB7XG4gICAgLy8gQ2FuJ3Qgb3ZlcnJpZGUgdGhlIGVsZW1lbnQgaW4gdXNlciBvcHRzIHJlZmVyZW5jZSBiZWNhdXNlIHdlIGNhbid0XG4gICAgLy8gZ3VhcmFudGVlIHRoYXQgdGhlIGVsZW1lbnQgd2lsbCBleGlzdCBpbiB0aGUgZnV0dXJlLlxuICAgIHRyeSB7XG4gICAgICByZXR1cm5PcHRzLmVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJldHVybk9wdHMuZWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gVE9ET1xuICAgIH1cbiAgICBpZiAoIXJldHVybk9wdHMuZWxlbWVudCkge1xuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFRoZSBlbGVtZW50IGZvciB0aGlzIFNoZXBoZXJkIHN0ZXAgd2FzIG5vdCBmb3VuZCAke29wdGlvbnMuZWxlbWVudH1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXR1cm5PcHRzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgc3RlcCBzaG91bGQgYmUgY2VudGVyZWQgb3Igbm90LiBEb2VzIG5vdCB0cmlnZ2VyIGF0dGFjaFRvLmVsZW1lbnQgZXZhbHVhdGlvbiwgbWFraW5nIGl0IGEgcHVyZVxuICogYWx0ZXJuYXRpdmUgZm9yIHRoZSBkZXByZWNhdGVkIHN0ZXAuaXNDZW50ZXJlZCgpIG1ldGhvZC5cbiAqIEBwYXJhbSByZXNvbHZlZEF0dGFjaFRvT3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRDZW50ZXJTdGVwKHJlc29sdmVkQXR0YWNoVG9PcHRpb25zKSB7XG4gIGlmIChyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8IHJlc29sdmVkQXR0YWNoVG9PcHRpb25zID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBcbiAgcmV0dXJuICFyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucy5lbGVtZW50IHx8ICFyZXNvbHZlZEF0dGFjaFRvT3B0aW9ucy5vbjtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG9wdGlvbnMgZm9yIHRoZSB0b29sdGlwIGFuZCBpbml0aWFsaXplc1xuICogYHN0ZXAudG9vbHRpcGAgYXMgYSBQb3BwZXIgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldHVwVG9vbHRpcChzdGVwKSB7XG4gIGlmIChzdGVwLnRvb2x0aXApIHtcbiAgICBzdGVwLnRvb2x0aXAuZGVzdHJveSgpO1xuICB9XG5cbiAgY29uc3QgYXR0YWNoVG9PcHRpb25zID0gc3RlcC5fZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKTtcblxuICBsZXQgdGFyZ2V0ID0gYXR0YWNoVG9PcHRpb25zLmVsZW1lbnQ7XG4gIGNvbnN0IHBvcHBlck9wdGlvbnMgPSBnZXRQb3BwZXJPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCk7XG5cbiAgaWYgKHNob3VsZENlbnRlclN0ZXAoYXR0YWNoVG9PcHRpb25zKSkge1xuICAgIHRhcmdldCA9IGRvY3VtZW50LmJvZHk7XG4gICAgY29uc3QgY29udGVudCA9IHN0ZXAuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ3NoZXBoZXJkLWNlbnRlcmVkJyk7XG4gIH1cblxuICBzdGVwLnRvb2x0aXAgPSBjcmVhdGVQb3BwZXIodGFyZ2V0LCBzdGVwLmVsLCBwb3BwZXJPcHRpb25zKTtcbiAgc3RlcC50YXJnZXQgPSBhdHRhY2hUb09wdGlvbnMuZWxlbWVudDtcblxuICByZXR1cm4gcG9wcGVyT3B0aW9ucztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSB1bmlxdWUgaWQgZm9yIHN0ZXBzLCB0b3VycywgbW9kYWxzLCBldGNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQoKSB7XG4gIGxldCBkID0gRGF0ZS5ub3coKTtcbiAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICBjb25zdCByID0gKGQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgIGQgPSBNYXRoLmZsb29yKGQgLyAxNik7XG4gICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYFBvcHBlcmAgb3B0aW9ucyBmcm9tIGEgc2V0IG9mIGJhc2UgYGF0dGFjaFRvYCBvcHRpb25zXG4gKiBAcGFyYW0gYXR0YWNoVG9PcHRpb25zXG4gKiBAcGFyYW0ge1N0ZXB9IHN0ZXAgVGhlIHN0ZXAgaW5zdGFuY2VcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3BwZXJPcHRpb25zKGF0dGFjaFRvT3B0aW9ucywgc3RlcCkge1xuICBsZXQgcG9wcGVyT3B0aW9ucyA9IHtcbiAgICBtb2RpZmllcnM6IFtcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBhbHRBeGlzOiB0cnVlLFxuICAgICAgICAgIHRldGhlcjogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlRm9jdXNBZnRlclJlbmRlck1vZGlmaWVyKHN0ZXApXG4gICAgXSxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJ1xuICB9O1xuXG4gIGlmIChzaG91bGRDZW50ZXJTdGVwKGF0dGFjaFRvT3B0aW9ucykpIHtcbiAgICBwb3BwZXJPcHRpb25zID0gbWFrZUNlbnRlcmVkUG9wcGVyKHN0ZXApO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9wdGlvbnMucGxhY2VtZW50ID0gYXR0YWNoVG9PcHRpb25zLm9uO1xuICB9XG5cbiAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zID1cbiAgICBzdGVwLnRvdXIgJiYgc3RlcC50b3VyLm9wdGlvbnMgJiYgc3RlcC50b3VyLm9wdGlvbnMuZGVmYXVsdFN0ZXBPcHRpb25zO1xuXG4gIGlmIChkZWZhdWx0U3RlcE9wdGlvbnMpIHtcbiAgICBwb3BwZXJPcHRpb25zID0gX21lcmdlTW9kaWZpZXJzKGRlZmF1bHRTdGVwT3B0aW9ucywgcG9wcGVyT3B0aW9ucyk7XG4gIH1cblxuICBwb3BwZXJPcHRpb25zID0gX21lcmdlTW9kaWZpZXJzKHN0ZXAub3B0aW9ucywgcG9wcGVyT3B0aW9ucyk7XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIF9tZXJnZU1vZGlmaWVycyhzdGVwT3B0aW9ucywgcG9wcGVyT3B0aW9ucykge1xuICBpZiAoc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucykge1xuICAgIGxldCBtZXJnZWRQb3BwZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIHt9LFxuICAgICAgcG9wcGVyT3B0aW9ucyxcbiAgICAgIHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnNcbiAgICApO1xuXG4gICAgaWYgKFxuICAgICAgc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMgJiZcbiAgICAgIHN0ZXBPcHRpb25zLnBvcHBlck9wdGlvbnMubW9kaWZpZXJzLmxlbmd0aCA+IDBcbiAgICApIHtcbiAgICAgIGNvbnN0IG5hbWVzID0gc3RlcE9wdGlvbnMucG9wcGVyT3B0aW9ucy5tb2RpZmllcnMubWFwKChtb2QpID0+IG1vZC5uYW1lKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkTW9kaWZpZXJzID0gcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMuZmlsdGVyKFxuICAgICAgICAobW9kKSA9PiAhbmFtZXMuaW5jbHVkZXMobW9kLm5hbWUpXG4gICAgICApO1xuXG4gICAgICBtZXJnZWRQb3BwZXJPcHRpb25zLm1vZGlmaWVycyA9IEFycmF5LmZyb20oXG4gICAgICAgIG5ldyBTZXQoWy4uLmZpbHRlcmVkTW9kaWZpZXJzLCAuLi5zdGVwT3B0aW9ucy5wb3BwZXJPcHRpb25zLm1vZGlmaWVyc10pXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZWRQb3BwZXJPcHRpb25zO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9wdGlvbnM7XG59XG4iLCJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIGFkZF9sb2NhdGlvbihlbGVtZW50LCBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIpIHtcbiAgICBlbGVtZW50Ll9fc3ZlbHRlX21ldGEgPSB7XG4gICAgICAgIGxvYzogeyBmaWxlLCBsaW5lLCBjb2x1bW4sIGNoYXIgfVxuICAgIH07XG59XG5mdW5jdGlvbiBydW4oZm4pIHtcbiAgICByZXR1cm4gZm4oKTtcbn1cbmZ1bmN0aW9uIGJsYW5rX29iamVjdCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbmZ1bmN0aW9uIHJ1bl9hbGwoZm5zKSB7XG4gICAgZm5zLmZvckVhY2gocnVuKTtcbn1cbmZ1bmN0aW9uIGlzX2Z1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHNhZmVfbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYiB8fCAoKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5sZXQgc3JjX3VybF9lcXVhbF9hbmNob3I7XG5mdW5jdGlvbiBzcmNfdXJsX2VxdWFsKGVsZW1lbnRfc3JjLCB1cmwpIHtcbiAgICBpZiAoIXNyY191cmxfZXF1YWxfYW5jaG9yKSB7XG4gICAgICAgIHNyY191cmxfZXF1YWxfYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIH1cbiAgICBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmID0gdXJsO1xuICAgIHJldHVybiBlbGVtZW50X3NyYyA9PT0gc3JjX3VybF9lcXVhbF9hbmNob3IuaHJlZjtcbn1cbmZ1bmN0aW9uIG5vdF9lcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgIT0gYSA/IGIgPT0gYiA6IGEgIT09IGI7XG59XG5mdW5jdGlvbiBpc19lbXB0eShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zdG9yZShzdG9yZSwgbmFtZSkge1xuICAgIGlmIChzdG9yZSAhPSBudWxsICYmIHR5cGVvZiBzdG9yZS5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtuYW1lfScgaXMgbm90IGEgc3RvcmUgd2l0aCBhICdzdWJzY3JpYmUnIG1ldGhvZGApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSwgLi4uY2FsbGJhY2tzKSB7XG4gICAgaWYgKHN0b3JlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgfVxuICAgIGNvbnN0IHVuc3ViID0gc3RvcmUuc3Vic2NyaWJlKC4uLmNhbGxiYWNrcyk7XG4gICAgcmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gKCkgPT4gdW5zdWIudW5zdWJzY3JpYmUoKSA6IHVuc3ViO1xufVxuZnVuY3Rpb24gZ2V0X3N0b3JlX3ZhbHVlKHN0b3JlKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIHN1YnNjcmliZShzdG9yZSwgXyA9PiB2YWx1ZSA9IF8pKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gY29tcG9uZW50X3N1YnNjcmliZShjb21wb25lbnQsIHN0b3JlLCBjYWxsYmFjaykge1xuICAgIGNvbXBvbmVudC4kJC5vbl9kZXN0cm95LnB1c2goc3Vic2NyaWJlKHN0b3JlLCBjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlX3Nsb3QoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHNsb3RfY3R4ID0gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKTtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25bMF0oc2xvdF9jdHgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NvbnRleHQoZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBmbikge1xuICAgIHJldHVybiBkZWZpbml0aW9uWzFdICYmIGZuXG4gICAgICAgID8gYXNzaWduKCQkc2NvcGUuY3R4LnNsaWNlKCksIGRlZmluaXRpb25bMV0oZm4oY3R4KSkpXG4gICAgICAgIDogJCRzY29wZS5jdHg7XG59XG5mdW5jdGlvbiBnZXRfc2xvdF9jaGFuZ2VzKGRlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBmbikge1xuICAgIGlmIChkZWZpbml0aW9uWzJdICYmIGZuKSB7XG4gICAgICAgIGNvbnN0IGxldHMgPSBkZWZpbml0aW9uWzJdKGZuKGRpcnR5KSk7XG4gICAgICAgIGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZXRzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbGV0cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gTWF0aC5tYXgoJCRzY29wZS5kaXJ0eS5sZW5ndGgsIGxldHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRbaV0gPSAkJHNjb3BlLmRpcnR5W2ldIHwgbGV0c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuICAgIH1cbiAgICByZXR1cm4gJCRzY29wZS5kaXJ0eTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICAgIGlmIChzbG90X2NoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jb250ZXh0ID0gZ2V0X3Nsb3RfY29udGV4dChzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG4gICAgICAgIHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3Qoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgY29uc3Qgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcbiAgICB1cGRhdGVfc2xvdF9iYXNlKHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBzbG90X2NoYW5nZXMsIGdldF9zbG90X2NvbnRleHRfZm4pO1xufVxuZnVuY3Rpb24gZ2V0X2FsbF9kaXJ0eV9mcm9tX3Njb3BlKCQkc2NvcGUpIHtcbiAgICBpZiAoJCRzY29wZS5jdHgubGVuZ3RoID4gMzIpIHtcbiAgICAgICAgY29uc3QgZGlydHkgPSBbXTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gJCRzY29wZS5jdHgubGVuZ3RoIC8gMzI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRpcnR5W2ldID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpcnR5O1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBleGNsdWRlX2ludGVybmFsX3Byb3BzKHByb3BzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrIGluIHByb3BzKVxuICAgICAgICBpZiAoa1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdWx0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVfcmVzdF9wcm9wcyhwcm9wcywga2V5cykge1xuICAgIGNvbnN0IHJlc3QgPSB7fTtcbiAgICBrZXlzID0gbmV3IFNldChrZXlzKTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmICgha2V5cy5oYXMoaykgJiYga1swXSAhPT0gJyQnKVxuICAgICAgICAgICAgcmVzdFtrXSA9IHByb3BzW2tdO1xuICAgIHJldHVybiByZXN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9zbG90cyhzbG90cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNsb3RzKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChyYW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICAgIGZuLmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG51bGxfdG9fZW1wdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfc3RvcmVfdmFsdWUoc3RvcmUsIHJldCwgdmFsdWUpIHtcbiAgICBzdG9yZS5zZXQodmFsdWUpO1xuICAgIHJldHVybiByZXQ7XG59XG5jb25zdCBoYXNfcHJvcCA9IChvYmosIHByb3ApID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xuZnVuY3Rpb24gYWN0aW9uX2Rlc3Ryb3llcihhY3Rpb25fcmVzdWx0KSB7XG4gICAgcmV0dXJuIGFjdGlvbl9yZXN1bHQgJiYgaXNfZnVuY3Rpb24oYWN0aW9uX3Jlc3VsdC5kZXN0cm95KSA/IGFjdGlvbl9yZXN1bHQuZGVzdHJveSA6IG5vb3A7XG59XG5cbmNvbnN0IGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xubGV0IG5vdyA9IGlzX2NsaWVudFxuICAgID8gKCkgPT4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXG4gICAgOiAoKSA9PiBEYXRlLm5vdygpO1xubGV0IHJhZiA9IGlzX2NsaWVudCA/IGNiID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShjYikgOiBub29wO1xuLy8gdXNlZCBpbnRlcm5hbGx5IGZvciB0ZXN0aW5nXG5mdW5jdGlvbiBzZXRfbm93KGZuKSB7XG4gICAgbm93ID0gZm47XG59XG5mdW5jdGlvbiBzZXRfcmFmKGZuKSB7XG4gICAgcmFmID0gZm47XG59XG5cbmNvbnN0IHRhc2tzID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICAgIHRhc2tzLmZvckVhY2godGFzayA9PiB7XG4gICAgICAgIGlmICghdGFzay5jKG5vdykpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgICAgIHRhc2suZigpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRhc2tzLnNpemUgIT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xufVxuLyoqXG4gKiBGb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5IVxuICovXG5mdW5jdGlvbiBjbGVhcl9sb29wcygpIHtcbiAgICB0YXNrcy5jbGVhcigpO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHRhc2sgdGhhdCBydW5zIG9uIGVhY2ggcmFmIGZyYW1lXG4gKiB1bnRpbCBpdCByZXR1cm5zIGEgZmFsc3kgdmFsdWUgb3IgaXMgYWJvcnRlZFxuICovXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gICAgbGV0IHRhc2s7XG4gICAgaWYgKHRhc2tzLnNpemUgPT09IDApXG4gICAgICAgIHJhZihydW5fdGFza3MpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IG5ldyBQcm9taXNlKGZ1bGZpbGwgPT4ge1xuICAgICAgICAgICAgdGFza3MuYWRkKHRhc2sgPSB7IGM6IGNhbGxiYWNrLCBmOiBmdWxmaWxsIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgYWJvcnQoKSB7XG4gICAgICAgICAgICB0YXNrcy5kZWxldGUodGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUcmFjayB3aGljaCBub2RlcyBhcmUgY2xhaW1lZCBkdXJpbmcgaHlkcmF0aW9uLiBVbmNsYWltZWQgbm9kZXMgY2FuIHRoZW4gYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbi8vIGF0IHRoZSBlbmQgb2YgaHlkcmF0aW9uIHdpdGhvdXQgdG91Y2hpbmcgdGhlIHJlbWFpbmluZyBub2Rlcy5cbmxldCBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbmZ1bmN0aW9uIHN0YXJ0X2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSB0cnVlO1xufVxuZnVuY3Rpb24gZW5kX2h5ZHJhdGluZygpIHtcbiAgICBpc19oeWRyYXRpbmcgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwcGVyX2JvdW5kKGxvdywgaGlnaCwga2V5LCB2YWx1ZSkge1xuICAgIC8vIFJldHVybiBmaXJzdCBpbmRleCBvZiB2YWx1ZSBsYXJnZXIgdGhhbiBpbnB1dCB2YWx1ZSBpbiB0aGUgcmFuZ2UgW2xvdywgaGlnaClcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICBjb25zdCBtaWQgPSBsb3cgKyAoKGhpZ2ggLSBsb3cpID4+IDEpO1xuICAgICAgICBpZiAoa2V5KG1pZCkgPD0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG59XG5mdW5jdGlvbiBpbml0X2h5ZHJhdGUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5oeWRyYXRlX2luaXQpXG4gICAgICAgIHJldHVybjtcbiAgICB0YXJnZXQuaHlkcmF0ZV9pbml0ID0gdHJ1ZTtcbiAgICAvLyBXZSBrbm93IHRoYXQgYWxsIGNoaWxkcmVuIGhhdmUgY2xhaW1fb3JkZXIgdmFsdWVzIHNpbmNlIHRoZSB1bmNsYWltZWQgaGF2ZSBiZWVuIGRldGFjaGVkIGlmIHRhcmdldCBpcyBub3QgPGhlYWQ+XG4gICAgbGV0IGNoaWxkcmVuID0gdGFyZ2V0LmNoaWxkTm9kZXM7XG4gICAgLy8gSWYgdGFyZ2V0IGlzIDxoZWFkPiwgdGhlcmUgbWF5IGJlIGNoaWxkcmVuIHdpdGhvdXQgY2xhaW1fb3JkZXJcbiAgICBpZiAodGFyZ2V0Lm5vZGVOYW1lID09PSAnSEVBRCcpIHtcbiAgICAgICAgY29uc3QgbXlDaGlsZHJlbiA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAobm9kZS5jbGFpbV9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbXlDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuID0gbXlDaGlsZHJlbjtcbiAgICB9XG4gICAgLypcbiAgICAqIFJlb3JkZXIgY2xhaW1lZCBjaGlsZHJlbiBvcHRpbWFsbHkuXG4gICAgKiBXZSBjYW4gcmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseSBieSBmaW5kaW5nIHRoZSBsb25nZXN0IHN1YnNlcXVlbmNlIG9mXG4gICAgKiBub2RlcyB0aGF0IGFyZSBhbHJlYWR5IGNsYWltZWQgaW4gb3JkZXIgYW5kIG9ubHkgbW92aW5nIHRoZSByZXN0LiBUaGUgbG9uZ2VzdFxuICAgICogc3Vic2VxdWVuY2Ugc3Vic2VxdWVuY2Ugb2Ygbm9kZXMgdGhhdCBhcmUgY2xhaW1lZCBpbiBvcmRlciBjYW4gYmUgZm91bmQgYnlcbiAgICAqIGNvbXB1dGluZyB0aGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIC5jbGFpbV9vcmRlciB2YWx1ZXMuXG4gICAgKlxuICAgICogVGhpcyBhbGdvcml0aG0gaXMgb3B0aW1hbCBpbiBnZW5lcmF0aW5nIHRoZSBsZWFzdCBhbW91bnQgb2YgcmVvcmRlciBvcGVyYXRpb25zXG4gICAgKiBwb3NzaWJsZS5cbiAgICAqXG4gICAgKiBQcm9vZjpcbiAgICAqIFdlIGtub3cgdGhhdCwgZ2l2ZW4gYSBzZXQgb2YgcmVvcmRlcmluZyBvcGVyYXRpb25zLCB0aGUgbm9kZXMgdGhhdCBkbyBub3QgbW92ZVxuICAgICogYWx3YXlzIGZvcm0gYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSwgc2luY2UgdGhleSBkbyBub3QgbW92ZSBhbW9uZyBlYWNoIG90aGVyXG4gICAgKiBtZWFuaW5nIHRoYXQgdGhleSBtdXN0IGJlIGFscmVhZHkgb3JkZXJlZCBhbW9uZyBlYWNoIG90aGVyLiBUaHVzLCB0aGUgbWF4aW1hbFxuICAgICogc2V0IG9mIG5vZGVzIHRoYXQgZG8gbm90IG1vdmUgZm9ybSBhIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZS5cbiAgICAqL1xuICAgIC8vIENvbXB1dGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlXG4gICAgLy8gbTogc3Vic2VxdWVuY2UgbGVuZ3RoIGogPT4gaW5kZXggayBvZiBzbWFsbGVzdCB2YWx1ZSB0aGF0IGVuZHMgYW4gaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBsZW5ndGggalxuICAgIGNvbnN0IG0gPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGggKyAxKTtcbiAgICAvLyBQcmVkZWNlc3NvciBpbmRpY2VzICsgMVxuICAgIGNvbnN0IHAgPSBuZXcgSW50MzJBcnJheShjaGlsZHJlbi5sZW5ndGgpO1xuICAgIG1bMF0gPSAtMTtcbiAgICBsZXQgbG9uZ2VzdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gY2hpbGRyZW5baV0uY2xhaW1fb3JkZXI7XG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3Qgc3Vic2VxdWVuY2UgbGVuZ3RoIHN1Y2ggdGhhdCBpdCBlbmRzIGluIGEgdmFsdWUgbGVzcyB0aGFuIG91ciBjdXJyZW50IHZhbHVlXG4gICAgICAgIC8vIHVwcGVyX2JvdW5kIHJldHVybnMgZmlyc3QgZ3JlYXRlciB2YWx1ZSwgc28gd2Ugc3VidHJhY3Qgb25lXG4gICAgICAgIC8vIHdpdGggZmFzdCBwYXRoIGZvciB3aGVuIHdlIGFyZSBvbiB0aGUgY3VycmVudCBsb25nZXN0IHN1YnNlcXVlbmNlXG4gICAgICAgIGNvbnN0IHNlcUxlbiA9ICgobG9uZ2VzdCA+IDAgJiYgY2hpbGRyZW5bbVtsb25nZXN0XV0uY2xhaW1fb3JkZXIgPD0gY3VycmVudCkgPyBsb25nZXN0ICsgMSA6IHVwcGVyX2JvdW5kKDEsIGxvbmdlc3QsIGlkeCA9PiBjaGlsZHJlblttW2lkeF1dLmNsYWltX29yZGVyLCBjdXJyZW50KSkgLSAxO1xuICAgICAgICBwW2ldID0gbVtzZXFMZW5dICsgMTtcbiAgICAgICAgY29uc3QgbmV3TGVuID0gc2VxTGVuICsgMTtcbiAgICAgICAgLy8gV2UgY2FuIGd1YXJhbnRlZSB0aGF0IGN1cnJlbnQgaXMgdGhlIHNtYWxsZXN0IHZhbHVlLiBPdGhlcndpc2UsIHdlIHdvdWxkIGhhdmUgZ2VuZXJhdGVkIGEgbG9uZ2VyIHNlcXVlbmNlLlxuICAgICAgICBtW25ld0xlbl0gPSBpO1xuICAgICAgICBsb25nZXN0ID0gTWF0aC5tYXgobmV3TGVuLCBsb25nZXN0KTtcbiAgICB9XG4gICAgLy8gVGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZSBvZiBub2RlcyAoaW5pdGlhbGx5IHJldmVyc2VkKVxuICAgIGNvbnN0IGxpcyA9IFtdO1xuICAgIC8vIFRoZSByZXN0IG9mIHRoZSBub2Rlcywgbm9kZXMgdGhhdCB3aWxsIGJlIG1vdmVkXG4gICAgY29uc3QgdG9Nb3ZlID0gW107XG4gICAgbGV0IGxhc3QgPSBjaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGN1ciA9IG1bbG9uZ2VzdF0gKyAxOyBjdXIgIT0gMDsgY3VyID0gcFtjdXIgLSAxXSkge1xuICAgICAgICBsaXMucHVzaChjaGlsZHJlbltjdXIgLSAxXSk7XG4gICAgICAgIGZvciAoOyBsYXN0ID49IGN1cjsgbGFzdC0tKSB7XG4gICAgICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdC0tO1xuICAgIH1cbiAgICBmb3IgKDsgbGFzdCA+PSAwOyBsYXN0LS0pIHtcbiAgICAgICAgdG9Nb3ZlLnB1c2goY2hpbGRyZW5bbGFzdF0pO1xuICAgIH1cbiAgICBsaXMucmV2ZXJzZSgpO1xuICAgIC8vIFdlIHNvcnQgdGhlIG5vZGVzIGJlaW5nIG1vdmVkIHRvIGd1YXJhbnRlZSB0aGF0IHRoZWlyIGluc2VydGlvbiBvcmRlciBtYXRjaGVzIHRoZSBjbGFpbSBvcmRlclxuICAgIHRvTW92ZS5zb3J0KChhLCBiKSA9PiBhLmNsYWltX29yZGVyIC0gYi5jbGFpbV9vcmRlcik7XG4gICAgLy8gRmluYWxseSwgd2UgbW92ZSB0aGUgbm9kZXNcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCB0b01vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGogPCBsaXMubGVuZ3RoICYmIHRvTW92ZVtpXS5jbGFpbV9vcmRlciA+PSBsaXNbal0uY2xhaW1fb3JkZXIpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmNob3IgPSBqIDwgbGlzLmxlbmd0aCA/IGxpc1tqXSA6IG51bGw7XG4gICAgICAgIHRhcmdldC5pbnNlcnRCZWZvcmUodG9Nb3ZlW2ldLCBhbmNob3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZCh0YXJnZXQsIG5vZGUpIHtcbiAgICB0YXJnZXQuYXBwZW5kQ2hpbGQobm9kZSk7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzKHRhcmdldCwgc3R5bGVfc2hlZXRfaWQsIHN0eWxlcykge1xuICAgIGNvbnN0IGFwcGVuZF9zdHlsZXNfdG8gPSBnZXRfcm9vdF9mb3Jfc3R5bGUodGFyZ2V0KTtcbiAgICBpZiAoIWFwcGVuZF9zdHlsZXNfdG8uZ2V0RWxlbWVudEJ5SWQoc3R5bGVfc2hlZXRfaWQpKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGUuaWQgPSBzdHlsZV9zaGVldF9pZDtcbiAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZXM7XG4gICAgICAgIGFwcGVuZF9zdHlsZXNoZWV0KGFwcGVuZF9zdHlsZXNfdG8sIHN0eWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSkge1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIGNvbnN0IHJvb3QgPSBub2RlLmdldFJvb3ROb2RlID8gbm9kZS5nZXRSb290Tm9kZSgpIDogbm9kZS5vd25lckRvY3VtZW50O1xuICAgIGlmIChyb290ICYmIHJvb3QuaG9zdCkge1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0KG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZV9lbGVtZW50ID0gZWxlbWVudCgnc3R5bGUnKTtcbiAgICBhcHBlbmRfc3R5bGVzaGVldChnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSksIHN0eWxlX2VsZW1lbnQpO1xuICAgIHJldHVybiBzdHlsZV9lbGVtZW50LnNoZWV0O1xufVxuZnVuY3Rpb24gYXBwZW5kX3N0eWxlc2hlZXQobm9kZSwgc3R5bGUpIHtcbiAgICBhcHBlbmQobm9kZS5oZWFkIHx8IG5vZGUsIHN0eWxlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50RWxlbWVudCAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGxpc3Rlbihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzdG9wX3Byb3BhZ2F0aW9uKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNlbGYoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcylcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0cnVzdGVkKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChldmVudC5pc1RydXN0ZWQpXG4gICAgICAgICAgICBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgZWxzZSBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKSAhPT0gdmFsdWUpXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0X2F0dHJpYnV0ZXMobm9kZSwgYXR0cmlidXRlcykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG5vZGUuX19wcm90b19fKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuY3NzVGV4dCA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXkgPT09ICdfX3ZhbHVlJykge1xuICAgICAgICAgICAgbm9kZS52YWx1ZSA9IG5vZGVba2V5XSA9IGF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkZXNjcmlwdG9yc1trZXldICYmIGRlc2NyaXB0b3JzW2tleV0uc2V0KSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24geGxpbmtfYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsIGF0dHJpYnV0ZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUoZ3JvdXAsIF9fdmFsdWUsIGNoZWNrZWQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChncm91cFtpXS5jaGVja2VkKVxuICAgICAgICAgICAgdmFsdWUuYWRkKGdyb3VwW2ldLl9fdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgdmFsdWUuZGVsZXRlKF9fdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24odW5kZWZpbmVkLCBpc19zdmcpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ICE9PSBkYXRhKVxuICAgICAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3ZhbHVlKGlucHV0LCB2YWx1ZSkge1xuICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG59XG5mdW5jdGlvbiBzZXRfaW5wdXRfdHlwZShpbnB1dCwgdHlwZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlucHV0LnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X3N0eWxlKG5vZGUsIGtleSwgdmFsdWUsIGltcG9ydGFudCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIGlmIChvcHRpb24uX192YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0LnNlbGVjdGVkSW5kZXggPSAtMTsgLy8gbm8gb3B0aW9uIHNob3VsZCBiZSBzZWxlY3RlZFxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJykgfHwgc2VsZWN0Lm9wdGlvbnNbMF07XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfcmVzaXplX2xpc3RlbmVyKG5vZGUsIGZuKSB7XG4gICAgY29uc3QgY29tcHV0ZWRfc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChjb21wdXRlZF9zdHlsZS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIGNvbnN0IGlmcmFtZSA9IGVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IGJsb2NrOyBwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgbGVmdDogMDsgd2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJTsgJyArXG4gICAgICAgICdvdmVyZmxvdzogaGlkZGVuOyBib3JkZXI6IDA7IG9wYWNpdHk6IDA7IHBvaW50ZXItZXZlbnRzOiBub25lOyB6LWluZGV4OiAtMTsnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgaWZyYW1lLnRhYkluZGV4ID0gLTE7XG4gICAgY29uc3QgY3Jvc3NvcmlnaW4gPSBpc19jcm9zc29yaWdpbigpO1xuICAgIGxldCB1bnN1YnNjcmliZTtcbiAgICBpZiAoY3Jvc3NvcmlnaW4pIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9IFwiZGF0YTp0ZXh0L2h0bWwsPHNjcmlwdD5vbnJlc2l6ZT1mdW5jdGlvbigpe3BhcmVudC5wb3N0TWVzc2FnZSgwLCcqJyl9PC9zY3JpcHQ+XCI7XG4gICAgICAgIHVuc3Vic2NyaWJlID0gbGlzdGVuKHdpbmRvdywgJ21lc3NhZ2UnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGlmcmFtZS5jb250ZW50V2luZG93KVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWZyYW1lLnNyYyA9ICdhYm91dDpibGFuayc7XG4gICAgICAgIGlmcmFtZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3RlbihpZnJhbWUuY29udGVudFdpbmRvdywgJ3Jlc2l6ZScsIGZuKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXBwZW5kKG5vZGUsIGlmcmFtZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuc3Vic2NyaWJlICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGFjaChpZnJhbWUpO1xuICAgIH07XG59XG5mdW5jdGlvbiB0b2dnbGVfY2xhc3MoZWxlbWVudCwgbmFtZSwgdG9nZ2xlKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3RbdG9nZ2xlID8gJ2FkZCcgOiAncmVtb3ZlJ10obmFtZSk7XG59XG5mdW5jdGlvbiBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGJ1YmJsZXMgPSBmYWxzZSwgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBidWJibGVzLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xuICAgIHJldHVybiBlO1xufVxuZnVuY3Rpb24gcXVlcnlfc2VsZWN0b3JfYWxsKHNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudC5ib2R5KSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20ocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfc3ZnKVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHN2Z19lbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lID0gZWxlbWVudCh0YXJnZXQubm9kZU5hbWUpO1xuICAgICAgICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLmNoaWxkTm9kZXMpO1xuICAgIH1cbiAgICBpKGFuY2hvcikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHAoaHRtbCkge1xuICAgICAgICB0aGlzLmQoKTtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gICAgZCgpIHtcbiAgICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG59XG5jbGFzcyBIdG1sVGFnSHlkcmF0aW9uIGV4dGVuZHMgSHRtbFRhZyB7XG4gICAgY29uc3RydWN0b3IoY2xhaW1lZF9ub2RlcywgaXNfc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoaXNfc3ZnKTtcbiAgICAgICAgdGhpcy5lID0gdGhpcy5uID0gbnVsbDtcbiAgICAgICAgdGhpcy5sID0gY2xhaW1lZF9ub2RlcztcbiAgICB9XG4gICAgYyhodG1sKSB7XG4gICAgICAgIGlmICh0aGlzLmwpIHtcbiAgICAgICAgICAgIHRoaXMubiA9IHRoaXMubDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLmMoaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydF9oeWRyYXRpb24odGhpcy50LCB0aGlzLm5baV0sIGFuY2hvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBhdHRyaWJ1dGVfdG9fb2JqZWN0KGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGF0dHJpYnV0ZSBvZiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJlc3VsdFthdHRyaWJ1dGUubmFtZV0gPSBhdHRyaWJ1dGUudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRfY3VzdG9tX2VsZW1lbnRzX3Nsb3RzKGVsZW1lbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBlbGVtZW50LmNoaWxkTm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICByZXN1bHRbbm9kZS5zbG90IHx8ICdkZWZhdWx0J10gPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHdlIG5lZWQgdG8gc3RvcmUgdGhlIGluZm9ybWF0aW9uIGZvciBtdWx0aXBsZSBkb2N1bWVudHMgYmVjYXVzZSBhIFN2ZWx0ZSBhcHBsaWNhdGlvbiBjb3VsZCBhbHNvIGNvbnRhaW4gaWZyYW1lc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3N2ZWx0ZWpzL3N2ZWx0ZS9pc3N1ZXMvMzYyNFxuY29uc3QgbWFuYWdlZF9zdHlsZXMgPSBuZXcgTWFwKCk7XG5sZXQgYWN0aXZlID0gMDtcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5mdW5jdGlvbiBoYXNoKHN0cikge1xuICAgIGxldCBoYXNoID0gNTM4MTtcbiAgICBsZXQgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGhhc2ggPj4+IDA7XG59XG5mdW5jdGlvbiBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKSB7XG4gICAgY29uc3QgaW5mbyA9IHsgc3R5bGVzaGVldDogYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSksIHJ1bGVzOiB7fSB9O1xuICAgIG1hbmFnZWRfc3R5bGVzLnNldChkb2MsIGluZm8pO1xuICAgIHJldHVybiBpbmZvO1xufVxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbiwgdWlkID0gMCkge1xuICAgIGNvbnN0IHN0ZXAgPSAxNi42NjYgLyBkdXJhdGlvbjtcbiAgICBsZXQga2V5ZnJhbWVzID0gJ3tcXG4nO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgICAgICBjb25zdCB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgICAgICBrZXlmcmFtZXMgKz0gcCAqIDEwMCArIGAleyR7Zm4odCwgMSAtIHQpfX1cXG5gO1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ga2V5ZnJhbWVzICsgYDEwMCUgeyR7Zm4oYiwgMSAtIGIpfX1cXG59YDtcbiAgICBjb25zdCBuYW1lID0gYF9fc3ZlbHRlXyR7aGFzaChydWxlKX1fJHt1aWR9YDtcbiAgICBjb25zdCBkb2MgPSBnZXRfcm9vdF9mb3Jfc3R5bGUobm9kZSk7XG4gICAgY29uc3QgeyBzdHlsZXNoZWV0LCBydWxlcyB9ID0gbWFuYWdlZF9zdHlsZXMuZ2V0KGRvYykgfHwgY3JlYXRlX3N0eWxlX2luZm9ybWF0aW9uKGRvYywgbm9kZSk7XG4gICAgaWYgKCFydWxlc1tuYW1lXSkge1xuICAgICAgICBydWxlc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShgQGtleWZyYW1lcyAke25hbWV9ICR7cnVsZX1gLCBzdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGFuaW1hdGlvbiA9IG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnO1xuICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gYCR7YW5pbWF0aW9uID8gYCR7YW5pbWF0aW9ufSwgYCA6ICcnfSR7bmFtZX0gJHtkdXJhdGlvbn1tcyBsaW5lYXIgJHtkZWxheX1tcyAxIGJvdGhgO1xuICAgIGFjdGl2ZSArPSAxO1xuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gZGVsZXRlX3J1bGUobm9kZSwgbmFtZSkge1xuICAgIGNvbnN0IHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgICBjb25zdCBuZXh0ID0gcHJldmlvdXMuZmlsdGVyKG5hbWVcbiAgICAgICAgPyBhbmltID0+IGFuaW0uaW5kZXhPZihuYW1lKSA8IDAgLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICAgICAgICA6IGFuaW0gPT4gYW5pbS5pbmRleE9mKCdfX3N2ZWx0ZScpID09PSAtMSAvLyByZW1vdmUgYWxsIFN2ZWx0ZSBhbmltYXRpb25zXG4gICAgKTtcbiAgICBjb25zdCBkZWxldGVkID0gcHJldmlvdXMubGVuZ3RoIC0gbmV4dC5sZW5ndGg7XG4gICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgICAgIGFjdGl2ZSAtPSBkZWxldGVkO1xuICAgICAgICBpZiAoIWFjdGl2ZSlcbiAgICAgICAgICAgIGNsZWFyX3J1bGVzKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gICAgcmFmKCgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWFuYWdlZF9zdHlsZXMuZm9yRWFjaChpbmZvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3R5bGVzaGVldCB9ID0gaW5mbztcbiAgICAgICAgICAgIGxldCBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKVxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXQuZGVsZXRlUnVsZShpKTtcbiAgICAgICAgICAgIGluZm8ucnVsZXMgPSB7fTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX21vdW50LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gYWZ0ZXJVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5hZnRlcl91cGRhdGUucHVzaChmbik7XG59XG5mdW5jdGlvbiBvbkRlc3Ryb3koZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9kZXN0cm95LnB1c2goZm4pO1xufVxuZnVuY3Rpb24gY3JlYXRlRXZlbnREaXNwYXRjaGVyKCkge1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgIHJldHVybiAodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gY29tcG9uZW50LiQkLmNhbGxiYWNrc1t0eXBlXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgLy8gVE9ETyBhcmUgdGhlcmUgc2l0dWF0aW9ucyB3aGVyZSBldmVudHMgY291bGQgYmUgZGlzcGF0Y2hlZFxuICAgICAgICAgICAgLy8gaW4gYSBzZXJ2ZXIgKG5vbi1ET00pIGVudmlyb25tZW50P1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBjdXN0b21fZXZlbnQodHlwZSwgZGV0YWlsLCB7IGNhbmNlbGFibGUgfSk7XG4gICAgICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGNvbXBvbmVudCwgZXZlbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGdldENvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuZ2V0KGtleSk7XG59XG5mdW5jdGlvbiBnZXRBbGxDb250ZXh0cygpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dDtcbn1cbmZ1bmN0aW9uIGhhc0NvbnRleHQoa2V5KSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQuaGFzKGtleSk7XG59XG4vLyBUT0RPIGZpZ3VyZSBvdXQgaWYgd2Ugc3RpbGwgd2FudCB0byBzdXBwb3J0XG4vLyBzaG9ydGhhbmQgZXZlbnRzLCBvciBpZiB3ZSB3YW50IHRvIGltcGxlbWVudFxuLy8gYSByZWFsIGJ1YmJsaW5nIG1lY2hhbmlzbVxuZnVuY3Rpb24gYnViYmxlKGNvbXBvbmVudCwgZXZlbnQpIHtcbiAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW2V2ZW50LnR5cGVdO1xuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYWxsYmFja3Muc2xpY2UoKS5mb3JFYWNoKGZuID0+IGZuLmNhbGwodGhpcywgZXZlbnQpKTtcbiAgICB9XG59XG5cbmNvbnN0IGRpcnR5X2NvbXBvbmVudHMgPSBbXTtcbmNvbnN0IGludHJvcyA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbmNvbnN0IGJpbmRpbmdfY2FsbGJhY2tzID0gW107XG5jb25zdCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbmxldCB1cGRhdGVfc2NoZWR1bGVkID0gZmFsc2U7XG5mdW5jdGlvbiBzY2hlZHVsZV91cGRhdGUoKSB7XG4gICAgaWYgKCF1cGRhdGVfc2NoZWR1bGVkKSB7XG4gICAgICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRpY2soKSB7XG4gICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgcmV0dXJuIHJlc29sdmVkX3Byb21pc2U7XG59XG5mdW5jdGlvbiBhZGRfcmVuZGVyX2NhbGxiYWNrKGZuKSB7XG4gICAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbmZ1bmN0aW9uIGFkZF9mbHVzaF9jYWxsYmFjayhmbikge1xuICAgIGZsdXNoX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cbi8vIGZsdXNoKCkgY2FsbHMgY2FsbGJhY2tzIGluIHRoaXMgb3JkZXI6XG4vLyAxLiBBbGwgYmVmb3JlVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuXG4vLyAyLiBBbGwgYmluZDp0aGlzIGNhbGxiYWNrcywgaW4gcmV2ZXJzZSBvcmRlcjogY2hpbGRyZW4gYmVmb3JlIHBhcmVudHMuXG4vLyAzLiBBbGwgYWZ0ZXJVcGRhdGUgY2FsbGJhY2tzLCBpbiBvcmRlcjogcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIEVYQ0VQVFxuLy8gICAgZm9yIGFmdGVyVXBkYXRlcyBjYWxsZWQgZHVyaW5nIHRoZSBpbml0aWFsIG9uTW91bnQsIHdoaWNoIGFyZSBjYWxsZWQgaW5cbi8vICAgIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gU2luY2UgY2FsbGJhY2tzIG1pZ2h0IHVwZGF0ZSBjb21wb25lbnQgdmFsdWVzLCB3aGljaCBjb3VsZCB0cmlnZ2VyIGFub3RoZXJcbi8vIGNhbGwgdG8gZmx1c2goKSwgdGhlIGZvbGxvd2luZyBzdGVwcyBndWFyZCBhZ2FpbnN0IHRoaXM6XG4vLyAxLiBEdXJpbmcgYmVmb3JlVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgYmUgYWRkZWQgdG8gdGhlXG4vLyAgICBkaXJ0eV9jb21wb25lbnRzIGFycmF5IGFuZCB3aWxsIGNhdXNlIGEgcmVlbnRyYW50IGNhbGwgdG8gZmx1c2goKS4gQmVjYXVzZVxuLy8gICAgdGhlIGZsdXNoIGluZGV4IGlzIGtlcHQgb3V0c2lkZSB0aGUgZnVuY3Rpb24sIHRoZSByZWVudHJhbnQgY2FsbCB3aWxsIHBpY2tcbi8vICAgIHVwIHdoZXJlIHRoZSBlYXJsaWVyIGNhbGwgbGVmdCBvZmYgYW5kIGdvIHRocm91Z2ggYWxsIGRpcnR5IGNvbXBvbmVudHMuIFRoZVxuLy8gICAgY3VycmVudF9jb21wb25lbnQgdmFsdWUgaXMgc2F2ZWQgYW5kIHJlc3RvcmVkIHNvIHRoYXQgdGhlIHJlZW50cmFudCBjYWxsIHdpbGxcbi8vICAgIG5vdCBpbnRlcmZlcmUgd2l0aCB0aGUgXCJwYXJlbnRcIiBmbHVzaCgpIGNhbGwuXG4vLyAyLiBiaW5kOnRoaXMgY2FsbGJhY2tzIGNhbm5vdCB0cmlnZ2VyIG5ldyBmbHVzaCgpIGNhbGxzLlxuLy8gMy4gRHVyaW5nIGFmdGVyVXBkYXRlLCBhbnkgdXBkYXRlZCBjb21wb25lbnRzIHdpbGwgTk9UIGhhdmUgdGhlaXIgYWZ0ZXJVcGRhdGVcbi8vICAgIGNhbGxiYWNrIGNhbGxlZCBhIHNlY29uZCB0aW1lOyB0aGUgc2Vlbl9jYWxsYmFja3Mgc2V0LCBvdXRzaWRlIHRoZSBmbHVzaCgpXG4vLyAgICBmdW5jdGlvbiwgZ3VhcmFudGVlcyB0aGlzIGJlaGF2aW9yLlxuY29uc3Qgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgZmx1c2hpZHggPSAwOyAvLyBEbyAqbm90KiBtb3ZlIHRoaXMgaW5zaWRlIHRoZSBmbHVzaCgpIGZ1bmN0aW9uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBjb25zdCBzYXZlZF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICBkbyB7XG4gICAgICAgIC8vIGZpcnN0LCBjYWxsIGJlZm9yZVVwZGF0ZSBmdW5jdGlvbnNcbiAgICAgICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgICAgIHdoaWxlIChmbHVzaGlkeCA8IGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgIGZsdXNoaWR4Kys7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZygpO1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdvKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGVuZCgpIHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVfb3V0X3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWU7XG4gICAgY29uc3QgZ3JvdXAgPSBvdXRyb3M7XG4gICAgZ3JvdXAuciArPSAxO1xuICAgIGZ1bmN0aW9uIGdvKCkge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBpZiAoY3NzKVxuICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCAxLCAwLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKCgpID0+IGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnc3RhcnQnKSk7XG4gICAgICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBlbmRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBmYWxzZSwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIS0tZ3JvdXAucikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIHJlc3VsdCBpbiBgZW5kKClgIGJlaW5nIGNhbGxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHdlIGRvbid0IG5lZWQgdG8gY2xlYW4gdXAgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVuX2FsbChncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3cgPj0gc3RhcnRfdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ID0gZWFzaW5nKChub3cgLSBzdGFydF90aW1lKSAvIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGljaygxIC0gdCwgdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICB3YWl0KCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBsZXQgY29uZmlnID0gZm4obm9kZSwgcGFyYW1zKTtcbiAgICBsZXQgdCA9IGludHJvID8gMCA6IDE7XG4gICAgbGV0IHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lID0gbnVsbDtcbiAgICBmdW5jdGlvbiBjbGVhcl9hbmltYXRpb24oKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW5pdChwcm9ncmFtLCBkdXJhdGlvbikge1xuICAgICAgICBjb25zdCBkID0gKHByb2dyYW0uYiAtIHQpO1xuICAgICAgICBkdXJhdGlvbiAqPSBNYXRoLmFicyhkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGE6IHQsXG4gICAgICAgICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICAgICAgICBkLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICBzdGFydDogcHJvZ3JhbS5zdGFydCxcbiAgICAgICAgICAgIGVuZDogcHJvZ3JhbS5zdGFydCArIGR1cmF0aW9uLFxuICAgICAgICAgICAgZ3JvdXA6IHByb2dyYW0uZ3JvdXBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oYikge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCB0aWNrID0gbm9vcCwgY3NzIH0gPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBwcm9ncmFtID0ge1xuICAgICAgICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICAgICAgICBiXG4gICAgICAgIH07XG4gICAgICAgIGlmICghYikge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICAgICAgICBvdXRyb3MuciArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhpcyBpcyBhbiBpbnRybywgYW5kIHRoZXJlJ3MgYSBkZWxheSwgd2UgbmVlZCB0byBkb1xuICAgICAgICAgICAgLy8gYW4gaW5pdGlhbCB0aWNrIGFuZC9vciBhcHBseSBDU1MgYW5pbWF0aW9uIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uX25hbWUgPSBjcmVhdGVfcnVsZShub2RlLCB0LCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2luZywgY3NzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiKVxuICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHByb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgYiwgJ3N0YXJ0JykpO1xuICAgICAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nX3Byb2dyYW0gJiYgbm93ID4gcGVuZGluZ19wcm9ncmFtLnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocGVuZGluZ19wcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5lbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCA9IHJ1bm5pbmdfcHJvZ3JhbS5iLCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaChub2RlLCBydW5uaW5nX3Byb2dyYW0uYiwgJ2VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSdyZSBkb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHJvIOKAlCB3ZSBjYW4gdGlkeSB1cCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG91dHJvIOKAlCBuZWVkcyB0byBiZSBjb29yZGluYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIS0tcnVubmluZ19wcm9ncmFtLmdyb3VwLnIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKHJ1bm5pbmdfcHJvZ3JhbS5ncm91cC5jKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub3cgLSBydW5uaW5nX3Byb2dyYW0uc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gcnVubmluZ19wcm9ncmFtLmEgKyBydW5uaW5nX3Byb2dyYW0uZCAqIGVhc2luZyhwIC8gcnVubmluZ19wcm9ncmFtLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAhIShydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJ1bihiKSB7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25maWcgPSBjb25maWcoKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5jb25zdCBnbG9iYWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGdsb2JhbFRoaXNcbiAgICAgICAgOiBnbG9iYWwpO1xuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgaSA9IG47XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBibG9jayA9IGxvb2t1cC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICAgICAgICBibG9jay5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHluYW1pYykge1xuICAgICAgICAgICAgYmxvY2sucChjaGlsZF9jdHgsIGRpcnR5KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJldHVybiBuZXdfYmxvY2tzO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9rZXlzKGN0eCwgbGlzdCwgZ2V0X2NvbnRleHQsIGdldF9rZXkpIHtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSBnZXRfa2V5KGdldF9jb250ZXh0KGN0eCwgbGlzdCwgaSkpO1xuICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaGF2ZSBkdXBsaWNhdGUga2V5cyBpbiBhIGtleWVkIGVhY2gnKTtcbiAgICAgICAgfVxuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0X3NwcmVhZF91cGRhdGUobGV2ZWxzLCB1cGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlID0ge307XG4gICAgY29uc3QgdG9fbnVsbF9vdXQgPSB7fTtcbiAgICBjb25zdCBhY2NvdW50ZWRfZm9yID0geyAkJHNjb3BlOiAxIH07XG4gICAgbGV0IGkgPSBsZXZlbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgbyA9IGxldmVsc1tpXTtcbiAgICAgICAgY29uc3QgbiA9IHVwZGF0ZXNbaV07XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG4pKVxuICAgICAgICAgICAgICAgICAgICB0b19udWxsX291dFtrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnRlZF9mb3Jba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVba2V5XSA9IG5ba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXZlbHNbaV0gPSBuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbykge1xuICAgICAgICAgICAgICAgIGFjY291bnRlZF9mb3Jba2V5XSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdG9fbnVsbF9vdXQpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHVwZGF0ZSkpXG4gICAgICAgICAgICB1cGRhdGVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGdldF9zcHJlYWRfb2JqZWN0KHNwcmVhZF9wcm9wcykge1xuICAgIHJldHVybiB0eXBlb2Ygc3ByZWFkX3Byb3BzID09PSAnb2JqZWN0JyAmJiBzcHJlYWRfcHJvcHMgIT09IG51bGwgPyBzcHJlYWRfcHJvcHMgOiB7fTtcbn1cblxuLy8gc291cmNlOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWxcbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpc21hcCcsXG4gICAgJ2xvb3AnLFxuICAgICdtdWx0aXBsZScsXG4gICAgJ211dGVkJyxcbiAgICAnbm9tb2R1bGUnLFxuICAgICdub3ZhbGlkYXRlJyxcbiAgICAnb3BlbicsXG4gICAgJ3BsYXlzaW5saW5lJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZXF1aXJlZCcsXG4gICAgJ3JldmVyc2VkJyxcbiAgICAnc2VsZWN0ZWQnXG5dKTtcblxuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzYCk7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBkZWJ1ZyhmaWxlLCBsaW5lLCBjb2x1bW4sIHZhbHVlcykge1xuICAgIGNvbnNvbGUubG9nKGB7QGRlYnVnfSAke2ZpbGUgPyBmaWxlICsgJyAnIDogJyd9KCR7bGluZX06JHtjb2x1bW59KWApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLmxvZyh2YWx1ZXMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICByZXR1cm4gJyc7XG59XG5sZXQgb25fZGVzdHJveTtcbmZ1bmN0aW9uIGNyZWF0ZV9zc3JfY29tcG9uZW50KGZuKSB7XG4gICAgZnVuY3Rpb24gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHBhcmVudF9jb21wb25lbnQgPSBjdXJyZW50X2NvbXBvbmVudDtcbiAgICAgICAgY29uc3QgJCQgPSB7XG4gICAgICAgICAgICBvbl9kZXN0cm95LFxuICAgICAgICAgICAgY29udGV4dDogbmV3IE1hcChjb250ZXh0IHx8IChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogW10pKSxcbiAgICAgICAgICAgIC8vIHRoZXNlIHdpbGwgYmUgaW1tZWRpYXRlbHkgZGlzY2FyZGVkXG4gICAgICAgICAgICBvbl9tb3VudDogW10sXG4gICAgICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgICAgICAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpXG4gICAgICAgIH07XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudCh7ICQkIH0pO1xuICAgICAgICBjb25zdCBodG1sID0gZm4ocmVzdWx0LCBwcm9wcywgYmluZGluZ3MsIHNsb3RzKTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVuZGVyOiAocHJvcHMgPSB7fSwgeyAkJHNsb3RzID0ge30sIGNvbnRleHQgPSBuZXcgTWFwKCkgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgICBvbl9kZXN0cm95ID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7IHRpdGxlOiAnJywgaGVhZDogJycsIGNzczogbmV3IFNldCgpIH07XG4gICAgICAgICAgICBjb25zdCBodG1sID0gJCRyZW5kZXIocmVzdWx0LCBwcm9wcywge30sICQkc2xvdHMsIGNvbnRleHQpO1xuICAgICAgICAgICAgcnVuX2FsbChvbl9kZXN0cm95KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaHRtbCxcbiAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogQXJyYXkuZnJvbShyZXN1bHQuY3NzKS5tYXAoY3NzID0+IGNzcy5jb2RlKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgICAgICAgICAgbWFwOiBudWxsIC8vIFRPRE9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGhlYWQ6IHJlc3VsdC50aXRsZSArIHJlc3VsdC5oZWFkXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICAkJHJlbmRlclxuICAgIH07XG59XG5mdW5jdGlvbiBhZGRfYXR0cmlidXRlKG5hbWUsIHZhbHVlLCBib29sZWFuKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgKGJvb2xlYW4gJiYgIXZhbHVlKSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IGFzc2lnbm1lbnQgPSAoYm9vbGVhbiAmJiB2YWx1ZSA9PT0gdHJ1ZSkgPyAnJyA6IGA9XCIke2VzY2FwZSh2YWx1ZSwgdHJ1ZSl9XCJgO1xuICAgIHJldHVybiBgICR7bmFtZX0ke2Fzc2lnbm1lbnR9YDtcbn1cbmZ1bmN0aW9uIGFkZF9jbGFzc2VzKGNsYXNzZXMpIHtcbiAgICByZXR1cm4gY2xhc3NlcyA/IGAgY2xhc3M9XCIke2NsYXNzZXN9XCJgIDogJyc7XG59XG5mdW5jdGlvbiBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdHlsZV9vYmplY3QpXG4gICAgICAgIC5maWx0ZXIoa2V5ID0+IHN0eWxlX29iamVjdFtrZXldKVxuICAgICAgICAubWFwKGtleSA9PiBgJHtrZXl9OiAke3N0eWxlX29iamVjdFtrZXldfTtgKVxuICAgICAgICAuam9pbignICcpO1xufVxuZnVuY3Rpb24gYWRkX3N0eWxlcyhzdHlsZV9vYmplY3QpIHtcbiAgICBjb25zdCBzdHlsZXMgPSBzdHlsZV9vYmplY3RfdG9fc3RyaW5nKHN0eWxlX29iamVjdCk7XG4gICAgcmV0dXJuIHN0eWxlcyA/IGAgc3R5bGU9XCIke3N0eWxlc31cImAgOiAnJztcbn1cblxuZnVuY3Rpb24gYmluZChjb21wb25lbnQsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaW5kZXggPSBjb21wb25lbnQuJCQucHJvcHNbbmFtZV07XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LiQkLmJvdW5kW2luZGV4XSA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnQuJCQuY3R4W2luZGV4XSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICAgIGJsb2NrICYmIGJsb2NrLmMoKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2NvbXBvbmVudChibG9jaywgcGFyZW50X25vZGVzKSB7XG4gICAgYmxvY2sgJiYgYmxvY2subChwYXJlbnRfbm9kZXMpO1xufVxuZnVuY3Rpb24gbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgdGFyZ2V0LCBhbmNob3IsIGN1c3RvbUVsZW1lbnQpIHtcbiAgICBjb25zdCB7IGZyYWdtZW50LCBvbl9tb3VudCwgb25fZGVzdHJveSwgYWZ0ZXJfdXBkYXRlIH0gPSBjb21wb25lbnQuJCQ7XG4gICAgZnJhZ21lbnQgJiYgZnJhZ21lbnQubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgaWYgKCFjdXN0b21FbGVtZW50KSB7XG4gICAgICAgIC8vIG9uTW91bnQgaGFwcGVucyBiZWZvcmUgdGhlIGluaXRpYWwgYWZ0ZXJVcGRhdGVcbiAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdfb25fZGVzdHJveSA9IG9uX21vdW50Lm1hcChydW4pLmZpbHRlcihpc19mdW5jdGlvbik7XG4gICAgICAgICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICAgICAgICAgIG9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgcnVuX2FsbCgkJC5vbl9kZXN0cm95KTtcbiAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpO1xuICAgICAgICAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgICAgIC8vIHByZXNlcnZlIGZpbmFsIHN0YXRlPylcbiAgICAgICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgJCQuY3R4ID0gW107XG4gICAgfVxufVxuZnVuY3Rpb24gbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpIHtcbiAgICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgICAgICBkaXJ0eV9jb21wb25lbnRzLnB1c2goY29tcG9uZW50KTtcbiAgICAgICAgc2NoZWR1bGVfdXBkYXRlKCk7XG4gICAgICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICAgIH1cbiAgICBjb21wb25lbnQuJCQuZGlydHlbKGkgLyAzMSkgfCAwXSB8PSAoMSA8PCAoaSAlIDMxKSk7XG59XG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcywgYXBwZW5kX3N0eWxlcywgZGlydHkgPSBbLTFdKSB7XG4gICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgIGNvbnN0ICQkID0gY29tcG9uZW50LiQkID0ge1xuICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgY3R4OiBudWxsLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gfHwgKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdID0gW10pKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMuIFVzZWQgd2hlbiBkZXY9ZmFsc2UuXG4gKi9cbmNsYXNzIFN2ZWx0ZUNvbXBvbmVudCB7XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSB8fCAodGhpcy4kJC5jYWxsYmFja3NbdHlwZV0gPSBbXSkpO1xuICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgICRzZXQoJCRwcm9wcykge1xuICAgICAgICBpZiAodGhpcy4kJHNldCAmJiAhaXNfZW1wdHkoJCRwcm9wcykpIHtcbiAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLiQkc2V0KCQkcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoX2Rldih0eXBlLCBkZXRhaWwpIHtcbiAgICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudCh0eXBlLCBPYmplY3QuYXNzaWduKHsgdmVyc2lvbjogJzMuNDkuMCcgfSwgZGV0YWlsKSwgeyBidWJibGVzOiB0cnVlIH0pKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmQodGFyZ2V0LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb25fZGV2KHRhcmdldCwgbm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUgfSk7XG4gICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpO1xufVxuZnVuY3Rpb24gaW5zZXJ0X2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlLCBhbmNob3IgfSk7XG4gICAgaW5zZXJ0X2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBkZXRhY2hfZGV2KG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZScsIHsgbm9kZSB9KTtcbiAgICBkZXRhY2gobm9kZSk7XG59XG5mdW5jdGlvbiBkZXRhY2hfYmV0d2Vlbl9kZXYoYmVmb3JlLCBhZnRlcikge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcgJiYgYmVmb3JlLm5leHRTaWJsaW5nICE9PSBhZnRlcikge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZGV0YWNoX2JlZm9yZV9kZXYoYWZ0ZXIpIHtcbiAgICB3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYWZ0ZXJfZGV2KGJlZm9yZSkge1xuICAgIHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihiZWZvcmUubmV4dFNpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxpc3Rlbl9kZXYobm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMsIGhhc19wcmV2ZW50X2RlZmF1bHQsIGhhc19zdG9wX3Byb3BhZ2F0aW9uKSB7XG4gICAgY29uc3QgbW9kaWZpZXJzID0gb3B0aW9ucyA9PT0gdHJ1ZSA/IFsnY2FwdHVyZSddIDogb3B0aW9ucyA/IEFycmF5LmZyb20oT2JqZWN0LmtleXMob3B0aW9ucykpIDogW107XG4gICAgaWYgKGhhc19wcmV2ZW50X2RlZmF1bHQpXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdwcmV2ZW50RGVmYXVsdCcpO1xuICAgIGlmIChoYXNfc3RvcF9wcm9wYWdhdGlvbilcbiAgICAgICAgbW9kaWZpZXJzLnB1c2goJ3N0b3BQcm9wYWdhdGlvbicpO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NQWRkRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICBjb25zdCBkaXNwb3NlID0gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVJlbW92ZUV2ZW50TGlzdGVuZXInLCB7IG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBtb2RpZmllcnMgfSk7XG4gICAgICAgIGRpc3Bvc2UoKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYXR0cl9kZXYobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlQXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUgfSk7XG4gICAgZWxzZVxuICAgICAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldEF0dHJpYnV0ZScsIHsgbm9kZSwgYXR0cmlidXRlLCB2YWx1ZSB9KTtcbn1cbmZ1bmN0aW9uIHByb3BfZGV2KG5vZGUsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIG5vZGVbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXRQcm9wZXJ0eScsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gZGF0YXNldF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZS5kYXRhc2V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YXNldCcsIHsgbm9kZSwgcHJvcGVydHksIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpIHtcbiAgICBkYXRhID0gJycgKyBkYXRhO1xuICAgIGlmICh0ZXh0Lndob2xlVGV4dCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVfZWFjaF9hcmd1bWVudChhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ3N0cmluZycgJiYgIShhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgJ2xlbmd0aCcgaW4gYXJnKSkge1xuICAgICAgICBsZXQgbXNnID0gJ3sjZWFjaH0gb25seSBpdGVyYXRlcyBvdmVyIGFycmF5LWxpa2Ugb2JqZWN0cy4nO1xuICAgICAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBhcmcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIGFyZykge1xuICAgICAgICAgICAgbXNnICs9ICcgWW91IGNhbiB1c2UgYSBzcHJlYWQgdG8gY29udmVydCB0aGlzIGl0ZXJhYmxlIGludG8gYW4gYXJyYXkuJztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9zbG90cyhuYW1lLCBzbG90LCBrZXlzKSB7XG4gICAgZm9yIChjb25zdCBzbG90X2tleSBvZiBPYmplY3Qua2V5cyhzbG90KSkge1xuICAgICAgICBpZiAoIX5rZXlzLmluZGV4T2Yoc2xvdF9rZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYDwke25hbWV9PiByZWNlaXZlZCBhbiB1bmV4cGVjdGVkIHNsb3QgXCIke3Nsb3Rfa2V5fVwiLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGNvbnN0IGlzX3N0cmluZyA9IHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnO1xuICAgIGlmICh0YWcgJiYgIWlzX3N0cmluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxzdmVsdGU6ZWxlbWVudD4gZXhwZWN0cyBcInRoaXNcIiBhdHRyaWJ1dGUgdG8gYmUgYSBzdHJpbmcuJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQodGFnKSB7XG4gICAgaWYgKHRhZyAmJiBpc192b2lkKHRhZykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGA8c3ZlbHRlOmVsZW1lbnQgdGhpcz1cIiR7dGFnfVwiPiBpcyBzZWxmLWNsb3NpbmcgYW5kIGNhbm5vdCBoYXZlIGNvbnRlbnQuYCk7XG4gICAgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBTdmVsdGUgY29tcG9uZW50cyB3aXRoIHNvbWUgbWlub3IgZGV2LWVuaGFuY2VtZW50cy4gVXNlZCB3aGVuIGRldj10cnVlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnREZXYgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMuJCRpbmxpbmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIndGFyZ2V0JyBpcyBhIHJlcXVpcmVkIG9wdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigpO1xuICAgIH1cbiAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ29tcG9uZW50IHdhcyBhbHJlYWR5IGRlc3Ryb3llZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJGNhcHR1cmVfc3RhdGUoKSB7IH1cbiAgICAkaW5qZWN0X3N0YXRlKCkgeyB9XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIHN0cm9uZ2x5IHR5cGVkIFN2ZWx0ZSBjb21wb25lbnRzLlxuICogVGhpcyBvbmx5IGV4aXN0cyBmb3IgdHlwaW5nIHB1cnBvc2VzIGFuZCBzaG91bGQgYmUgdXNlZCBpbiBgLmQudHNgIGZpbGVzLlxuICpcbiAqICMjIyBFeGFtcGxlOlxuICpcbiAqIFlvdSBoYXZlIGNvbXBvbmVudCBsaWJyYXJ5IG9uIG5wbSBjYWxsZWQgYGNvbXBvbmVudC1saWJyYXJ5YCwgZnJvbSB3aGljaFxuICogeW91IGV4cG9ydCBhIGNvbXBvbmVudCBjYWxsZWQgYE15Q29tcG9uZW50YC4gRm9yIFN2ZWx0ZStUeXBlU2NyaXB0IHVzZXJzLFxuICogeW91IHdhbnQgdG8gcHJvdmlkZSB0eXBpbmdzLiBUaGVyZWZvcmUgeW91IGNyZWF0ZSBhIGBpbmRleC5kLnRzYDpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBTdmVsdGVDb21wb25lbnRUeXBlZCB9IGZyb20gXCJzdmVsdGVcIjtcbiAqIGV4cG9ydCBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudFR5cGVkPHtmb286IHN0cmluZ30+IHt9XG4gKiBgYGBcbiAqIFR5cGluZyB0aGlzIG1ha2VzIGl0IHBvc3NpYmxlIGZvciBJREVzIGxpa2UgVlMgQ29kZSB3aXRoIHRoZSBTdmVsdGUgZXh0ZW5zaW9uXG4gKiB0byBwcm92aWRlIGludGVsbGlzZW5zZSBhbmQgdG8gdXNlIHRoZSBjb21wb25lbnQgbGlrZSB0aGlzIGluIGEgU3ZlbHRlIGZpbGVcbiAqIHdpdGggVHlwZVNjcmlwdDpcbiAqIGBgYHN2ZWx0ZVxuICogPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAqIFx0aW1wb3J0IHsgTXlDb21wb25lbnQgfSBmcm9tIFwiY29tcG9uZW50LWxpYnJhcnlcIjtcbiAqIDwvc2NyaXB0PlxuICogPE15Q29tcG9uZW50IGZvbz17J2Jhcid9IC8+XG4gKiBgYGBcbiAqXG4gKiAjIyMjIFdoeSBub3QgbWFrZSB0aGlzIHBhcnQgb2YgYFN2ZWx0ZUNvbXBvbmVudChEZXYpYD9cbiAqIEJlY2F1c2VcbiAqIGBgYHRzXG4gKiBjbGFzcyBBU3ViY2xhc3NPZlN2ZWx0ZUNvbXBvbmVudCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogY29uc3QgY29tcG9uZW50OiB0eXBlb2YgU3ZlbHRlQ29tcG9uZW50ID0gQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQ7XG4gKiBgYGBcbiAqIHdpbGwgdGhyb3cgYSB0eXBlIGVycm9yLCBzbyB3ZSBuZWVkIHRvIHNlcGFyYXRlIHRoZSBtb3JlIHN0cmljdGx5IHR5cGVkIGNsYXNzLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnRUeXBlZCBleHRlbmRzIFN2ZWx0ZUNvbXBvbmVudERldiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiBsb29wX2d1YXJkKHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgSHRtbFRhZywgSHRtbFRhZ0h5ZHJhdGlvbiwgU3ZlbHRlQ29tcG9uZW50LCBTdmVsdGVDb21wb25lbnREZXYsIFN2ZWx0ZUNvbXBvbmVudFR5cGVkLCBTdmVsdGVFbGVtZW50LCBhY3Rpb25fZGVzdHJveWVyLCBhZGRfYXR0cmlidXRlLCBhZGRfY2xhc3NlcywgYWRkX2ZsdXNoX2NhbGxiYWNrLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9yZXNpemVfbGlzdGVuZXIsIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY3JlYXRlRXZlbnREaXNwYXRjaGVyLCBjcmVhdGVfYW5pbWF0aW9uLCBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uLCBjcmVhdGVfY29tcG9uZW50LCBjcmVhdGVfaW5fdHJhbnNpdGlvbiwgY3JlYXRlX291dF90cmFuc2l0aW9uLCBjcmVhdGVfc2xvdCwgY3JlYXRlX3Nzcl9jb21wb25lbnQsIGN1cnJlbnRfY29tcG9uZW50LCBjdXN0b21fZXZlbnQsIGRhdGFzZXRfZGV2LCBkZWJ1ZywgZGVzdHJveV9ibG9jaywgZGVzdHJveV9jb21wb25lbnQsIGRlc3Ryb3lfZWFjaCwgZGV0YWNoLCBkZXRhY2hfYWZ0ZXJfZGV2LCBkZXRhY2hfYmVmb3JlX2RldiwgZGV0YWNoX2JldHdlZW5fZGV2LCBkZXRhY2hfZGV2LCBkaXJ0eV9jb21wb25lbnRzLCBkaXNwYXRjaF9kZXYsIGVhY2gsIGVsZW1lbnQsIGVsZW1lbnRfaXMsIGVtcHR5LCBlbmRfaHlkcmF0aW5nLCBlc2NhcGUsIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUsIGVzY2FwZV9vYmplY3QsIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMsIGZpeF9hbmRfZGVzdHJveV9ibG9jaywgZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jaywgZml4X3Bvc2l0aW9uLCBmbHVzaCwgZ2V0QWxsQ29udGV4dHMsIGdldENvbnRleHQsIGdldF9hbGxfZGlydHlfZnJvbV9zY29wZSwgZ2V0X2JpbmRpbmdfZ3JvdXBfdmFsdWUsIGdldF9jdXJyZW50X2NvbXBvbmVudCwgZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cywgZ2V0X3Jvb3RfZm9yX3N0eWxlLCBnZXRfc2xvdF9jaGFuZ2VzLCBnZXRfc3ByZWFkX29iamVjdCwgZ2V0X3NwcmVhZF91cGRhdGUsIGdldF9zdG9yZV92YWx1ZSwgZ2xvYmFscywgZ3JvdXBfb3V0cm9zLCBoYW5kbGVfcHJvbWlzZSwgaGFzQ29udGV4dCwgaGFzX3Byb3AsIGlkZW50aXR5LCBpbml0LCBpbnNlcnQsIGluc2VydF9kZXYsIGluc2VydF9oeWRyYXRpb24sIGluc2VydF9oeWRyYXRpb25fZGV2LCBpbnRyb3MsIGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLCBpc19jbGllbnQsIGlzX2Nyb3Nzb3JpZ2luLCBpc19lbXB0eSwgaXNfZnVuY3Rpb24sIGlzX3Byb21pc2UsIGlzX3ZvaWQsIGxpc3RlbiwgbGlzdGVuX2RldiwgbG9vcCwgbG9vcF9ndWFyZCwgbWVyZ2Vfc3NyX3N0eWxlcywgbWlzc2luZ19jb21wb25lbnQsIG1vdW50X2NvbXBvbmVudCwgbm9vcCwgbm90X2VxdWFsLCBub3csIG51bGxfdG9fZW1wdHksIG9iamVjdF93aXRob3V0X3Byb3BlcnRpZXMsIG9uRGVzdHJveSwgb25Nb3VudCwgb25jZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIHByZXZlbnRfZGVmYXVsdCwgcHJvcF9kZXYsIHF1ZXJ5X3NlbGVjdG9yX2FsbCwgcmFmLCBydW4sIHJ1bl9hbGwsIHNhZmVfbm90X2VxdWFsLCBzY2hlZHVsZV91cGRhdGUsIHNlbGVjdF9tdWx0aXBsZV92YWx1ZSwgc2VsZWN0X29wdGlvbiwgc2VsZWN0X29wdGlvbnMsIHNlbGVjdF92YWx1ZSwgc2VsZiwgc2V0Q29udGV4dCwgc2V0X2F0dHJpYnV0ZXMsIHNldF9jdXJyZW50X2NvbXBvbmVudCwgc2V0X2N1c3RvbV9lbGVtZW50X2RhdGEsIHNldF9kYXRhLCBzZXRfZGF0YV9kZXYsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcHJlYWQsIHNyY191cmxfZXF1YWwsIHN0YXJ0X2h5ZHJhdGluZywgc3RvcF9wcm9wYWdhdGlvbiwgc3Vic2NyaWJlLCBzdmdfZWxlbWVudCwgdGV4dCwgdGljaywgdGltZV9yYW5nZXNfdG9fYXJyYXksIHRvX251bWJlciwgdG9nZ2xlX2NsYXNzLCB0cmFuc2l0aW9uX2luLCB0cmFuc2l0aW9uX291dCwgdHJ1c3RlZCwgdXBkYXRlX2F3YWl0X2Jsb2NrX2JyYW5jaCwgdXBkYXRlX2tleWVkX2VhY2gsIHVwZGF0ZV9zbG90LCB1cGRhdGVfc2xvdF9iYXNlLCB2YWxpZGF0ZV9jb21wb25lbnQsIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCwgdmFsaWRhdGVfZWFjaF9hcmd1bWVudCwgdmFsaWRhdGVfZWFjaF9rZXlzLCB2YWxpZGF0ZV9zbG90cywgdmFsaWRhdGVfc3RvcmUsIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50LCB4bGlua19hdHRyIH07XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjayc7XG5cbiAgZXhwb3J0IGxldCBjb25maWcsIHN0ZXA7XG4gIGxldCBhY3Rpb24sIGNsYXNzZXMsIGRpc2FibGVkLCBsYWJlbCwgc2Vjb25kYXJ5LCB0ZXh0O1xuXG4gICQ6IHtcbiAgICBhY3Rpb24gPSBjb25maWcuYWN0aW9uID8gY29uZmlnLmFjdGlvbi5iaW5kKHN0ZXAudG91cikgOiBudWxsO1xuICAgIGNsYXNzZXMgPSBjb25maWcuY2xhc3NlcztcbiAgICBkaXNhYmxlZCA9IGNvbmZpZy5kaXNhYmxlZCA/IGdldENvbmZpZ09wdGlvbihjb25maWcuZGlzYWJsZWQpIDogZmFsc2U7XG4gICAgbGFiZWwgPSBjb25maWcubGFiZWwgPyBnZXRDb25maWdPcHRpb24oY29uZmlnLmxhYmVsKSA6IG51bGw7XG4gICAgc2Vjb25kYXJ5ID0gY29uZmlnLnNlY29uZGFyeTtcbiAgICB0ZXh0ID0gY29uZmlnLnRleHQgPyBnZXRDb25maWdPcHRpb24oY29uZmlnLnRleHQpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbmZpZ09wdGlvbihvcHRpb24pIHtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb24pKSB7XG4gICAgICByZXR1cm4gb3B0aW9uID0gb3B0aW9uLmNhbGwoc3RlcCk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb247XG4gIH1cblxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBnbG9iYWw+XG4gIC5zaGVwaGVyZC1idXR0b24ge1xuICAgIGJhY2tncm91bmQ6IHJnYig1MCwgMTM2LCAyMzApO1xuICAgIGJvcmRlcjogMDtcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSk7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuICAgIG1hcmdpbi1yaWdodDogMC41cmVtO1xuICAgIHBhZGRpbmc6IDAuNXJlbSAxLjVyZW07XG4gICAgdHJhbnNpdGlvbjogYWxsIDAuNXMgZWFzZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b246bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYigyNSwgMTExLCAyMDQpO1xuICAgIGNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWJ1dHRvbi5zaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5IHtcbiAgICBiYWNrZ3JvdW5kOiByZ2IoMjQxLCAyNDIsIDI0Myk7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gIH1cblxuICAuc2hlcGhlcmQtYnV0dG9uLnNoZXBoZXJkLWJ1dHRvbi1zZWNvbmRhcnk6bm90KDpkaXNhYmxlZCk6aG92ZXIge1xuICAgIGJhY2tncm91bmQ6IHJnYigyMTQsIDIxNywgMjE5KTtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1idXR0b246ZGlzYWJsZWQge1xuICAgIGN1cnNvcjogbm90LWFsbG93ZWQ7XG4gIH1cbjwvc3R5bGU+XG5cbjxidXR0b25cbiAgYXJpYS1sYWJlbD1cIntsYWJlbCA/IGxhYmVsIDogbnVsbH1cIlxuICBjbGFzcz1cIntgJHsoY2xhc3NlcyB8fCAnJyl9IHNoZXBoZXJkLWJ1dHRvbiAkeyhzZWNvbmRhcnkgPyAnc2hlcGhlcmQtYnV0dG9uLXNlY29uZGFyeScgOiAnJyl9YH1cIlxuICBkaXNhYmxlZD17ZGlzYWJsZWR9XG4gIG9uOmNsaWNrPXthY3Rpb259XG4gIHRhYmluZGV4PVwiMFwiXG4+XG4gICAge0BodG1sIHRleHR9XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZEJ1dHRvbiBmcm9tICcuL3NoZXBoZXJkLWJ1dHRvbi5zdmVsdGUnO1xuXG4gIGV4cG9ydCBsZXQgc3RlcDtcblxuICAkOiBidXR0b25zID0gc3RlcC5vcHRpb25zLmJ1dHRvbnM7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWZvb3RlciB7XG4gICAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogNXB4O1xuICAgIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA1cHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgIHBhZGRpbmc6IDAgMC43NXJlbSAwLjc1cmVtO1xuICB9XG5cbiAgLnNoZXBoZXJkLWZvb3RlciAuc2hlcGhlcmQtYnV0dG9uOmxhc3QtY2hpbGQge1xuICAgIG1hcmdpbi1yaWdodDogMDtcbiAgfVxuPC9zdHlsZT5cblxuPGZvb3RlciBjbGFzcz1cInNoZXBoZXJkLWZvb3RlclwiPlxuICAgIHsjaWYgYnV0dG9uc31cbiAgICAgICAgeyNlYWNoIGJ1dHRvbnMgYXMgY29uZmlnfVxuICAgICAgICAgIDxTaGVwaGVyZEJ1dHRvblxuICAgICAgICAgICAge2NvbmZpZ31cbiAgICAgICAgICAgIHtzdGVwfVxuICAgICAgICAgIC8+XG4gICAgICAgIHsvZWFjaH1cbiAgICB7L2lmfVxuPC9mb290ZXI+XG4iLCI8c2NyaXB0PlxuICBleHBvcnQgbGV0IGNhbmNlbEljb24sIHN0ZXA7XG5cbiAgLyoqXG4gICAqIEFkZCBhIGNsaWNrIGxpc3RlbmVyIHRvIHRoZSBjYW5jZWwgbGluayB0aGF0IGNhbmNlbHMgdGhlIHRvdXJcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNhbmNlbENsaWNrID0gKGUpID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgc3RlcC5jYW5jZWwoKTtcbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtY2FuY2VsLWljb24ge1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBjb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjc1KTtcbiAgICBmb250LXNpemU6IDJlbTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgZm9udC13ZWlnaHQ6IG5vcm1hbDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogMDtcbiAgICB0cmFuc2l0aW9uOiBjb2xvciAwLjVzIGVhc2U7XG4gIH1cblxuICAuc2hlcGhlcmQtY2FuY2VsLWljb246aG92ZXIge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtY2FuY2VsLWljb24ge1xuICAgIGNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuNzUpO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtY2FuY2VsLWljb246aG92ZXIge1xuICAgIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNzUpO1xuICB9XG48L3N0eWxlPlxuXG48YnV0dG9uXG4gIGFyaWEtbGFiZWw9XCJ7Y2FuY2VsSWNvbi5sYWJlbCA/IGNhbmNlbEljb24ubGFiZWwgOiAnQ2xvc2UgVG91cid9XCJcbiAgY2xhc3M9XCJzaGVwaGVyZC1jYW5jZWwtaWNvblwiXG4gIG9uOmNsaWNrPXtoYW5kbGVDYW5jZWxDbGlja31cbiAgdHlwZT1cImJ1dHRvblwiXG4+XG4gIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG48L2J1dHRvbj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWxzL3R5cGUtY2hlY2snO1xuICBcbiAgZXhwb3J0IGxldCBsYWJlbElkLCBlbGVtZW50LCB0aXRsZTtcbiAgXG4gIGFmdGVyVXBkYXRlKCgpID0+IHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aXRsZSkpIHtcbiAgICAgIHRpdGxlID0gdGl0bGUoKTtcbiAgICB9XG4gICAgXG4gICAgZWxlbWVudC5pbm5lckhUTUwgPSB0aXRsZTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLXRpdGxlIHtcbiAgICBjb2xvcjogcmdiYSgwLCAwLCAwLCAwLjc1KTtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZvbnQtc2l6ZTogMXJlbTtcbiAgICBmb250LXdlaWdodDogbm9ybWFsO1xuICAgIGZsZXg6IDEgMCBhdXRvO1xuICAgIG1hcmdpbjogMDtcbiAgICBwYWRkaW5nOiAwO1xuICB9XG48L3N0eWxlPlxuXG48aDNcbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBpZD1cIntsYWJlbElkfVwiXG4gIGNsYXNzPVwic2hlcGhlcmQtdGl0bGVcIlxuPlxuPC9oMz5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZENhbmNlbEljb24gZnJvbSAnLi9zaGVwaGVyZC1jYW5jZWwtaWNvbi5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRUaXRsZSBmcm9tICcuL3NoZXBoZXJkLXRpdGxlLnN2ZWx0ZSc7XG5cbiAgZXhwb3J0IGxldCBsYWJlbElkLCBzdGVwO1xuICBsZXQgdGl0bGUsIGNhbmNlbEljb247XG5cbiAgJDoge1xuICAgICAgdGl0bGUgPSBzdGVwLm9wdGlvbnMudGl0bGU7XG4gICAgICBjYW5jZWxJY29uID0gc3RlcC5vcHRpb25zLmNhbmNlbEljb247XG4gIH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtaGVhZGVyIHtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDVweDtcbiAgICBib3JkZXItdG9wLXJpZ2h0LXJhZGl1czogNXB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICBsaW5lLWhlaWdodDogMmVtO1xuICAgIHBhZGRpbmc6IDAuNzVyZW0gMC43NXJlbSAwO1xuICB9XG5cbiAgLnNoZXBoZXJkLWhhcy10aXRsZSAuc2hlcGhlcmQtY29udGVudCAuc2hlcGhlcmQtaGVhZGVyIHtcbiAgICBiYWNrZ3JvdW5kOiAjZTZlNmU2O1xuICAgIHBhZGRpbmc6IDFlbTtcbiAgfVxuPC9zdHlsZT5cblxuPGhlYWRlciBjbGFzcz1cInNoZXBoZXJkLWhlYWRlclwiPlxuICAgIHsjaWYgdGl0bGV9XG4gICAgICA8U2hlcGhlcmRUaXRsZVxuICAgICAgICB7bGFiZWxJZH1cbiAgICAgICAge3RpdGxlfVxuICAgICAgLz5cbiAgICB7L2lmfVxuXG4gICAgeyNpZiBjYW5jZWxJY29uICYmIGNhbmNlbEljb24uZW5hYmxlZH1cbiAgICAgIDxTaGVwaGVyZENhbmNlbEljb25cbiAgICAgICAge2NhbmNlbEljb259XG4gICAgICAgIHtzdGVwfVxuICAgICAgLz5cbiAgICB7L2lmfVxuPC9oZWFkZXI+XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyBhZnRlclVwZGF0ZSB9IGZyb20gJ3N2ZWx0ZSc7XG4gIGltcG9ydCB7IGlzSFRNTEVsZW1lbnQsIGlzRnVuY3Rpb24gfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrJztcblxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uSWQsIGVsZW1lbnQsIHN0ZXA7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGxldCB7IHRleHQgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRleHQpKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5jYWxsKHN0ZXApO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRleHQpKSB7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LmlubmVySFRNTCA9IHRleHQ7XG4gICAgfVxuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtdGV4dCB7XG4gICAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC43NSk7XG4gICAgZm9udC1zaXplOiAxcmVtO1xuICAgIGxpbmUtaGVpZ2h0OiAxLjNlbTtcbiAgICBwYWRkaW5nOiAwLjc1ZW07XG4gIH1cblxuICAuc2hlcGhlcmQtdGV4dCBwIHtcbiAgICBtYXJnaW4tdG9wOiAwO1xuICB9XG5cbiAgLnNoZXBoZXJkLXRleHQgcDpsYXN0LWNoaWxkIHtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9XCJzaGVwaGVyZC10ZXh0XCJcbiAgaWQ9XCJ7ZGVzY3JpcHRpb25JZH1cIlxuPlxuPC9kaXY+XG5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCBTaGVwaGVyZEZvb3RlciBmcm9tICcuL3NoZXBoZXJkLWZvb3Rlci5zdmVsdGUnO1xuICBpbXBvcnQgU2hlcGhlcmRIZWFkZXIgZnJvbSAnLi9zaGVwaGVyZC1oZWFkZXIuc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkVGV4dCBmcm9tICcuL3NoZXBoZXJkLXRleHQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNVbmRlZmluZWQgfSBmcm9tICcuLi91dGlscy90eXBlLWNoZWNrLmpzJztcblxuICBleHBvcnQgbGV0IGRlc2NyaXB0aW9uSWQsIGxhYmVsSWQsIHN0ZXA7XG48L3NjcmlwdD5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLWNvbnRlbnQge1xuICAgIGJvcmRlci1yYWRpdXM6IDVweDtcbiAgICBvdXRsaW5lOiBub25lO1xuICAgIHBhZGRpbmc6IDA7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXZcbiAgY2xhc3M9XCJzaGVwaGVyZC1jb250ZW50XCJcbj5cbiAgeyNpZiAhaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRpdGxlKSB8fCAoc3RlcC5vcHRpb25zLmNhbmNlbEljb24gJiYgc3RlcC5vcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZCl9XG4gICAgPFNoZXBoZXJkSGVhZGVyXG4gICAgICB7bGFiZWxJZH1cbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG5cbiAgeyNpZiAhaXNVbmRlZmluZWQoc3RlcC5vcHRpb25zLnRleHQpfVxuICAgIDxTaGVwaGVyZFRleHRcbiAgICAgIHtkZXNjcmlwdGlvbklkfVxuICAgICAge3N0ZXB9XG4gICAgLz5cbiAgey9pZn1cblxuICB7I2lmIEFycmF5LmlzQXJyYXkoc3RlcC5vcHRpb25zLmJ1dHRvbnMpICYmIHN0ZXAub3B0aW9ucy5idXR0b25zLmxlbmd0aH1cbiAgICA8U2hlcGhlcmRGb290ZXJcbiAgICAgIHtzdGVwfVxuICAgIC8+XG4gIHsvaWZ9XG48L2Rpdj5cbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IG9uTW91bnQsIGFmdGVyVXBkYXRlIH0gZnJvbSAnc3ZlbHRlJztcbiAgaW1wb3J0IFNoZXBoZXJkQ29udGVudCBmcm9tICcuL3NoZXBoZXJkLWNvbnRlbnQuc3ZlbHRlJztcbiAgaW1wb3J0IHsgaXNVbmRlZmluZWQsIGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMvdHlwZS1jaGVjay5qcyc7XG5cbiAgY29uc3QgS0VZX1RBQiA9IDk7XG4gIGNvbnN0IEtFWV9FU0MgPSAyNztcbiAgY29uc3QgTEVGVF9BUlJPVyA9IDM3O1xuICBjb25zdCBSSUdIVF9BUlJPVyA9IDM5O1xuXG4gIGV4cG9ydCBsZXQgY2xhc3NQcmVmaXgsIGVsZW1lbnQsIGRlc2NyaXB0aW9uSWQsIGZpcnN0Rm9jdXNhYmxlRWxlbWVudCxcbiAgICBmb2N1c2FibGVFbGVtZW50cywgbGFiZWxJZCwgbGFzdEZvY3VzYWJsZUVsZW1lbnQsIHN0ZXAsIGRhdGFTdGVwSWQ7XG5cbiAgbGV0IGhhc0NhbmNlbEljb24sIGhhc1RpdGxlLCBjbGFzc2VzO1xuXG4gICQ6IHtcbiAgICBoYXNDYW5jZWxJY29uID0gc3RlcC5vcHRpb25zICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uICYmIHN0ZXAub3B0aW9ucy5jYW5jZWxJY29uLmVuYWJsZWQ7XG4gICAgaGFzVGl0bGUgPSBzdGVwLm9wdGlvbnMgJiYgc3RlcC5vcHRpb25zLnRpdGxlO1xuICB9XG5cbiAgZXhwb3J0IGNvbnN0IGdldEVsZW1lbnQgPSAoKSA9PiBlbGVtZW50O1xuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIC8vIEdldCBhbGwgZWxlbWVudHMgdGhhdCBhcmUgZm9jdXNhYmxlXG4gICAgZGF0YVN0ZXBJZCA9IHsgW2BkYXRhLSR7Y2xhc3NQcmVmaXh9c2hlcGhlcmQtc3RlcC1pZGBdOiBzdGVwLmlkIH07XG4gICAgZm9jdXNhYmxlRWxlbWVudHMgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKSwgc2VsZWN0Om5vdChbZGlzYWJsZWRdKSwgdGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pLCBidXR0b246bm90KFtkaXNhYmxlZF0pLCBbdGFiaW5kZXg9XCIwXCJdJyk7XG4gICAgZmlyc3RGb2N1c2FibGVFbGVtZW50ID0gZm9jdXNhYmxlRWxlbWVudHNbMF07XG4gICAgbGFzdEZvY3VzYWJsZUVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgfSk7XG5cbiAgYWZ0ZXJVcGRhdGUoKCkgPT4ge1xuICAgIGlmKGNsYXNzZXMgIT09IHN0ZXAub3B0aW9ucy5jbGFzc2VzKSB7XG4gICAgICB1cGRhdGVEeW5hbWljQ2xhc3NlcygpO1xuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gdXBkYXRlRHluYW1pY0NsYXNzZXMoKSB7XG4gICAgICByZW1vdmVDbGFzc2VzKGNsYXNzZXMpO1xuICAgICAgY2xhc3NlcyA9IHN0ZXAub3B0aW9ucy5jbGFzc2VzO1xuICAgICAgYWRkQ2xhc3NlcyhjbGFzc2VzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNsYXNzZXMoY2xhc3Nlcykge1xuICAgIGlmIChpc1N0cmluZyhjbGFzc2VzKSkge1xuICAgICAgY29uc3Qgb2xkQ2xhc3NlcyA9IGdldENsYXNzZXNBcnJheShjbGFzc2VzKTtcbiAgICAgIGlmIChvbGRDbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoLi4ub2xkQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgaWYoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNvbnN0IG5ld0NsYXNzZXMgPSBnZXRDbGFzc2VzQXJyYXkoY2xhc3Nlcyk7XG4gICAgICBpZiAobmV3Q2xhc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLm5ld0NsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsYXNzZXNBcnJheShjbGFzc2VzKSB7XG4gICAgIHJldHVybiBjbGFzc2VzLnNwbGl0KCcgJykuZmlsdGVyKGNsYXNzTmFtZSA9PiAhIWNsYXNzTmFtZS5sZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHVwIGtleWRvd24gZXZlbnRzIHRvIGFsbG93IGNsb3NpbmcgdGhlIG1vZGFsIHdpdGggRVNDXG4gICAqXG4gICAqIEJvcnJvd2VkIGZyb20gdGhpcyBncmVhdCBwb3N0ISBodHRwczovL2JpdHNvZmNvLmRlL2FjY2Vzc2libGUtbW9kYWwtZGlhbG9nL1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3QgaGFuZGxlS2V5RG93biA9IChlKSA9PiB7XG4gICAgY29uc3QgeyB0b3VyIH0gPSBzdGVwO1xuICAgIHN3aXRjaCAoZS5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEtFWV9UQUI6XG4gICAgICAgIGlmIChmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmFja3dhcmQgdGFiXG4gICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGZpcnN0Rm9jdXNhYmxlRWxlbWVudCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnc2hlcGhlcmQtZWxlbWVudCcpKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBsYXN0Rm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gbGFzdEZvY3VzYWJsZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGZpcnN0Rm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS0VZX0VTQzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5leGl0T25Fc2MpIHtcbiAgICAgICAgICBzdGVwLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBMRUZUX0FSUk9XOlxuICAgICAgICBpZiAodG91ci5vcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbikge1xuICAgICAgICAgIHRvdXIuYmFjaygpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSSUdIVF9BUlJPVzpcbiAgICAgICAgaWYgKHRvdXIub3B0aW9ucy5rZXlib2FyZE5hdmlnYXRpb24pIHtcbiAgICAgICAgICB0b3VyLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbjwvc2NyaXB0PlxuXG48c3R5bGUgZ2xvYmFsPlxuICAuc2hlcGhlcmQtZWxlbWVudCB7XG4gICAgYmFja2dyb3VuZDogI2ZmZjtcbiAgICBib3JkZXItcmFkaXVzOiA1cHg7XG4gICAgYm94LXNoYWRvdzogMCAxcHggNHB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICBtYXgtd2lkdGg6IDQwMHB4O1xuICAgIG9wYWNpdHk6IDA7XG4gICAgb3V0bGluZTogbm9uZTtcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3MsIHZpc2liaWxpdHkgMC4zcztcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgei1pbmRleDogOTk5OTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbmFibGVkLnNoZXBoZXJkLWVsZW1lbnQge1xuICAgIG9wYWNpdHk6IDE7XG4gICAgdmlzaWJpbGl0eTogdmlzaWJsZTtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5dOm5vdCguc2hlcGhlcmQtY2VudGVyZWQpIHtcbiAgICBvcGFjaXR5OiAwO1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50LCAuc2hlcGhlcmQtZWxlbWVudCAqLFxuICAuc2hlcGhlcmQtZWxlbWVudCAqOmFmdGVyLFxuICAuc2hlcGhlcmQtZWxlbWVudCAqOmJlZm9yZSB7XG4gICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1hcnJvdyxcbiAgLnNoZXBoZXJkLWFycm93OjpiZWZvcmUge1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogMTZweDtcbiAgICBoZWlnaHQ6IDE2cHg7XG4gICAgei1pbmRleDogLTE7XG4gIH1cblxuICAuc2hlcGhlcmQtYXJyb3c6YmVmb3JlIHtcbiAgICBjb250ZW50OiAnJztcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSg0NWRlZyk7XG4gICAgYmFja2dyb3VuZDogI2ZmZiAgO1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0ndG9wJ10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIGJvdHRvbTogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50W2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2JvdHRvbSddID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICB0b3A6IC04cHg7XG4gIH1cblxuICAuc2hlcGhlcmQtZWxlbWVudFtkYXRhLXBvcHBlci1wbGFjZW1lbnRePSdsZWZ0J10gPiAuc2hlcGhlcmQtYXJyb3cge1xuICAgIHJpZ2h0OiAtOHB4O1xuICB9XG5cbiAgLnNoZXBoZXJkLWVsZW1lbnRbZGF0YS1wb3BwZXItcGxhY2VtZW50Xj0ncmlnaHQnXSA+IC5zaGVwaGVyZC1hcnJvdyB7XG4gICAgbGVmdDogLThweDtcbiAgfVxuXG4gIC5zaGVwaGVyZC1lbGVtZW50LnNoZXBoZXJkLWNlbnRlcmVkID4gLnNoZXBoZXJkLWFycm93IHtcbiAgICBvcGFjaXR5OiAwO1xuICB9XG5cblxuICAvKipcbiAgKiBBcnJvdyBvbiB0b3Agb2YgdG9vbHRpcCBjZW50ZXJlZCBob3Jpem9udGFsbHksIHdpdGggdGl0bGUgY29sb3JcbiAgKi9cbiAgLnNoZXBoZXJkLWVsZW1lbnQuc2hlcGhlcmQtaGFzLXRpdGxlW2RhdGEtcG9wcGVyLXBsYWNlbWVudF49J2JvdHRvbSddID4gLnNoZXBoZXJkLWFycm93OjpiZWZvcmUge1xuICAgIGJhY2tncm91bmQtY29sb3I6ICNlNmU2ZTY7XG4gIH1cblxuICAuc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtdGFyZ2V0LFxuICAuc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkLnNoZXBoZXJkLWVuYWJsZWQuc2hlcGhlcmQtdGFyZ2V0ICoge1xuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICB9XG48L3N0eWxlPlxuXG48ZGl2XG4gIGFyaWEtZGVzY3JpYmVkYnk9eyFpc1VuZGVmaW5lZChzdGVwLm9wdGlvbnMudGV4dCkgPyBkZXNjcmlwdGlvbklkIDogbnVsbH1cbiAgYXJpYS1sYWJlbGxlZGJ5PXtzdGVwLm9wdGlvbnMudGl0bGUgPyBsYWJlbElkIDogbnVsbH1cbiAgYmluZDp0aGlzPXtlbGVtZW50fVxuICBjbGFzczpzaGVwaGVyZC1oYXMtY2FuY2VsLWljb249XCJ7aGFzQ2FuY2VsSWNvbn1cIlxuICBjbGFzczpzaGVwaGVyZC1oYXMtdGl0bGU9XCJ7aGFzVGl0bGV9XCJcbiAgY2xhc3M6c2hlcGhlcmQtZWxlbWVudD1cInt0cnVlfVwiXG4gIHsuLi5kYXRhU3RlcElkfVxuICBvbjprZXlkb3duPXtoYW5kbGVLZXlEb3dufVxuICByb2xlPVwiZGlhbG9nXCJcbiAgdGFiaW5kZXg9XCIwXCJcbj5cbiAgICB7I2lmIHN0ZXAub3B0aW9ucy5hcnJvdyAmJiBzdGVwLm9wdGlvbnMuYXR0YWNoVG8gJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvLmVsZW1lbnQgJiYgc3RlcC5vcHRpb25zLmF0dGFjaFRvLm9ufVxuICAgICAgPGRpdiBjbGFzcz1cInNoZXBoZXJkLWFycm93XCIgZGF0YS1wb3BwZXItYXJyb3c+PC9kaXY+XG4gICAgey9pZn1cbiAgPFNoZXBoZXJkQ29udGVudFxuICAgIHtkZXNjcmlwdGlvbklkfVxuICAgIHtsYWJlbElkfVxuICAgIHtzdGVwfVxuICAvPlxuPC9kaXY+XG4iLCIvKiBzbW9vdGhzY3JvbGwgdjAuNC40IC0gMjAxOSAtIER1c3RhbiBLYXN0ZW4sIEplcmVtaWFzIE1lbmljaGVsbGkgLSBNSVQgTGljZW5zZSAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHBvbHlmaWxsXG4gIGZ1bmN0aW9uIHBvbHlmaWxsKCkge1xuICAgIC8vIGFsaWFzZXNcbiAgICB2YXIgdyA9IHdpbmRvdztcbiAgICB2YXIgZCA9IGRvY3VtZW50O1xuXG4gICAgLy8gcmV0dXJuIGlmIHNjcm9sbCBiZWhhdmlvciBpcyBzdXBwb3J0ZWQgYW5kIHBvbHlmaWxsIGlzIG5vdCBmb3JjZWRcbiAgICBpZiAoXG4gICAgICAnc2Nyb2xsQmVoYXZpb3InIGluIGQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmXG4gICAgICB3Ll9fZm9yY2VTbW9vdGhTY3JvbGxQb2x5ZmlsbF9fICE9PSB0cnVlXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2xvYmFsc1xuICAgIHZhciBFbGVtZW50ID0gdy5IVE1MRWxlbWVudCB8fCB3LkVsZW1lbnQ7XG4gICAgdmFyIFNDUk9MTF9USU1FID0gNDY4O1xuXG4gICAgLy8gb2JqZWN0IGdhdGhlcmluZyBvcmlnaW5hbCBzY3JvbGwgbWV0aG9kc1xuICAgIHZhciBvcmlnaW5hbCA9IHtcbiAgICAgIHNjcm9sbDogdy5zY3JvbGwgfHwgdy5zY3JvbGxUbyxcbiAgICAgIHNjcm9sbEJ5OiB3LnNjcm9sbEJ5LFxuICAgICAgZWxlbWVudFNjcm9sbDogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsIHx8IHNjcm9sbEVsZW1lbnQsXG4gICAgICBzY3JvbGxJbnRvVmlldzogRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICB9O1xuXG4gICAgLy8gZGVmaW5lIHRpbWluZyBtZXRob2RcbiAgICB2YXIgbm93ID1cbiAgICAgIHcucGVyZm9ybWFuY2UgJiYgdy5wZXJmb3JtYW5jZS5ub3dcbiAgICAgICAgPyB3LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHcucGVyZm9ybWFuY2UpXG4gICAgICAgIDogRGF0ZS5ub3c7XG5cbiAgICAvKipcbiAgICAgKiBpbmRpY2F0ZXMgaWYgYSB0aGUgY3VycmVudCBicm93c2VyIGlzIG1hZGUgYnkgTWljcm9zb2Z0XG4gICAgICogQG1ldGhvZCBpc01pY3Jvc29mdEJyb3dzZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXNlckFnZW50XG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNaWNyb3NvZnRCcm93c2VyKHVzZXJBZ2VudCkge1xuICAgICAgdmFyIHVzZXJBZ2VudFBhdHRlcm5zID0gWydNU0lFICcsICdUcmlkZW50LycsICdFZGdlLyddO1xuXG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1c2VyQWdlbnRQYXR0ZXJucy5qb2luKCd8JykpLnRlc3QodXNlckFnZW50KTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIElFIGhhcyByb3VuZGluZyBidWcgcm91bmRpbmcgZG93biBjbGllbnRIZWlnaHQgYW5kIGNsaWVudFdpZHRoIGFuZFxuICAgICAqIHJvdW5kaW5nIHVwIHNjcm9sbEhlaWdodCBhbmQgc2Nyb2xsV2lkdGggY2F1c2luZyBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgKiBvbiBoYXNTY3JvbGxhYmxlU3BhY2VcbiAgICAgKi9cbiAgICB2YXIgUk9VTkRJTkdfVE9MRVJBTkNFID0gaXNNaWNyb3NvZnRCcm93c2VyKHcubmF2aWdhdG9yLnVzZXJBZ2VudCkgPyAxIDogMDtcblxuICAgIC8qKlxuICAgICAqIGNoYW5nZXMgc2Nyb2xsIHBvc2l0aW9uIGluc2lkZSBhbiBlbGVtZW50XG4gICAgICogQG1ldGhvZCBzY3JvbGxFbGVtZW50XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2Nyb2xsRWxlbWVudCh4LCB5KSB7XG4gICAgICB0aGlzLnNjcm9sbExlZnQgPSB4O1xuICAgICAgdGhpcy5zY3JvbGxUb3AgPSB5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzdWx0IG9mIGFwcGx5aW5nIGVhc2UgbWF0aCBmdW5jdGlvbiB0byBhIG51bWJlclxuICAgICAqIEBtZXRob2QgZWFzZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBrXG4gICAgICogQHJldHVybnMge051bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlYXNlKGspIHtcbiAgICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGEgc21vb3RoIGJlaGF2aW9yIHNob3VsZCBiZSBhcHBsaWVkXG4gICAgICogQG1ldGhvZCBzaG91bGRCYWlsT3V0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBmaXJzdEFyZ1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNob3VsZEJhaWxPdXQoZmlyc3RBcmcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgZmlyc3RBcmcgPT09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIGZpcnN0QXJnICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICBmaXJzdEFyZy5iZWhhdmlvciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIGZpcnN0QXJnLmJlaGF2aW9yID09PSAnYXV0bycgfHxcbiAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdpbnN0YW50J1xuICAgICAgKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIG5vdCBhbiBvYmplY3QvbnVsbFxuICAgICAgICAvLyBvciBiZWhhdmlvciBpcyBhdXRvLCBpbnN0YW50IG9yIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyA9PT0gJ29iamVjdCcgJiYgZmlyc3RBcmcuYmVoYXZpb3IgPT09ICdzbW9vdGgnKSB7XG4gICAgICAgIC8vIGZpcnN0IGFyZ3VtZW50IGlzIGFuIG9iamVjdCBhbmQgYmVoYXZpb3IgaXMgc21vb3RoXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhyb3cgZXJyb3Igd2hlbiBiZWhhdmlvciBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnYmVoYXZpb3IgbWVtYmVyIG9mIFNjcm9sbE9wdGlvbnMgJyArXG4gICAgICAgICAgZmlyc3RBcmcuYmVoYXZpb3IgK1xuICAgICAgICAgICcgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGVudW1lcmF0aW9uIFNjcm9sbEJlaGF2aW9yLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgaGFzIHNjcm9sbGFibGUgc3BhY2UgaW4gdGhlIHByb3ZpZGVkIGF4aXNcbiAgICAgKiBAbWV0aG9kIGhhc1Njcm9sbGFibGVTcGFjZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXhpc1xuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc1Njcm9sbGFibGVTcGFjZShlbCwgYXhpcykge1xuICAgICAgaWYgKGF4aXMgPT09ICdZJykge1xuICAgICAgICByZXR1cm4gZWwuY2xpZW50SGVpZ2h0ICsgUk9VTkRJTkdfVE9MRVJBTkNFIDwgZWwuc2Nyb2xsSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBpZiAoYXhpcyA9PT0gJ1gnKSB7XG4gICAgICAgIHJldHVybiBlbC5jbGllbnRXaWR0aCArIFJPVU5ESU5HX1RPTEVSQU5DRSA8IGVsLnNjcm9sbFdpZHRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGluZGljYXRlcyBpZiBhbiBlbGVtZW50IGhhcyBhIHNjcm9sbGFibGUgb3ZlcmZsb3cgcHJvcGVydHkgaW4gdGhlIGF4aXNcbiAgICAgKiBAbWV0aG9kIGNhbk92ZXJmbG93XG4gICAgICogQHBhcmFtIHtOb2RlfSBlbFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBheGlzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FuT3ZlcmZsb3coZWwsIGF4aXMpIHtcbiAgICAgIHZhciBvdmVyZmxvd1ZhbHVlID0gdy5nZXRDb21wdXRlZFN0eWxlKGVsLCBudWxsKVsnb3ZlcmZsb3cnICsgYXhpc107XG5cbiAgICAgIHJldHVybiBvdmVyZmxvd1ZhbHVlID09PSAnYXV0bycgfHwgb3ZlcmZsb3dWYWx1ZSA9PT0gJ3Njcm9sbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGlmIGFuIGVsZW1lbnQgY2FuIGJlIHNjcm9sbGVkIGluIGVpdGhlciBheGlzXG4gICAgICogQG1ldGhvZCBpc1Njcm9sbGFibGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF4aXNcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Njcm9sbGFibGUoZWwpIHtcbiAgICAgIHZhciBpc1Njcm9sbGFibGVZID0gaGFzU2Nyb2xsYWJsZVNwYWNlKGVsLCAnWScpICYmIGNhbk92ZXJmbG93KGVsLCAnWScpO1xuICAgICAgdmFyIGlzU2Nyb2xsYWJsZVggPSBoYXNTY3JvbGxhYmxlU3BhY2UoZWwsICdYJykgJiYgY2FuT3ZlcmZsb3coZWwsICdYJyk7XG5cbiAgICAgIHJldHVybiBpc1Njcm9sbGFibGVZIHx8IGlzU2Nyb2xsYWJsZVg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZmluZHMgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgYW4gZWxlbWVudFxuICAgICAqIEBtZXRob2QgZmluZFNjcm9sbGFibGVQYXJlbnRcbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsXG4gICAgICogQHJldHVybnMge05vZGV9IGVsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZFNjcm9sbGFibGVQYXJlbnQoZWwpIHtcbiAgICAgIHdoaWxlIChlbCAhPT0gZC5ib2R5ICYmIGlzU2Nyb2xsYWJsZShlbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsID0gZWwucGFyZW50Tm9kZSB8fCBlbC5ob3N0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc2VsZiBpbnZva2VkIGZ1bmN0aW9uIHRoYXQsIGdpdmVuIGEgY29udGV4dCwgc3RlcHMgdGhyb3VnaCBzY3JvbGxpbmdcbiAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RlcChjb250ZXh0KSB7XG4gICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRYO1xuICAgICAgdmFyIGN1cnJlbnRZO1xuICAgICAgdmFyIGVsYXBzZWQgPSAodGltZSAtIGNvbnRleHQuc3RhcnRUaW1lKSAvIFNDUk9MTF9USU1FO1xuXG4gICAgICAvLyBhdm9pZCBlbGFwc2VkIHRpbWVzIGhpZ2hlciB0aGFuIG9uZVxuICAgICAgZWxhcHNlZCA9IGVsYXBzZWQgPiAxID8gMSA6IGVsYXBzZWQ7XG5cbiAgICAgIC8vIGFwcGx5IGVhc2luZyB0byBlbGFwc2VkIHRpbWVcbiAgICAgIHZhbHVlID0gZWFzZShlbGFwc2VkKTtcblxuICAgICAgY3VycmVudFggPSBjb250ZXh0LnN0YXJ0WCArIChjb250ZXh0LnggLSBjb250ZXh0LnN0YXJ0WCkgKiB2YWx1ZTtcbiAgICAgIGN1cnJlbnRZID0gY29udGV4dC5zdGFydFkgKyAoY29udGV4dC55IC0gY29udGV4dC5zdGFydFkpICogdmFsdWU7XG5cbiAgICAgIGNvbnRleHQubWV0aG9kLmNhbGwoY29udGV4dC5zY3JvbGxhYmxlLCBjdXJyZW50WCwgY3VycmVudFkpO1xuXG4gICAgICAvLyBzY3JvbGwgbW9yZSBpZiB3ZSBoYXZlIG5vdCByZWFjaGVkIG91ciBkZXN0aW5hdGlvblxuICAgICAgaWYgKGN1cnJlbnRYICE9PSBjb250ZXh0LnggfHwgY3VycmVudFkgIT09IGNvbnRleHQueSkge1xuICAgICAgICB3LnJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwLmJpbmQodywgY29udGV4dCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHNjcm9sbHMgd2luZG93IG9yIGVsZW1lbnQgd2l0aCBhIHNtb290aCBiZWhhdmlvclxuICAgICAqIEBtZXRob2Qgc21vb3RoU2Nyb2xsXG4gICAgICogQHBhcmFtIHtPYmplY3R8Tm9kZX0gZWxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzbW9vdGhTY3JvbGwoZWwsIHgsIHkpIHtcbiAgICAgIHZhciBzY3JvbGxhYmxlO1xuICAgICAgdmFyIHN0YXJ0WDtcbiAgICAgIHZhciBzdGFydFk7XG4gICAgICB2YXIgbWV0aG9kO1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IG5vdygpO1xuXG4gICAgICAvLyBkZWZpbmUgc2Nyb2xsIGNvbnRleHRcbiAgICAgIGlmIChlbCA9PT0gZC5ib2R5KSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSB3O1xuICAgICAgICBzdGFydFggPSB3LnNjcm9sbFggfHwgdy5wYWdlWE9mZnNldDtcbiAgICAgICAgc3RhcnRZID0gdy5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQ7XG4gICAgICAgIG1ldGhvZCA9IG9yaWdpbmFsLnNjcm9sbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjcm9sbGFibGUgPSBlbDtcbiAgICAgICAgc3RhcnRYID0gZWwuc2Nyb2xsTGVmdDtcbiAgICAgICAgc3RhcnRZID0gZWwuc2Nyb2xsVG9wO1xuICAgICAgICBtZXRob2QgPSBzY3JvbGxFbGVtZW50O1xuICAgICAgfVxuXG4gICAgICAvLyBzY3JvbGwgbG9vcGluZyBvdmVyIGEgZnJhbWVcbiAgICAgIHN0ZXAoe1xuICAgICAgICBzY3JvbGxhYmxlOiBzY3JvbGxhYmxlLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICAgIHN0YXJ0WDogc3RhcnRYLFxuICAgICAgICBzdGFydFk6IHN0YXJ0WSxcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT1JJR0lOQUwgTUVUSE9EUyBPVkVSUklERVNcbiAgICAvLyB3LnNjcm9sbCBhbmQgdy5zY3JvbGxUb1xuICAgIHcuc2Nyb2xsID0gdy5zY3JvbGxUbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgYWN0aW9uIHdoZW4gbm8gYXJndW1lbnRzIGFyZSBwYXNzZWRcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGF2b2lkIHNtb290aCBiZWhhdmlvciBpZiBub3QgcmVxdWlyZWRcbiAgICAgIGlmIChzaG91bGRCYWlsT3V0KGFyZ3VtZW50c1swXSkgPT09IHRydWUpIHtcbiAgICAgICAgb3JpZ2luYWwuc2Nyb2xsLmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnXG4gICAgICAgICAgICAgID8gYXJndW1lbnRzWzBdXG4gICAgICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgICAgLy8gdXNlIHRvcCBwcm9wLCBzZWNvbmQgYXJndW1lbnQgaWYgcHJlc2VudCBvciBmYWxsYmFjayB0byBzY3JvbGxZXG4gICAgICAgICAgYXJndW1lbnRzWzBdLnRvcCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS50b3BcbiAgICAgICAgICAgIDogYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyBhcmd1bWVudHNbMV1cbiAgICAgICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gTEVUIFRIRSBTTU9PVEhORVNTIEJFR0lOIVxuICAgICAgc21vb3RoU2Nyb2xsLmNhbGwoXG4gICAgICAgIHcsXG4gICAgICAgIGQuYm9keSxcbiAgICAgICAgYXJndW1lbnRzWzBdLmxlZnQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdFxuICAgICAgICAgIDogdy5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQsXG4gICAgICAgIGFyZ3VtZW50c1swXS50b3AgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgOiB3LnNjcm9sbFkgfHwgdy5wYWdlWU9mZnNldFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLy8gdy5zY3JvbGxCeVxuICAgIHcuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIG9yaWdpbmFsLnNjcm9sbEJ5LmNhbGwoXG4gICAgICAgICAgdyxcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGFyZ3VtZW50c1swXS5sZWZ0XG4gICAgICAgICAgICA6IHR5cGVvZiBhcmd1bWVudHNbMF0gIT09ICdvYmplY3QnID8gYXJndW1lbnRzWzBdIDogMCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYXJndW1lbnRzWzBdLnRvcFxuICAgICAgICAgICAgOiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDBcbiAgICAgICAgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIExFVCBUSEUgU01PT1RITkVTUyBCRUdJTiFcbiAgICAgIHNtb290aFNjcm9sbC5jYWxsKFxuICAgICAgICB3LFxuICAgICAgICBkLmJvZHksXG4gICAgICAgIH5+YXJndW1lbnRzWzBdLmxlZnQgKyAody5zY3JvbGxYIHx8IHcucGFnZVhPZmZzZXQpLFxuICAgICAgICB+fmFyZ3VtZW50c1swXS50b3AgKyAody5zY3JvbGxZIHx8IHcucGFnZVlPZmZzZXQpXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvLyBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGwgYW5kIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbFRvXG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsID0gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsVG8gPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGlmIG9uZSBudW1iZXIgaXMgcGFzc2VkLCB0aHJvdyBlcnJvciB0byBtYXRjaCBGaXJlZm94IGltcGxlbWVudGF0aW9uXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVmFsdWUgY291bGQgbm90IGJlIGNvbnZlcnRlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgb3JpZ2luYWwuZWxlbWVudFNjcm9sbC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgLy8gdXNlIGxlZnQgcHJvcCwgZmlyc3QgbnVtYmVyIGFyZ3VtZW50IG9yIGZhbGxiYWNrIHRvIHNjcm9sbExlZnRcbiAgICAgICAgICBhcmd1bWVudHNbMF0ubGVmdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IH5+YXJndW1lbnRzWzBdLmxlZnRcbiAgICAgICAgICAgIDogdHlwZW9mIGFyZ3VtZW50c1swXSAhPT0gJ29iamVjdCcgPyB+fmFyZ3VtZW50c1swXSA6IHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAvLyB1c2UgdG9wIHByb3AsIHNlY29uZCBhcmd1bWVudCBvciBmYWxsYmFjayB0byBzY3JvbGxUb3BcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wXG4gICAgICAgICAgICA6IGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gfn5hcmd1bWVudHNbMV0gOiB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlZnQgPSBhcmd1bWVudHNbMF0ubGVmdDtcbiAgICAgIHZhciB0b3AgPSBhcmd1bWVudHNbMF0udG9wO1xuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdHlwZW9mIGxlZnQgPT09ICd1bmRlZmluZWQnID8gdGhpcy5zY3JvbGxMZWZ0IDogfn5sZWZ0LFxuICAgICAgICB0eXBlb2YgdG9wID09PSAndW5kZWZpbmVkJyA/IHRoaXMuc2Nyb2xsVG9wIDogfn50b3BcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIEVsZW1lbnQucHJvdG90eXBlLnNjcm9sbEJ5XG4gICAgRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsQnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGF2b2lkIGFjdGlvbiB3aGVuIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkXG4gICAgICBpZiAoYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhdm9pZCBzbW9vdGggYmVoYXZpb3IgaWYgbm90IHJlcXVpcmVkXG4gICAgICBpZiAoc2hvdWxkQmFpbE91dChhcmd1bWVudHNbMF0pID09PSB0cnVlKSB7XG4gICAgICAgIG9yaWdpbmFsLmVsZW1lbnRTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIGFyZ3VtZW50c1swXS5sZWZ0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0ubGVmdCArIHRoaXMuc2Nyb2xsTGVmdFxuICAgICAgICAgICAgOiB+fmFyZ3VtZW50c1swXSArIHRoaXMuc2Nyb2xsTGVmdCxcbiAgICAgICAgICBhcmd1bWVudHNbMF0udG9wICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gfn5hcmd1bWVudHNbMF0udG9wICsgdGhpcy5zY3JvbGxUb3BcbiAgICAgICAgICAgIDogfn5hcmd1bWVudHNbMV0gKyB0aGlzLnNjcm9sbFRvcFxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zY3JvbGwoe1xuICAgICAgICBsZWZ0OiB+fmFyZ3VtZW50c1swXS5sZWZ0ICsgdGhpcy5zY3JvbGxMZWZ0LFxuICAgICAgICB0b3A6IH5+YXJndW1lbnRzWzBdLnRvcCArIHRoaXMuc2Nyb2xsVG9wLFxuICAgICAgICBiZWhhdmlvcjogYXJndW1lbnRzWzBdLmJlaGF2aW9yXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRWxlbWVudC5wcm90b3R5cGUuc2Nyb2xsSW50b1ZpZXdcbiAgICBFbGVtZW50LnByb3RvdHlwZS5zY3JvbGxJbnRvVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gYXZvaWQgc21vb3RoIGJlaGF2aW9yIGlmIG5vdCByZXF1aXJlZFxuICAgICAgaWYgKHNob3VsZEJhaWxPdXQoYXJndW1lbnRzWzBdKSA9PT0gdHJ1ZSkge1xuICAgICAgICBvcmlnaW5hbC5zY3JvbGxJbnRvVmlldy5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdXG4gICAgICAgICk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBMRVQgVEhFIFNNT09USE5FU1MgQkVHSU4hXG4gICAgICB2YXIgc2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50KHRoaXMpO1xuICAgICAgdmFyIHBhcmVudFJlY3RzID0gc2Nyb2xsYWJsZVBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBjbGllbnRSZWN0cyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIGlmIChzY3JvbGxhYmxlUGFyZW50ICE9PSBkLmJvZHkpIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW5zaWRlIHBhcmVudFxuICAgICAgICBzbW9vdGhTY3JvbGwuY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNjcm9sbGFibGVQYXJlbnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxMZWZ0ICsgY2xpZW50UmVjdHMubGVmdCAtIHBhcmVudFJlY3RzLmxlZnQsXG4gICAgICAgICAgc2Nyb2xsYWJsZVBhcmVudC5zY3JvbGxUb3AgKyBjbGllbnRSZWN0cy50b3AgLSBwYXJlbnRSZWN0cy50b3BcbiAgICAgICAgKTtcblxuICAgICAgICAvLyByZXZlYWwgcGFyZW50IGluIHZpZXdwb3J0IHVubGVzcyBpcyBmaXhlZFxuICAgICAgICBpZiAody5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbGFibGVQYXJlbnQpLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgICBsZWZ0OiBwYXJlbnRSZWN0cy5sZWZ0LFxuICAgICAgICAgICAgdG9wOiBwYXJlbnRSZWN0cy50b3AsXG4gICAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmV2ZWFsIGVsZW1lbnQgaW4gdmlld3BvcnRcbiAgICAgICAgdy5zY3JvbGxCeSh7XG4gICAgICAgICAgbGVmdDogY2xpZW50UmVjdHMubGVmdCxcbiAgICAgICAgICB0b3A6IGNsaWVudFJlY3RzLnRvcCxcbiAgICAgICAgICBiZWhhdmlvcjogJ3Ntb290aCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBjb21tb25qc1xuICAgIG1vZHVsZS5leHBvcnRzID0geyBwb2x5ZmlsbDogcG9seWZpbGwgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBnbG9iYWxcbiAgICBwb2x5ZmlsbCgpO1xuICB9XG5cbn0oKSk7XG4iLCJpbXBvcnQgbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcbmltcG9ydCB7IEV2ZW50ZWQgfSBmcm9tICcuL2V2ZW50ZWQuanMnO1xuaW1wb3J0IGF1dG9CaW5kIGZyb20gJy4vdXRpbHMvYXV0by1iaW5kLmpzJztcbmltcG9ydCB7XG4gIGlzRWxlbWVudCxcbiAgaXNIVE1MRWxlbWVudCxcbiAgaXNGdW5jdGlvbixcbiAgaXNVbmRlZmluZWRcbn0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGJpbmRBZHZhbmNlIH0gZnJvbSAnLi91dGlscy9iaW5kLmpzJztcbmltcG9ydCB7XG4gIHNldHVwVG9vbHRpcCxcbiAgcGFyc2VBdHRhY2hUbyxcbiAgbm9ybWFsaXplUHJlZml4LFxuICB1dWlkXG59IGZyb20gJy4vdXRpbHMvZ2VuZXJhbC5qcyc7XG5pbXBvcnQgU2hlcGhlcmRFbGVtZW50IGZyb20gJy4vY29tcG9uZW50cy9zaGVwaGVyZC1lbGVtZW50LnN2ZWx0ZSc7XG5cbi8vIFBvbHlmaWxsc1xuaW1wb3J0IHNtb290aHNjcm9sbCBmcm9tICdzbW9vdGhzY3JvbGwtcG9seWZpbGwnO1xuc21vb3Roc2Nyb2xsLnBvbHlmaWxsKCk7XG5cbi8qKlxuICogQSBjbGFzcyByZXByZXNlbnRpbmcgc3RlcHMgdG8gYmUgYWRkZWQgdG8gYSB0b3VyLlxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBTdGVwIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdGVwXG4gICAqIEBwYXJhbSB7VG91cn0gdG91ciBUaGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5hcnJvdyBXaGV0aGVyIHRvIGRpc3BsYXkgdGhlIGFycm93IGZvciB0aGUgdG9vbHRpcCBvciBub3QuIERlZmF1bHRzIHRvIGB0cnVlYC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuYXR0YWNoVG8gVGhlIGVsZW1lbnQgdGhlIHN0ZXAgc2hvdWxkIGJlIGF0dGFjaGVkIHRvIG9uIHRoZSBwYWdlLlxuICAgKiBBbiBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGBlbGVtZW50YCBhbmQgYG9uYC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RlcCA9IG5ldyBTdGVwKHRvdXIsIHtcbiAgICogICBhdHRhY2hUbzogeyBlbGVtZW50OiAnLnNvbWUgLnNlbGVjdG9yLXBhdGgnLCBvbjogJ2xlZnQnIH0sXG4gICAqICAgLi4ubW9yZU9wdGlvbnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3UgZG9u4oCZdCBzcGVjaWZ5IGFuIGBhdHRhY2hUb2AgdGhlIGVsZW1lbnQgd2lsbCBhcHBlYXIgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc2NyZWVuLiBUaGUgc2FtZSB3aWxsIGhhcHBlbiBpZiB5b3VyIGBhdHRhY2hUby5lbGVtZW50YCBjYWxsYmFjayByZXR1cm5zIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yIGEgc2VsZWN0b3IgdGhhdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgRE9NLlxuICAgKiBJZiB5b3Ugb21pdCB0aGUgYG9uYCBwb3J0aW9uIG9mIGBhdHRhY2hUb2AsIHRoZSBlbGVtZW50IHdpbGwgc3RpbGwgYmUgaGlnaGxpZ2h0ZWQsIGJ1dCB0aGUgdG9vbHRpcCB3aWxsIGFwcGVhclxuICAgKiBpbiB0aGUgbWlkZGxlIG9mIHRoZSBzY3JlZW4sIHdpdGhvdXQgYW4gYXJyb3cgcG9pbnRpbmcgdG8gdGhlIHRhcmdldC5cbiAgICogSWYgdGhlIGVsZW1lbnQgdG8gaGlnaGxpZ2h0IGRvZXMgbm90IHlldCBleGlzdCB3aGlsZSBpbnN0YW50aWF0aW5nIHRvdXIgc3RlcHMsIHlvdSBtYXkgdXNlIGxhenkgZXZhbHVhdGlvbiBieSBzdXBwbHlpbmcgYSBmdW5jdGlvbiB0byBgYXR0YWNoVG8uZWxlbWVudGAuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBpbiB0aGUgYGJlZm9yZS1zaG93YCBwaGFzZS5cbiAgICogQHBhcmFtIHtzdHJpbmd8SFRNTEVsZW1lbnR8ZnVuY3Rpb259IG9wdGlvbnMuYXR0YWNoVG8uZWxlbWVudCBBbiBlbGVtZW50IHNlbGVjdG9yIHN0cmluZywgRE9NIGVsZW1lbnQsIG9yIGEgZnVuY3Rpb24gKHJldHVybmluZyBhIHNlbGVjdG9yLCBhIERPTSBlbGVtZW50LCBgbnVsbGAgb3IgYHVuZGVmaW5lZGApLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5hdHRhY2hUby5vbiBUaGUgb3B0aW9uYWwgZGlyZWN0aW9uIHRvIHBsYWNlIHRoZSBQb3BwZXIgdG9vbHRpcCByZWxhdGl2ZSB0byB0aGUgZWxlbWVudC5cbiAgICogICAtIFBvc3NpYmxlIHN0cmluZyB2YWx1ZXM6ICdhdXRvJywgJ2F1dG8tc3RhcnQnLCAnYXV0by1lbmQnLCAndG9wJywgJ3RvcC1zdGFydCcsICd0b3AtZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnYm90dG9tLWVuZCcsICdyaWdodCcsICdyaWdodC1zdGFydCcsICdyaWdodC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0JywgJ2xlZnQtZW5kJ1xuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hZHZhbmNlT24gQW4gYWN0aW9uIG9uIHRoZSBwYWdlIHdoaWNoIHNob3VsZCBhZHZhbmNlIHNoZXBoZXJkIHRvIHRoZSBuZXh0IHN0ZXAuXG4gICAqIEl0IHNob3VsZCBiZSBhbiBvYmplY3Qgd2l0aCBhIHN0cmluZyBgc2VsZWN0b3JgIGFuZCBhbiBgZXZlbnRgIG5hbWVcbiAgICogYGBganNcbiAgICogY29uc3Qgc3RlcCA9IG5ldyBTdGVwKHRvdXIsIHtcbiAgICogICBhZHZhbmNlT246IHsgc2VsZWN0b3I6ICcuc29tZSAuc2VsZWN0b3ItcGF0aCcsIGV2ZW50OiAnY2xpY2snIH0sXG4gICAqICAgLi4ubW9yZU9wdGlvbnNcbiAgICogfSk7XG4gICAqIGBgYFxuICAgKiBgZXZlbnRgIGRvZXNu4oCZdCBoYXZlIHRvIGJlIGFuIGV2ZW50IGluc2lkZSB0aGUgdG91ciwgaXQgY2FuIGJlIGFueSBldmVudCBmaXJlZCBvbiBhbnkgZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAgICogWW91IGNhbiBhbHNvIGFsd2F5cyBtYW51YWxseSBhZHZhbmNlIHRoZSBUb3VyIGJ5IGNhbGxpbmcgYG15VG91ci5uZXh0KClgLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmJlZm9yZVNob3dQcm9taXNlIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICogV2hlbiB0aGUgcHJvbWlzZSByZXNvbHZlcywgdGhlIHJlc3Qgb2YgdGhlIGBzaG93YCBjb2RlIGZvciB0aGUgc3RlcCB3aWxsIGV4ZWN1dGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0W119IG9wdGlvbnMuYnV0dG9ucyBBbiBhcnJheSBvZiBidXR0b25zIHRvIGFkZCB0byB0aGUgc3RlcC4gVGhlc2Ugd2lsbCBiZSByZW5kZXJlZCBpbiBhXG4gICAqIGZvb3RlciBiZWxvdyB0aGUgbWFpbiBib2R5IHRleHQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMuYnV0dG9ucy5idXR0b24uYWN0aW9uIEEgZnVuY3Rpb24gZXhlY3V0ZWQgd2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQgb24uXG4gICAqIEl0IGlzIGF1dG9tYXRpY2FsbHkgYm91bmQgdG8gdGhlIGB0b3VyYCB0aGUgc3RlcCBpcyBhc3NvY2lhdGVkIHdpdGgsIHNvIHRoaW5ncyBsaWtlIGB0aGlzLm5leHRgIHdpbGxcbiAgICogd29yayBpbnNpZGUgdGhlIGFjdGlvbi5cbiAgICogWW91IGNhbiB1c2UgYWN0aW9uIHRvIHNraXAgc3RlcHMgb3IgbmF2aWdhdGUgdG8gc3BlY2lmaWMgc3RlcHMsIHdpdGggc29tZXRoaW5nIGxpa2U6XG4gICAqIGBgYGpzXG4gICAqIGFjdGlvbigpIHtcbiAgICogICByZXR1cm4gdGhpcy5zaG93KCdzb21lX3N0ZXBfbmFtZScpO1xuICAgKiB9XG4gICAqIGBgYFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5jbGFzc2VzIEV4dHJhIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIGA8YT5gXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5kaXNhYmxlZCBTaG91bGQgdGhlIGJ1dHRvbiBiZSBkaXNhYmxlZD9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuYnV0dG9ucy5idXR0b24ubGFiZWwgVGhlIGFyaWEtbGFiZWwgdGV4dCBvZiB0aGUgYnV0dG9uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi5zZWNvbmRhcnkgSWYgdHJ1ZSwgYSBzaGVwaGVyZC1idXR0b24tc2Vjb25kYXJ5IGNsYXNzIGlzIGFwcGxpZWQgdG8gdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5idXR0b25zLmJ1dHRvbi50ZXh0IFRoZSBIVE1MIHRleHQgb2YgdGhlIGJ1dHRvblxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdGlvbnMuY2FuQ2xpY2tUYXJnZXQgQSBib29sZWFuLCB0aGF0IHdoZW4gc2V0IHRvIGZhbHNlLCB3aWxsIHNldCBgcG9pbnRlci1ldmVudHM6IG5vbmVgIG9uIHRoZSB0YXJnZXRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMuY2FuY2VsSWNvbiBPcHRpb25zIGZvciB0aGUgY2FuY2VsIGljb25cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNhbmNlbEljb24uZW5hYmxlZCBTaG91bGQgYSBjYW5jZWwg4oCc4pyV4oCdIGJlIHNob3duIGluIHRoZSBoZWFkZXIgb2YgdGhlIHN0ZXA/XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNhbmNlbEljb24ubGFiZWwgVGhlIGxhYmVsIHRvIGFkZCBmb3IgYGFyaWEtbGFiZWxgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmNsYXNzZXMgQSBzdHJpbmcgb2YgZXh0cmEgY2xhc3NlcyB0byBhZGQgdG8gdGhlIHN0ZXAncyBjb250ZW50IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmhpZ2hsaWdodENsYXNzIEFuIGV4dHJhIGNsYXNzIHRvIGFwcGx5IHRvIHRoZSBgYXR0YWNoVG9gIGVsZW1lbnQgd2hlbiBpdCBpc1xuICAgKiBoaWdobGlnaHRlZCAodGhhdCBpcywgd2hlbiBpdHMgc3RlcCBpcyBhY3RpdmUpLiBZb3UgY2FuIHRoZW4gdGFyZ2V0IHRoYXQgc2VsZWN0b3IgaW4geW91ciBDU1MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmlkIFRoZSBzdHJpbmcgdG8gdXNlIGFzIHRoZSBgaWRgIGZvciB0aGUgc3RlcC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgQW4gYW1vdW50IG9mIHBhZGRpbmcgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zLnBvcHBlck9wdGlvbnMgRXh0cmEgb3B0aW9ucyB0byBwYXNzIHRvIFBvcHBlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBvcHRpb25zLnNjcm9sbFRvIFNob3VsZCB0aGUgZWxlbWVudCBiZSBzY3JvbGxlZCB0byB3aGVuIHRoaXMgc3RlcCBpcyBzaG93bj8gSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBge2JlaGF2aW9yOiAnc21vb3RoJywgYmxvY2s6ICdjZW50ZXInfWBcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIgQSBmdW5jdGlvbiB0aGF0IGxldHMgeW91IG92ZXJyaWRlIHRoZSBkZWZhdWx0IHNjcm9sbFRvIGJlaGF2aW9yIGFuZFxuICAgKiBkZWZpbmUgYSBjdXN0b20gYWN0aW9uIHRvIGRvIHRoZSBzY3JvbGxpbmcsIGFuZCBwb3NzaWJseSBvdGhlciBsb2dpYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucy5zaG93T24gQSBmdW5jdGlvbiB0aGF0LCB3aGVuIGl0IHJldHVybnMgYHRydWVgLCB3aWxsIHNob3cgdGhlIHN0ZXAuXG4gICAqIElmIGl0IHJldHVybnMgZmFsc2UsIHRoZSBzdGVwIHdpbGwgYmUgc2tpcHBlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudGV4dCBUaGUgdGV4dCBpbiB0aGUgYm9keSBvZiB0aGUgc3RlcC4gSXQgY2FuIGJlIG9uZSBvZiB0aHJlZSB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgSFRNTEVsZW1lbnRgIG9iamVjdFxuICAgKiAtIGBGdW5jdGlvbmAgdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgc3RlcCBpcyBidWlsdC4gSXQgbXVzdCByZXR1cm4gb25lIHRoZSB0d28gb3B0aW9ucyBhYm92ZS5cbiAgICogYGBgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLnRpdGxlIFRoZSBzdGVwJ3MgdGl0bGUuIEl0IGJlY29tZXMgYW4gYGgzYCBhdCB0aGUgdG9wIG9mIHRoZSBzdGVwLiBJdCBjYW4gYmUgb25lIG9mIHR3byB0eXBlczpcbiAgICogYGBgXG4gICAqIC0gSFRNTCBzdHJpbmdcbiAgICogLSBgRnVuY3Rpb25gIHRvIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIHN0ZXAgaXMgYnVpbHQuIEl0IG11c3QgcmV0dXJuIEhUTUwgc3RyaW5nLlxuICAgKiBgYGBcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMud2hlbiBZb3UgY2FuIGRlZmluZSBgc2hvd2AsIGBoaWRlYCwgZXRjIGV2ZW50cyBpbnNpZGUgYHdoZW5gLiBGb3IgZXhhbXBsZTpcbiAgICogYGBganNcbiAgICogd2hlbjoge1xuICAgKiAgIHNob3c6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgKiAgIH1cbiAgICogfVxuICAgKiBgYGBcbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGNyZWF0ZWQgU3RlcCBpbnN0YW5jZVxuICAgKi9cbiAgY29uc3RydWN0b3IodG91ciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodG91ciwgb3B0aW9ucyk7XG4gICAgdGhpcy50b3VyID0gdG91cjtcbiAgICB0aGlzLmNsYXNzUHJlZml4ID0gdGhpcy50b3VyLm9wdGlvbnNcbiAgICAgID8gbm9ybWFsaXplUHJlZml4KHRoaXMudG91ci5vcHRpb25zLmNsYXNzUHJlZml4KVxuICAgICAgOiAnJztcbiAgICB0aGlzLnN0eWxlcyA9IHRvdXIuc3R5bGVzO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgYXR0YWNoVG8gb3B0aW9ucy4gRHVlIHRvIGxhenkgZXZhbHVhdGlvbiwgd2Ugb25seSByZXNvbHZlIHRoZSBvcHRpb25zIGR1cmluZyBgYmVmb3JlLXNob3dgIHBoYXNlLlxuICAgICAqIERvIG5vdCB1c2UgdGhpcyBkaXJlY3RseSwgdXNlIHRoZSBfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMgbWV0aG9kIGluc3RlYWQuXG4gICAgICogQHR5cGUge251bGx8e318e2VsZW1lbnQsIHRvfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPSBudWxsO1xuXG4gICAgYXV0b0JpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9zZXRPcHRpb25zKG9wdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ2FuY2VsIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY2FuY2VsYCBldmVudFxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMudG91ci5jYW5jZWwoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlIHRoZSB0b3VyXG4gICAqIFRyaWdnZXJzIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLnRvdXIuY29tcGxldGUoKTtcbiAgICB0aGlzLnRyaWdnZXIoJ2NvbXBsZXRlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSBzdGVwLCBkZWxldGUgdGhlIHN0ZXAncyBlbGVtZW50LCBhbmQgZGVzdHJveSB0aGUgUG9wcGVyIGluc3RhbmNlIGZvciB0aGUgc3RlcC5cbiAgICogVHJpZ2dlcnMgYGRlc3Ryb3lgIGV2ZW50XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnRvb2x0aXApIHtcbiAgICAgIHRoaXMudG9vbHRpcC5kZXN0cm95KCk7XG4gICAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KHRoaXMuZWwpICYmIHRoaXMuZWwucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5lbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgICAgdGhpcy5lbCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpO1xuXG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdG91ciBmb3IgdGhlIHN0ZXBcbiAgICogQHJldHVybiB7VG91cn0gVGhlIHRvdXIgaW5zdGFuY2VcbiAgICovXG4gIGdldFRvdXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudG91cjtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBzdGVwXG4gICAqL1xuICBoaWRlKCkge1xuICAgIHRoaXMudG91ci5tb2RhbC5oaWRlKCk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1oaWRlJyk7XG5cbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgdGhpcy5lbC5oaWRkZW4gPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVN0ZXBUYXJnZXRPbkhpZGUoKTtcblxuICAgIHRoaXMudHJpZ2dlcignaGlkZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc29sdmVzIGF0dGFjaFRvIG9wdGlvbnMuXG4gICAqIEByZXR1cm5zIHt7fXx7ZWxlbWVudCwgb259fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKSB7XG4gICAgdGhpcy5fcmVzb2x2ZWRBdHRhY2hUbyA9IHBhcnNlQXR0YWNoVG8odGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG87XG4gIH1cblxuICAvKipcbiAgICogQSBzZWxlY3RvciBmb3IgcmVzb2x2ZWQgYXR0YWNoVG8gb3B0aW9ucy5cbiAgICogQHJldHVybnMge3t9fHtlbGVtZW50LCBvbn19XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmVkQXR0YWNoVG8gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVkQXR0YWNoVG87XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHN0ZXAgaXMgb3BlbiBhbmQgdmlzaWJsZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBzdGVwIGlzIG9wZW4gYW5kIHZpc2libGVcbiAgICovXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmVsICYmICF0aGlzLmVsLmhpZGRlbik7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHMgYF9zaG93YCBhbmQgZW5zdXJlcyBgYmVmb3JlU2hvd1Byb21pc2VgIHJlc29sdmVzIGJlZm9yZSBjYWxsaW5nIHNob3dcbiAgICogQHJldHVybiB7KnxQcm9taXNlfVxuICAgKi9cbiAgc2hvdygpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih0aGlzLm9wdGlvbnMuYmVmb3JlU2hvd1Byb21pc2UpKSB7XG4gICAgICBjb25zdCBiZWZvcmVTaG93UHJvbWlzZSA9IHRoaXMub3B0aW9ucy5iZWZvcmVTaG93UHJvbWlzZSgpO1xuICAgICAgaWYgKCFpc1VuZGVmaW5lZChiZWZvcmVTaG93UHJvbWlzZSkpIHtcbiAgICAgICAgcmV0dXJuIGJlZm9yZVNob3dQcm9taXNlLnRoZW4oKCkgPT4gdGhpcy5fc2hvdygpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fc2hvdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIG9wdGlvbnMgb2YgdGhlIHN0ZXAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFRoZSBvcHRpb25zIGZvciB0aGUgc3RlcFxuICAgKi9cbiAgdXBkYXRlU3RlcE9wdGlvbnMob3B0aW9ucykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgIGlmICh0aGlzLnNoZXBoZXJkRWxlbWVudENvbXBvbmVudCkge1xuICAgICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuJHNldCh7IHN0ZXA6IHRoaXMgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGVsZW1lbnQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIGl0IGhhcyBiZWVuIGRlc3Ryb3llZFxuICAgKi9cbiAgZ2V0RWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0YXJnZXQgZm9yIHRoZSBzdGVwXG4gICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkfSBUaGUgZWxlbWVudCBpbnN0YW5jZS4gdW5kZWZpbmVkIGlmIGl0IGhhcyBuZXZlciBiZWVuIHNob3duLCBudWxsIGlmIHF1ZXJ5IHN0cmluZyBoYXMgbm90IGJlZW4gZm91bmRcbiAgICovXG4gIGdldFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy50YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBTaGVwaGVyZCBlbGVtZW50IGZvciBzdGVwIGJhc2VkIG9uIG9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIERPTSBlbGVtZW50IGZvciB0aGUgc3RlcCB0b29sdGlwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY3JlYXRlVG9vbHRpcENvbnRlbnQoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb25JZCA9IGAke3RoaXMuaWR9LWRlc2NyaXB0aW9uYDtcbiAgICBjb25zdCBsYWJlbElkID0gYCR7dGhpcy5pZH0tbGFiZWxgO1xuXG4gICAgdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQgPSBuZXcgU2hlcGhlcmRFbGVtZW50KHtcbiAgICAgIHRhcmdldDogdGhpcy50b3VyLm9wdGlvbnMuc3RlcHNDb250YWluZXIgfHwgZG9jdW1lbnQuYm9keSxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIGNsYXNzUHJlZml4OiB0aGlzLmNsYXNzUHJlZml4LFxuICAgICAgICBkZXNjcmlwdGlvbklkLFxuICAgICAgICBsYWJlbElkLFxuICAgICAgICBzdGVwOiB0aGlzLFxuICAgICAgICBzdHlsZXM6IHRoaXMuc3R5bGVzXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5zaGVwaGVyZEVsZW1lbnRDb21wb25lbnQuZ2V0RWxlbWVudCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIGEgY3VzdG9tIHNjcm9sbFRvSGFuZGxlciBpcyBkZWZpbmVkLCBjYWxsIHRoYXQsIG90aGVyd2lzZSBkbyB0aGUgZ2VuZXJpY1xuICAgKiBzY3JvbGxJbnRvVmlldyBjYWxsLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0fSBzY3JvbGxUb09wdGlvbnMgSWYgdHJ1ZSwgdXNlcyB0aGUgZGVmYXVsdCBgc2Nyb2xsSW50b1ZpZXdgLFxuICAgKiBpZiBhbiBvYmplY3QsIHBhc3NlcyB0aGF0IG9iamVjdCBhcyB0aGUgcGFyYW1zIHRvIGBzY3JvbGxJbnRvVmlld2AgaS5lLiBgeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnY2VudGVyJyB9YFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Njcm9sbFRvKHNjcm9sbFRvT3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxlbWVudCB9ID0gdGhpcy5fZ2V0UmVzb2x2ZWRBdHRhY2hUb09wdGlvbnMoKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMub3B0aW9ucy5zY3JvbGxUb0hhbmRsZXIpKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2Nyb2xsVG9IYW5kbGVyKGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpc0VsZW1lbnQoZWxlbWVudCkgJiZcbiAgICAgIHR5cGVvZiBlbGVtZW50LnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nXG4gICAgKSB7XG4gICAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHNjcm9sbFRvT3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIF9nZXRDbGFzc09wdGlvbnMgZ2V0cyBhbGwgcG9zc2libGUgY2xhc3NlcyBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0ZXBPcHRpb25zIFRoZSBzdGVwIHNwZWNpZmljIG9wdGlvbnNcbiAgICogQHJldHVybnMge1N0cmluZ30gdW5pcXVlIHN0cmluZyBmcm9tIGFycmF5IG9mIGNsYXNzZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRDbGFzc09wdGlvbnMoc3RlcE9wdGlvbnMpIHtcbiAgICBjb25zdCBkZWZhdWx0U3RlcE9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcbiAgICBjb25zdCBzdGVwQ2xhc3NlcyA9IHN0ZXBPcHRpb25zLmNsYXNzZXMgPyBzdGVwT3B0aW9ucy5jbGFzc2VzIDogJyc7XG4gICAgY29uc3QgZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3NlcyA9XG4gICAgICBkZWZhdWx0U3RlcE9wdGlvbnMgJiYgZGVmYXVsdFN0ZXBPcHRpb25zLmNsYXNzZXNcbiAgICAgICAgPyBkZWZhdWx0U3RlcE9wdGlvbnMuY2xhc3Nlc1xuICAgICAgICA6ICcnO1xuICAgIGNvbnN0IGFsbENsYXNzZXMgPSBbXG4gICAgICAuLi5zdGVwQ2xhc3Nlcy5zcGxpdCgnICcpLFxuICAgICAgLi4uZGVmYXVsdFN0ZXBPcHRpb25zQ2xhc3Nlcy5zcGxpdCgnICcpXG4gICAgXTtcbiAgICBjb25zdCB1bmlxQ2xhc3NlcyA9IG5ldyBTZXQoYWxsQ2xhc3Nlcyk7XG5cbiAgICByZXR1cm4gQXJyYXkuZnJvbSh1bmlxQ2xhc3Nlcykuam9pbignICcpLnRyaW0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBvcHRpb25zIGZvciB0aGUgc3RlcCwgbWFwcyBgd2hlbmAgdG8gZXZlbnRzLCBzZXRzIHVwIGJ1dHRvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIHRoZSBzdGVwXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgdG91ck9wdGlvbnMgPVxuICAgICAgdGhpcy50b3VyICYmIHRoaXMudG91ci5vcHRpb25zICYmIHRoaXMudG91ci5vcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucztcblxuICAgIHRvdXJPcHRpb25zID0gbWVyZ2Uoe30sIHRvdXJPcHRpb25zIHx8IHt9KTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIGFycm93OiB0cnVlXG4gICAgICB9LFxuICAgICAgdG91ck9wdGlvbnMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGNvbnN0IHsgd2hlbiB9ID0gdGhpcy5vcHRpb25zO1xuXG4gICAgdGhpcy5vcHRpb25zLmNsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc09wdGlvbnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB0aGlzLmlkID0gdGhpcy5vcHRpb25zLmlkIHx8IGBzdGVwLSR7dXVpZCgpfWA7XG5cbiAgICBpZiAod2hlbikge1xuICAgICAgT2JqZWN0LmtleXMod2hlbikuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5vbihldmVudCwgd2hlbltldmVudF0sIHRoaXMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZWxlbWVudCBhbmQgc2V0IHVwIHRoZSBQb3BwZXIgaW5zdGFuY2VcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXR1cEVsZW1lbnRzKCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5lbCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuZWwgPSB0aGlzLl9jcmVhdGVUb29sdGlwQ29udGVudCgpO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZHZhbmNlT24pIHtcbiAgICAgIGJpbmRBZHZhbmNlKHRoaXMpO1xuICAgIH1cbiAgICBzZXR1cFRvb2x0aXAodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlcnMgYGJlZm9yZS1zaG93YCwgZ2VuZXJhdGVzIHRoZSB0b29sdGlwIERPTSBjb250ZW50LFxuICAgKiBzZXRzIHVwIGEgUG9wcGVyIGluc3RhbmNlIGZvciB0aGUgdG9vbHRpcCwgdGhlbiB0cmlnZ2VycyBgc2hvd2AuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvdygpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2JlZm9yZS1zaG93Jyk7XG5cbiAgICAvLyBGb3JjZSByZXNvbHZlIHRvIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBhcmUgdXBkYXRlZCBvbiBzdWJzZXF1ZW50IHNob3dzLlxuICAgIHRoaXMuX3Jlc29sdmVBdHRhY2hUb09wdGlvbnMoKTtcbiAgICB0aGlzLl9zZXR1cEVsZW1lbnRzKCk7XG5cbiAgICBpZiAoIXRoaXMudG91ci5tb2RhbCkge1xuICAgICAgdGhpcy50b3VyLl9zZXR1cE1vZGFsKCk7XG4gICAgfVxuXG4gICAgdGhpcy50b3VyLm1vZGFsLnNldHVwRm9yU3RlcCh0aGlzKTtcbiAgICB0aGlzLl9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHRoaXMpO1xuICAgIHRoaXMuZWwuaGlkZGVuID0gZmFsc2U7XG5cbiAgICAvLyBzdGFydCBzY3JvbGxpbmcgdG8gdGFyZ2V0IGJlZm9yZSBzaG93aW5nIHRoZSBzdGVwXG4gICAgaWYgKHRoaXMub3B0aW9ucy5zY3JvbGxUbykge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX3Njcm9sbFRvKHRoaXMub3B0aW9ucy5zY3JvbGxUbyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmVsLmhpZGRlbiA9IGZhbHNlO1xuXG4gICAgY29uc3QgY29udGVudCA9IHRoaXMuc2hlcGhlcmRFbGVtZW50Q29tcG9uZW50LmdldEVsZW1lbnQoKTtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtZW5hYmxlZGApO1xuICAgIHRhcmdldC5jbGFzc0xpc3QuYWRkKGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YCk7XG4gICAgY29udGVudC5jbGFzc0xpc3QuYWRkKCdzaGVwaGVyZC1lbmFibGVkJyk7XG5cbiAgICB0aGlzLnRyaWdnZXIoJ3Nob3cnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb2R1bGF0ZXMgdGhlIHN0eWxlcyBvZiB0aGUgcGFzc2VkIHN0ZXAncyB0YXJnZXQgZWxlbWVudCwgYmFzZWQgb24gdGhlIHN0ZXAncyBvcHRpb25zIGFuZFxuICAgKiB0aGUgdG91cidzIGBtb2RhbGAgb3B0aW9uLCB0byB2aXN1YWxseSBlbXBoYXNpemUgdGhlIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHN0ZXAgVGhlIHN0ZXAgb2JqZWN0IHRoYXQgYXR0YWNoZXMgdG8gdGhlIGVsZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zdHlsZVRhcmdldEVsZW1lbnRGb3JTdGVwKHN0ZXApIHtcbiAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gc3RlcC50YXJnZXQ7XG5cbiAgICBpZiAoIXRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKSB7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5hZGQoc3RlcC5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3NoZXBoZXJkLXRhcmdldC1jbGljay1kaXNhYmxlZCcpO1xuXG4gICAgaWYgKHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hlcGhlcmQtdGFyZ2V0LWNsaWNrLWRpc2FibGVkJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBzdGVwIGlzIGhpZGRlbiwgcmVtb3ZlIHRoZSBoaWdobGlnaHRDbGFzcyBhbmQgJ3NoZXBoZXJkLWVuYWJsZWQnXG4gICAqIGFuZCAnc2hlcGhlcmQtdGFyZ2V0JyBjbGFzc2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSgpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldCB8fCBkb2N1bWVudC5ib2R5O1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHRDbGFzcykge1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5vcHRpb25zLmhpZ2hsaWdodENsYXNzKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnLFxuICAgICAgYCR7dGhpcy5jbGFzc1ByZWZpeH1zaGVwaGVyZC1lbmFibGVkYCxcbiAgICAgIGAke3RoaXMuY2xhc3NQcmVmaXh9c2hlcGhlcmQtdGFyZ2V0YFxuICAgICk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ2xlYW51cCB0aGUgc3RlcHMgYW5kIHNldCBwb2ludGVyRXZlbnRzIGJhY2sgdG8gJ2F1dG8nXG4gKiBAcGFyYW0gdG91ciBUaGUgdG91ciBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXBTdGVwcyh0b3VyKSB7XG4gIGlmICh0b3VyKSB7XG4gICAgY29uc3QgeyBzdGVwcyB9ID0gdG91cjtcblxuICAgIHN0ZXBzLmZvckVhY2goKHN0ZXApID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgc3RlcC5vcHRpb25zICYmXG4gICAgICAgIHN0ZXAub3B0aW9ucy5jYW5DbGlja1RhcmdldCA9PT0gZmFsc2UgJiZcbiAgICAgICAgc3RlcC5vcHRpb25zLmF0dGFjaFRvXG4gICAgICApIHtcbiAgICAgICAgaWYgKHN0ZXAudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICBzdGVwLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdzaGVwaGVyZC10YXJnZXQtY2xpY2stZGlzYWJsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCIvKipcbiAqIEdlbmVyYXRlcyB0aGUgc3ZnIHBhdGggZGF0YSBmb3IgYSByb3VuZGVkIHJlY3RhbmdsZSBvdmVybGF5XG4gKiBAcGFyYW0ge09iamVjdH0gZGltZW5zaW9uIC0gRGltZW5zaW9ucyBvZiByZWN0YW5nbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBXaWR0aC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBIZWlnaHQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geCBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3k9MF0gLSBPZmZzZXQgZnJvbSB0b3AgbGVmdCBjb3JuZXIgaW4geSBheGlzLiBkZWZhdWx0IDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW3I9MF0gLSBDb3JuZXIgUmFkaXVzLiBLZWVwIHRoaXMgc21hbGxlciB0aGFuICBoYWxmIG9mIHdpZHRoIG9yIGhlaWdodC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gUm91bmRlZCByZWN0YW5nbGUgb3ZlcmxheSBwYXRoIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlT3ZlcmxheVBhdGgoeyB3aWR0aCwgaGVpZ2h0LCB4ID0gMCwgeSA9IDAsIHIgPSAwIH0pIHtcbiAgY29uc3QgeyBpbm5lcldpZHRoOiB3LCBpbm5lckhlaWdodDogaCB9ID0gd2luZG93O1xuXG4gIHJldHVybiBgTSR7d30sJHtofVxcXG5IMFxcXG5WMFxcXG5IJHt3fVxcXG5WJHtofVxcXG5aXFxcbk0ke3ggKyByfSwke3l9XFxcbmEke3J9LCR7cn0sMCwwLDAtJHtyfSwke3J9XFxcblYke2hlaWdodCArIHkgLSByfVxcXG5hJHtyfSwke3J9LDAsMCwwLCR7cn0sJHtyfVxcXG5IJHt3aWR0aCArIHggLSByfVxcXG5hJHtyfSwke3J9LDAsMCwwLCR7cn0tJHtyfVxcXG5WJHt5ICsgcn1cXFxuYSR7cn0sJHtyfSwwLDAsMC0ke3J9LSR7cn1cXFxuWmA7XG59XG4iLCI8c2NyaXB0PlxuICBpbXBvcnQgeyB1dWlkIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbC5qcyc7XG4gIGltcG9ydCB7IG1ha2VPdmVybGF5UGF0aCB9IGZyb20gJy4uL3V0aWxzL292ZXJsYXktcGF0aC5qcyc7XG5cbiAgZXhwb3J0IGxldCBlbGVtZW50LCBvcGVuaW5nUHJvcGVydGllcztcbiAgY29uc3QgZ3VpZCA9IHV1aWQoKTtcbiAgbGV0IG1vZGFsSXNWaXNpYmxlID0gZmFsc2U7XG4gIGxldCByYWZJZCA9IHVuZGVmaW5lZDtcbiAgbGV0IHBhdGhEZWZpbml0aW9uO1xuXG4gICQ6IHBhdGhEZWZpbml0aW9uID0gbWFrZU92ZXJsYXlQYXRoKG9wZW5pbmdQcm9wZXJ0aWVzKTtcblxuICBjbG9zZU1vZGFsT3BlbmluZygpO1xuXG4gIGV4cG9ydCBjb25zdCBnZXRFbGVtZW50ID0gKCkgPT4gZWxlbWVudDtcblxuICBleHBvcnQgZnVuY3Rpb24gY2xvc2VNb2RhbE9wZW5pbmcoKSB7XG4gICAgb3BlbmluZ1Byb3BlcnRpZXMgPSB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgcjogMFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogSGlkZSB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSBmYWxzZTtcblxuICAgIC8vIEVuc3VyZSB3ZSBjbGVhbnVwIGFsbCBldmVudCBsaXN0ZW5lcnMgd2hlbiB3ZSBoaWRlIHRoZSBtb2RhbFxuICAgIF9jbGVhbnVwU3RlcEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlcyB0aGUgYm91bmRzIG9mIHRoZSBlbGVtZW50IHdlIHdhbnQgdGhlIG9wZW5pbmcgb3ZlcnRvcCBvZiB0byBzZXQgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIG9wZW5pbmcgYW5kIHBvc2l0aW9uIGl0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyBBbiBhbW91bnQgb2YgcGFkZGluZyB0byBhZGQgYXJvdW5kIHRoZSBtb2RhbCBvdmVybGF5IG9wZW5pbmdcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG1vZGFsT3ZlcmxheU9wZW5pbmdSYWRpdXMgQW4gYW1vdW50IG9mIGJvcmRlciByYWRpdXMgdG8gYWRkIGFyb3VuZCB0aGUgbW9kYWwgb3ZlcmxheSBvcGVuaW5nXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHNjcm9sbFBhcmVudCBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRhcmdldEVsZW1lbnQgVGhlIGVsZW1lbnQgdGhlIG9wZW5pbmcgd2lsbCBleHBvc2VcbiAgICovXG4gIGV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbk1vZGFsKFxuICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nID0gMCxcbiAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzID0gMCxcbiAgICBzY3JvbGxQYXJlbnQsXG4gICAgdGFyZ2V0RWxlbWVudFxuICApIHtcbiAgICBpZiAodGFyZ2V0RWxlbWVudCkge1xuICAgICAgY29uc3QgeyB5LCBoZWlnaHQgfSA9IF9nZXRWaXNpYmxlSGVpZ2h0KHRhcmdldEVsZW1lbnQsIHNjcm9sbFBhcmVudCk7XG4gICAgICBjb25zdCB7IHgsIHdpZHRoLCBsZWZ0IH0gPSB0YXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgbm90IGNvbnNpc3RlbnQuIFNvbWUgYnJvd3NlcnMgdXNlIHggYW5kIHksIHdoaWxlIG90aGVycyB1c2UgbGVmdCBhbmQgdG9wXG4gICAgICBvcGVuaW5nUHJvcGVydGllcyA9IHtcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcgKiAyLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCArIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nICogMixcbiAgICAgICAgeDogKHggfHwgbGVmdCkgLSBtb2RhbE92ZXJsYXlPcGVuaW5nUGFkZGluZyxcbiAgICAgICAgeTogeSAtIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICByOiBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZU1vZGFsT3BlbmluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBtb2RhbCBpcyBlbmFibGVkLCBzZXR1cCB0aGUgc3ZnIG1hc2sgb3BlbmluZyBhbmQgbW9kYWwgb3ZlcmxheSBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIGluc3RhbmNlXG4gICAqL1xuICBleHBvcnQgZnVuY3Rpb24gc2V0dXBGb3JTdGVwKHN0ZXApIHtcbiAgICAvLyBFbnN1cmUgd2UgbW92ZSBsaXN0ZW5lcnMgZnJvbSB0aGUgcHJldmlvdXMgc3RlcCwgYmVmb3JlIHdlIHNldHVwIG5ldyBvbmVzXG4gICAgX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChzdGVwLnRvdXIub3B0aW9ucy51c2VNb2RhbE92ZXJsYXkpIHtcbiAgICAgIF9zdHlsZUZvclN0ZXAoc3RlcCk7XG4gICAgICBzaG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdyB0aGUgbW9kYWwgb3ZlcmxheVxuICAgKi9cbiAgZXhwb3J0IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgbW9kYWxJc1Zpc2libGUgPSB0cnVlO1xuICB9XG5cbiAgY29uc3QgX3ByZXZlbnRNb2RhbEJvZHlUb3VjaCA9IChlKSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9O1xuXG4gIGNvbnN0IF9wcmV2ZW50TW9kYWxPdmVybGF5VG91Y2ggPSAoZSkgPT4ge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgLy8gUHJldmVudHMgd2luZG93IGZyb20gbW92aW5nIG9uIHRvdWNoLlxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbmNlbCB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGxvb3AgYW5kIHJlbW92ZSB0b3VjaG1vdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBfY2xlYW51cFN0ZXBFdmVudExpc3RlbmVycygpIHtcbiAgICBpZiAocmFmSWQpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZklkKTtcbiAgICAgIHJhZklkID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBfcHJldmVudE1vZGFsQm9keVRvdWNoLCB7XG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlIHRoZSBtb2RhbCBmb3IgdGhlIHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHN0eWxlIHRoZSBvcGVuaW5nIGZvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX3N0eWxlRm9yU3RlcChzdGVwKSB7XG4gICAgY29uc3Qge1xuICAgICAgbW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmcsXG4gICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzXG4gICAgfSA9IHN0ZXAub3B0aW9ucztcblxuICAgIGNvbnN0IHNjcm9sbFBhcmVudCA9IF9nZXRTY3JvbGxQYXJlbnQoc3RlcC50YXJnZXQpO1xuXG4gICAgLy8gU2V0dXAgcmVjdXJzaXZlIGZ1bmN0aW9uIHRvIGNhbGwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIHVwZGF0ZSB0aGUgbW9kYWwgb3BlbmluZyBwb3NpdGlvblxuICAgIGNvbnN0IHJhZkxvb3AgPSAoKSA9PiB7XG4gICAgICByYWZJZCA9IHVuZGVmaW5lZDtcbiAgICAgIHBvc2l0aW9uTW9kYWwoXG4gICAgICAgIG1vZGFsT3ZlcmxheU9wZW5pbmdQYWRkaW5nLFxuICAgICAgICBtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzLFxuICAgICAgICBzY3JvbGxQYXJlbnQsXG4gICAgICAgIHN0ZXAudGFyZ2V0XG4gICAgICApO1xuICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmTG9vcCk7XG4gICAgfTtcblxuICAgIHJhZkxvb3AoKTtcblxuICAgIF9hZGRTdGVwRXZlbnRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBjbG9zZXN0IHNjcm9sbGFibGUgcGFyZW50IGVsZW1lbnRcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgdGFyZ2V0IGVsZW1lbnRcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBpc0h0bWxFbGVtZW50ID0gZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgIGNvbnN0IG92ZXJmbG93WSA9XG4gICAgICBpc0h0bWxFbGVtZW50ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLm92ZXJmbG93WTtcbiAgICBjb25zdCBpc1Njcm9sbGFibGUgPSBvdmVyZmxvd1kgIT09ICdoaWRkZW4nICYmIG92ZXJmbG93WSAhPT0gJ3Zpc2libGUnO1xuXG4gICAgaWYgKGlzU2Nyb2xsYWJsZSAmJiBlbGVtZW50LnNjcm9sbEhlaWdodCA+PSBlbGVtZW50LmNsaWVudEhlaWdodCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9nZXRTY3JvbGxQYXJlbnQoZWxlbWVudC5wYXJlbnRFbGVtZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpc2libGUgaGVpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgc2Nyb2xsUGFyZW50LlxuICAgKiBJZiB0aGVyZSBpcyBubyBzY3JvbGwgcGFyZW50LCB0aGUgaGVpZ2h0IG9mIHRoZSBlbGVtZW50IGlzIHJldHVybmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IFRoZSB0YXJnZXQgZWxlbWVudFxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbc2Nyb2xsUGFyZW50XSBUaGUgc2Nyb2xsYWJsZSBwYXJlbnQgZWxlbWVudFxuICAgKiBAcmV0dXJucyB7e3k6IG51bWJlciwgaGVpZ2h0OiBudW1iZXJ9fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gX2dldFZpc2libGVIZWlnaHQoZWxlbWVudCwgc2Nyb2xsUGFyZW50KSB7XG4gICAgY29uc3QgZWxlbWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB0b3AgPSBlbGVtZW50UmVjdC55IHx8IGVsZW1lbnRSZWN0LnRvcDtcbiAgICBsZXQgYm90dG9tID0gZWxlbWVudFJlY3QuYm90dG9tIHx8IHRvcCArIGVsZW1lbnRSZWN0LmhlaWdodDtcblxuICAgIGlmIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIGNvbnN0IHNjcm9sbFJlY3QgPSBzY3JvbGxQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBzY3JvbGxUb3AgPSBzY3JvbGxSZWN0LnkgfHwgc2Nyb2xsUmVjdC50b3A7XG4gICAgICBjb25zdCBzY3JvbGxCb3R0b20gPSBzY3JvbGxSZWN0LmJvdHRvbSB8fCBzY3JvbGxUb3AgKyBzY3JvbGxSZWN0LmhlaWdodDtcblxuICAgICAgdG9wID0gTWF0aC5tYXgodG9wLCBzY3JvbGxUb3ApO1xuICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBzY3JvbGxCb3R0b20pO1xuICAgIH1cblxuICAgIGNvbnN0IGhlaWdodCA9IE1hdGgubWF4KGJvdHRvbSAtIHRvcCwgMCk7IC8vIERlZmF1bHQgdG8gMCBpZiBoZWlnaHQgaXMgbmVnYXRpdmVcblxuICAgIHJldHVybiB7IHk6IHRvcCwgaGVpZ2h0IH07XG4gIH1cbjwvc2NyaXB0PlxuXG48c3ZnXG4gIGJpbmQ6dGhpcz17ZWxlbWVudH1cbiAgY2xhc3M9e2Ake1xuICAgIG1vZGFsSXNWaXNpYmxlID8gJ3NoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUnIDogJydcbiAgfSBzaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcmB9XG4gIG9uOnRvdWNobW92ZT17X3ByZXZlbnRNb2RhbE92ZXJsYXlUb3VjaH1cbj5cbiAgPHBhdGggZD17cGF0aERlZmluaXRpb259IC8+XG48L3N2Zz5cblxuPHN0eWxlIGdsb2JhbD5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyIHtcbiAgICBoZWlnaHQ6IDA7XG4gICAgbGVmdDogMDtcbiAgICBvcGFjaXR5OiAwO1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHRvcDogMDtcbiAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlLW91dCwgaGVpZ2h0IDBtcyAwLjNzLCBvcGFjaXR5IDAuM3MgMG1zO1xuICAgIHdpZHRoOiAxMDB2dztcbiAgICB6LWluZGV4OiA5OTk3O1xuICB9XG5cbiAgLnNoZXBoZXJkLW1vZGFsLW92ZXJsYXktY29udGFpbmVyLnNoZXBoZXJkLW1vZGFsLWlzLXZpc2libGUge1xuICAgIGhlaWdodDogMTAwdmg7XG4gICAgb3BhY2l0eTogMC41O1xuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2Utb3V0LCBoZWlnaHQgMHMgMHMsIG9wYWNpdHkgMC4zcyAwcztcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVooMCk7XG4gIH1cblxuICAuc2hlcGhlcmQtbW9kYWwtb3ZlcmxheS1jb250YWluZXIuc2hlcGhlcmQtbW9kYWwtaXMtdmlzaWJsZSBwYXRoIHtcbiAgICBwb2ludGVyLWV2ZW50czogYWxsO1xuICB9XG48L3N0eWxlPlxuIiwiaW1wb3J0IHsgRXZlbnRlZCB9IGZyb20gJy4vZXZlbnRlZC5qcyc7XG5pbXBvcnQgeyBTdGVwIH0gZnJvbSAnLi9zdGVwLmpzJztcbmltcG9ydCBhdXRvQmluZCBmcm9tICcuL3V0aWxzL2F1dG8tYmluZC5qcyc7XG5pbXBvcnQge1xuICBpc0hUTUxFbGVtZW50LFxuICBpc0Z1bmN0aW9uLFxuICBpc1N0cmluZyxcbiAgaXNVbmRlZmluZWRcbn0gZnJvbSAnLi91dGlscy90eXBlLWNoZWNrLmpzJztcbmltcG9ydCB7IGNsZWFudXBTdGVwcyB9IGZyb20gJy4vdXRpbHMvY2xlYW51cC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVQcmVmaXgsIHV1aWQgfSBmcm9tICcuL3V0aWxzL2dlbmVyYWwuanMnO1xuaW1wb3J0IFNoZXBoZXJkTW9kYWwgZnJvbSAnLi9jb21wb25lbnRzL3NoZXBoZXJkLW1vZGFsLnN2ZWx0ZSc7XG5cbmNvbnN0IFNoZXBoZXJkID0gbmV3IEV2ZW50ZWQoKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgdGhlIHNpdGUgdG91clxuICogQGV4dGVuZHMge0V2ZW50ZWR9XG4gKi9cbmV4cG9ydCBjbGFzcyBUb3VyIGV4dGVuZHMgRXZlbnRlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBmb3IgdGhlIHRvdXJcbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmNvbmZpcm1DYW5jZWwgSWYgdHJ1ZSwgd2lsbCBpc3N1ZSBhIGB3aW5kb3cuY29uZmlybWAgYmVmb3JlIGNhbmNlbGxpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZGlzcGxheSBpbiB0aGUgY29uZmlybSBkaWFsb2dcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuY2xhc3NQcmVmaXggVGhlIHByZWZpeCB0byBhZGQgdG8gdGhlIGBzaGVwaGVyZC1lbmFibGVkYCBhbmQgYHNoZXBoZXJkLXRhcmdldGAgY2xhc3MgbmFtZXMgYXMgd2VsbCBhcyB0aGUgYGRhdGEtc2hlcGhlcmQtc3RlcC1pZGAuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmRlZmF1bHRTdGVwT3B0aW9ucyBEZWZhdWx0IG9wdGlvbnMgZm9yIFN0ZXBzICh7QGxpbmsgU3RlcCNjb25zdHJ1Y3Rvcn0pLCBjcmVhdGVkIHRocm91Z2ggYGFkZFN0ZXBgXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5leGl0T25Fc2MgRXhpdGluZyB0aGUgdG91ciB3aXRoIHRoZSBlc2NhcGUga2V5IHdpbGwgYmUgZW5hYmxlZCB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5XG4gICAqIHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmtleWJvYXJkTmF2aWdhdGlvbiBOYXZpZ2F0aW5nIHRoZSB0b3VyIHZpYSBsZWZ0IGFuZCByaWdodCBhcnJvdyBrZXlzIHdpbGwgYmUgZW5hYmxlZFxuICAgKiB1bmxlc3MgdGhpcyBpcyBleHBsaWNpdGx5IHNldCB0byBmYWxzZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5zdGVwc0NvbnRhaW5lciBBbiBvcHRpb25hbCBjb250YWluZXIgZWxlbWVudCBmb3IgdGhlIHN0ZXBzLlxuICAgKiBJZiBub3Qgc2V0LCB0aGUgc3RlcHMgd2lsbCBiZSBhcHBlbmRlZCB0byBgZG9jdW1lbnQuYm9keWAuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMubW9kYWxDb250YWluZXIgQW4gb3B0aW9uYWwgY29udGFpbmVyIGVsZW1lbnQgZm9yIHRoZSBtb2RhbC5cbiAgICogSWYgbm90IHNldCwgdGhlIG1vZGFsIHdpbGwgYmUgYXBwZW5kZWQgdG8gYGRvY3VtZW50LmJvZHlgLlxuICAgKiBAcGFyYW0ge29iamVjdFtdIHwgU3RlcFtdfSBvcHRpb25zLnN0ZXBzIEFuIGFycmF5IG9mIHN0ZXAgb3B0aW9ucyBvYmplY3RzIG9yIFN0ZXAgaW5zdGFuY2VzIHRvIGluaXRpYWxpemUgdGhlIHRvdXIgd2l0aFxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50b3VyTmFtZSBBbiBvcHRpb25hbCBcIm5hbWVcIiBmb3IgdGhlIHRvdXIuIFRoaXMgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgdGhlIHRvdXInc1xuICAgKiBkeW5hbWljYWxseSBnZW5lcmF0ZWQgYGlkYCBwcm9wZXJ0eSAtLSB3aGljaCBpcyBhbHNvIHNldCBvbiB0aGUgYGJvZHlgIGVsZW1lbnQgYXMgdGhlIGBkYXRhLXNoZXBoZXJkLWFjdGl2ZS10b3VyYCBhdHRyaWJ1dGVcbiAgICogd2hlbmV2ZXIgdGhlIHRvdXIgYmVjb21lcyBhY3RpdmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy51c2VNb2RhbE92ZXJsYXkgV2hldGhlciBvciBub3Qgc3RlcHMgc2hvdWxkIGJlIHBsYWNlZCBhYm92ZSBhIGRhcmtlbmVkXG4gICAqIG1vZGFsIG92ZXJsYXkuIElmIHRydWUsIHRoZSBvdmVybGF5IHdpbGwgY3JlYXRlIGFuIG9wZW5pbmcgYXJvdW5kIHRoZSB0YXJnZXQgZWxlbWVudCBzbyB0aGF0IGl0XG4gICAqIGNhbiByZW1haW4gaW50ZXJhY3RpdmVcbiAgICogQHJldHVybnMge1RvdXJ9XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIGF1dG9CaW5kKHRoaXMpO1xuXG4gICAgY29uc3QgZGVmYXVsdFRvdXJPcHRpb25zID0ge1xuICAgICAgZXhpdE9uRXNjOiB0cnVlLFxuICAgICAga2V5Ym9hcmROYXZpZ2F0aW9uOiB0cnVlXG4gICAgfTtcblxuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRUb3VyT3B0aW9ucywgb3B0aW9ucyk7XG4gICAgdGhpcy5jbGFzc1ByZWZpeCA9IG5vcm1hbGl6ZVByZWZpeCh0aGlzLm9wdGlvbnMuY2xhc3NQcmVmaXgpO1xuICAgIHRoaXMuc3RlcHMgPSBbXTtcbiAgICB0aGlzLmFkZFN0ZXBzKHRoaXMub3B0aW9ucy5zdGVwcyk7XG5cbiAgICAvLyBQYXNzIHRoZXNlIGV2ZW50cyBvbnRvIHRoZSBnbG9iYWwgU2hlcGhlcmQgb2JqZWN0XG4gICAgY29uc3QgZXZlbnRzID0gW1xuICAgICAgJ2FjdGl2ZScsXG4gICAgICAnY2FuY2VsJyxcbiAgICAgICdjb21wbGV0ZScsXG4gICAgICAnaW5hY3RpdmUnLFxuICAgICAgJ3Nob3cnLFxuICAgICAgJ3N0YXJ0J1xuICAgIF07XG4gICAgZXZlbnRzLm1hcCgoZXZlbnQpID0+IHtcbiAgICAgICgoZSkgPT4ge1xuICAgICAgICB0aGlzLm9uKGUsIChvcHRzKSA9PiB7XG4gICAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgICAgb3B0cy50b3VyID0gdGhpcztcbiAgICAgICAgICBTaGVwaGVyZC50cmlnZ2VyKGUsIG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pKGV2ZW50KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3NldFRvdXJJRCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBzdGVwIHRvIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0ZXB9IG9wdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgc3RlcCBvcHRpb25zIG9yIGEgU3RlcCBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIG9wdGlvbmFsIGluZGV4IHRvIGluc2VydCB0aGUgc3RlcCBhdC4gSWYgdW5kZWZpbmVkLCB0aGUgc3RlcFxuICAgKiBpcyBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICogQHJldHVybiB7U3RlcH0gVGhlIG5ld2x5IGFkZGVkIHN0ZXBcbiAgICovXG4gIGFkZFN0ZXAob3B0aW9ucywgaW5kZXgpIHtcbiAgICBsZXQgc3RlcCA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgU3RlcCkpIHtcbiAgICAgIHN0ZXAgPSBuZXcgU3RlcCh0aGlzLCBzdGVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RlcC50b3VyID0gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoIWlzVW5kZWZpbmVkKGluZGV4KSkge1xuICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaW5kZXgsIDAsIHN0ZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ZXA7XG4gIH1cblxuICAvKipcbiAgICogQWRkIG11bHRpcGxlIHN0ZXBzIHRvIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7QXJyYXk8b2JqZWN0PiB8IEFycmF5PFN0ZXA+fSBzdGVwcyBUaGUgc3RlcHMgdG8gYWRkIHRvIHRoZSB0b3VyXG4gICAqL1xuICBhZGRTdGVwcyhzdGVwcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0ZXBzKSkge1xuICAgICAgc3RlcHMuZm9yRWFjaCgoc3RlcCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyB0byB0aGUgcHJldmlvdXMgc3RlcCBpbiB0aGUgdG91clxuICAgKi9cbiAgYmFjaygpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICB0aGlzLnNob3coaW5kZXggLSAxLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSAnY2FuY2VsJyBldmVudFxuICAgKiBJZiBgY29uZmlybUNhbmNlbGAgaXMgdHJ1ZSwgd2lsbCBzaG93IGEgd2luZG93LmNvbmZpcm0gYmVmb3JlIGNhbmNlbGxpbmdcbiAgICovXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmNvbmZpcm1DYW5jZWwpIHtcbiAgICAgIGNvbnN0IGNhbmNlbE1lc3NhZ2UgPVxuICAgICAgICB0aGlzLm9wdGlvbnMuY29uZmlybUNhbmNlbE1lc3NhZ2UgfHxcbiAgICAgICAgJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzdG9wIHRoZSB0b3VyPyc7XG4gICAgICBjb25zdCBzdG9wVG91ciA9IHdpbmRvdy5jb25maXJtKGNhbmNlbE1lc3NhZ2UpO1xuICAgICAgaWYgKHN0b3BUb3VyKSB7XG4gICAgICAgIHRoaXMuX2RvbmUoJ2NhbmNlbCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kb25lKCdjYW5jZWwnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbHMgX2RvbmUoKSB0cmlnZ2VyaW5nIHRoZSBgY29tcGxldGVgIGV2ZW50XG4gICAqL1xuICBjb21wbGV0ZSgpIHtcbiAgICB0aGlzLl9kb25lKCdjb21wbGV0ZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHN0ZXAgZnJvbSBhIGdpdmVuIGlkXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBzdGVwIHRvIHJldHJpZXZlXG4gICAqIEByZXR1cm4ge1N0ZXB9IFRoZSBzdGVwIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGBpZGBcbiAgICovXG4gIGdldEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwcy5maW5kKChzdGVwKSA9PiB7XG4gICAgICByZXR1cm4gc3RlcC5pZCA9PT0gaWQ7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzdGVwXG4gICAqIEByZXR1cm5zIHtTdGVwfG51bGx9XG4gICAqL1xuICBnZXRDdXJyZW50U3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlIHRoZSBjdXJyZW50IHN0ZXBcbiAgICovXG4gIGhpZGUoKSB7XG4gICAgY29uc3QgY3VycmVudFN0ZXAgPSB0aGlzLmdldEN1cnJlbnRTdGVwKCk7XG5cbiAgICBpZiAoY3VycmVudFN0ZXApIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RlcC5oaWRlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSB0b3VyIGlzIGFjdGl2ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPT09IHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR28gdG8gdGhlIG5leHQgc3RlcCBpbiB0aGUgdG91clxuICAgKiBJZiB3ZSBhcmUgYXQgdGhlIGVuZCwgY2FsbCBgY29tcGxldGVgXG4gICAqL1xuICBuZXh0KCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHRoaXMuY3VycmVudFN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zaG93KGluZGV4ICsgMSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHN0ZXAgZnJvbSB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgaWQgZm9yIHRoZSBzdGVwIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlU3RlcChuYW1lKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuZ2V0Q3VycmVudFN0ZXAoKTtcblxuICAgIC8vIEZpbmQgdGhlIHN0ZXAsIGRlc3Ryb3kgaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoaXMuc3RlcHNcbiAgICB0aGlzLnN0ZXBzLnNvbWUoKHN0ZXAsIGkpID0+IHtcbiAgICAgIGlmIChzdGVwLmlkID09PSBuYW1lKSB7XG4gICAgICAgIGlmIChzdGVwLmlzT3BlbigpKSB7XG4gICAgICAgICAgc3RlcC5oaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGVwLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdGVwcy5zcGxpY2UoaSwgMSk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmlkID09PSBuYW1lKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBJZiB3ZSBoYXZlIHN0ZXBzIGxlZnQsIHNob3cgdGhlIGZpcnN0IG9uZSwgb3RoZXJ3aXNlIGp1c3QgY2FuY2VsIHRoZSB0b3VyXG4gICAgICB0aGlzLnN0ZXBzLmxlbmd0aCA/IHRoaXMuc2hvdygwKSA6IHRoaXMuY2FuY2VsKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3cgYSBzcGVjaWZpYyBzdGVwIGluIHRoZSB0b3VyXG4gICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30ga2V5IFRoZSBrZXkgdG8gbG9vayB1cCB0aGUgc3RlcCBieVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZvcndhcmQgVHJ1ZSBpZiB3ZSBhcmUgZ29pbmcgZm9yd2FyZCwgZmFsc2UgaWYgYmFja3dhcmRcbiAgICovXG4gIHNob3coa2V5ID0gMCwgZm9yd2FyZCA9IHRydWUpIHtcbiAgICBjb25zdCBzdGVwID0gaXNTdHJpbmcoa2V5KSA/IHRoaXMuZ2V0QnlJZChrZXkpIDogdGhpcy5zdGVwc1trZXldO1xuXG4gICAgaWYgKHN0ZXApIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdygpO1xuXG4gICAgICBjb25zdCBzaG91bGRTa2lwU3RlcCA9XG4gICAgICAgIGlzRnVuY3Rpb24oc3RlcC5vcHRpb25zLnNob3dPbikgJiYgIXN0ZXAub3B0aW9ucy5zaG93T24oKTtcblxuICAgICAgLy8gSWYgYHNob3dPbmAgcmV0dXJucyBmYWxzZSwgd2Ugd2FudCB0byBza2lwIHRoZSBzdGVwLCBvdGhlcndpc2UsIHNob3cgdGhlIHN0ZXAgbGlrZSBub3JtYWxcbiAgICAgIGlmIChzaG91bGRTa2lwU3RlcCkge1xuICAgICAgICB0aGlzLl9za2lwU3RlcChzdGVwLCBmb3J3YXJkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignc2hvdycsIHtcbiAgICAgICAgICBzdGVwLFxuICAgICAgICAgIHByZXZpb3VzOiB0aGlzLmN1cnJlbnRTdGVwXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSBzdGVwO1xuICAgICAgICBzdGVwLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgdGhlIHRvdXJcbiAgICovXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcblxuICAgIC8vIFNhdmUgdGhlIGZvY3VzZWQgZWxlbWVudCBiZWZvcmUgdGhlIHRvdXIgb3BlbnNcbiAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgdGhpcy5jdXJyZW50U3RlcCA9IG51bGw7XG5cbiAgICB0aGlzLl9zZXR1cE1vZGFsKCk7XG5cbiAgICB0aGlzLl9zZXR1cEFjdGl2ZVRvdXIoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbmV2ZXIgdGhlIHRvdXIgaXMgY2FuY2VsbGVkIG9yIGNvbXBsZXRlZCwgYmFzaWNhbGx5IGFueXRpbWUgd2UgZXhpdCB0aGUgdG91clxuICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUgdG8gdHJpZ2dlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RvbmUoZXZlbnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RlcHMuaW5kZXhPZih0aGlzLmN1cnJlbnRTdGVwKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnN0ZXBzKSkge1xuICAgICAgdGhpcy5zdGVwcy5mb3JFYWNoKChzdGVwKSA9PiBzdGVwLmRlc3Ryb3koKSk7XG4gICAgfVxuXG4gICAgY2xlYW51cFN0ZXBzKHRoaXMpO1xuXG4gICAgdGhpcy50cmlnZ2VyKGV2ZW50LCB7IGluZGV4IH0pO1xuXG4gICAgU2hlcGhlcmQuYWN0aXZlVG91ciA9IG51bGw7XG4gICAgdGhpcy50cmlnZ2VyKCdpbmFjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIGlmICh0aGlzLm1vZGFsKSB7XG4gICAgICB0aGlzLm1vZGFsLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQgPT09ICdjYW5jZWwnIHx8IGV2ZW50ID09PSAnY29tcGxldGUnKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCkge1xuICAgICAgICBjb25zdCBtb2RhbENvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgJy5zaGVwaGVyZC1tb2RhbC1vdmVybGF5LWNvbnRhaW5lcidcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAobW9kYWxDb250YWluZXIpIHtcbiAgICAgICAgICBtb2RhbENvbnRhaW5lci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSB0b3VyIHN0YXJ0ZWRcbiAgICBpZiAoaXNIVE1MRWxlbWVudCh0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4pKSB7XG4gICAgICB0aGlzLmZvY3VzZWRFbEJlZm9yZU9wZW4uZm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFrZSB0aGlzIHRvdXIgXCJhY3RpdmVcIlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwQWN0aXZlVG91cigpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2FjdGl2ZScsIHsgdG91cjogdGhpcyB9KTtcblxuICAgIFNoZXBoZXJkLmFjdGl2ZVRvdXIgPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIF9zZXR1cE1vZGFsIGNyZWF0ZSB0aGUgbW9kYWwgY29udGFpbmVyIGFuZCBpbnN0YW5jZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldHVwTW9kYWwoKSB7XG4gICAgdGhpcy5tb2RhbCA9IG5ldyBTaGVwaGVyZE1vZGFsKHtcbiAgICAgIHRhcmdldDogdGhpcy5vcHRpb25zLm1vZGFsQ29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHksXG4gICAgICBwcm9wczoge1xuICAgICAgICBjbGFzc1ByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCxcbiAgICAgICAgc3R5bGVzOiB0aGlzLnN0eWxlc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGBzaG93T25gIGV2YWx1YXRlcyB0byBmYWxzZSwgdG8gc2tpcCB0aGUgc3RlcCBvciBjb21wbGV0ZSB0aGUgdG91ciBpZiBpdCdzIHRoZSBsYXN0IHN0ZXBcbiAgICogQHBhcmFtIHtTdGVwfSBzdGVwIFRoZSBzdGVwIHRvIHNraXBcbiAgICogQHBhcmFtIHtCb29sZWFufSBmb3J3YXJkIFRydWUgaWYgd2UgYXJlIGdvaW5nIGZvcndhcmQsIGZhbHNlIGlmIGJhY2t3YXJkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2tpcFN0ZXAoc3RlcCwgZm9yd2FyZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5zdGVwcy5pbmRleE9mKHN0ZXApO1xuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnN0ZXBzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbmV4dEluZGV4ID0gZm9yd2FyZCA/IGluZGV4ICsgMSA6IGluZGV4IC0gMTtcbiAgICAgIHRoaXMuc2hvdyhuZXh0SW5kZXgsIGZvcndhcmQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBCZWZvcmUgc2hvd2luZywgaGlkZSB0aGUgY3VycmVudCBzdGVwIGFuZCBpZiB0aGUgdG91ciBpcyBub3RcbiAgICogYWxyZWFkeSBhY3RpdmUsIGNhbGwgYHRoaXMuX3NldHVwQWN0aXZlVG91cmAuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlU3RhdGVCZWZvcmVTaG93KCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRTdGVwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRTdGVwLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fc2V0dXBBY3RpdmVUb3VyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhpcy5pZCB0byBgJHt0b3VyTmFtZX0tLSR7dXVpZH1gXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0VG91cklEKCkge1xuICAgIGNvbnN0IHRvdXJOYW1lID0gdGhpcy5vcHRpb25zLnRvdXJOYW1lIHx8ICd0b3VyJztcblxuICAgIHRoaXMuaWQgPSBgJHt0b3VyTmFtZX0tLSR7dXVpZCgpfWA7XG4gIH1cbn1cblxuZXhwb3J0IHsgU2hlcGhlcmQgfTtcbiIsImltcG9ydCB7IFN0ZXAgfSBmcm9tICcuL3N0ZXAuanMnO1xuaW1wb3J0IHsgU2hlcGhlcmQsIFRvdXIgfSBmcm9tICcuL3RvdXIuanMnO1xuXG5PYmplY3QuYXNzaWduKFNoZXBoZXJkLCB7IFRvdXIsIFN0ZXAgfSk7XG5cbmV4cG9ydCBkZWZhdWx0IFNoZXBoZXJkO1xuIl0sIm5hbWVzIjpbImlzTWVyZ2VhYmxlT2JqZWN0IiwidmFsdWUiLCJpc05vbk51bGxPYmplY3QiLCJpc1NwZWNpYWwiLCJzdHJpbmdWYWx1ZSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImlzUmVhY3RFbGVtZW50IiwiY2FuVXNlU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiJCR0eXBlb2YiLCJlbXB0eVRhcmdldCIsInZhbCIsIkFycmF5IiwiaXNBcnJheSIsImNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkIiwib3B0aW9ucyIsImNsb25lIiwiZGVlcG1lcmdlIiwiZGVmYXVsdEFycmF5TWVyZ2UiLCJ0YXJnZXQiLCJzb3VyY2UiLCJjb25jYXQiLCJtYXAiLCJlbGVtZW50IiwiZ2V0TWVyZ2VGdW5jdGlvbiIsImtleSIsImN1c3RvbU1lcmdlIiwiZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImZpbHRlciIsInN5bWJvbCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiZ2V0S2V5cyIsImtleXMiLCJwcm9wZXJ0eUlzT25PYmplY3QiLCJvYmplY3QiLCJwcm9wZXJ0eSIsIl8iLCJwcm9wZXJ0eUlzVW5zYWZlIiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZU9iamVjdCIsImRlc3RpbmF0aW9uIiwiZm9yRWFjaCIsImFycmF5TWVyZ2UiLCJzb3VyY2VJc0FycmF5IiwidGFyZ2V0SXNBcnJheSIsInNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2giLCJhbGwiLCJkZWVwbWVyZ2VBbGwiLCJhcnJheSIsIkVycm9yIiwicmVkdWNlIiwicHJldiIsIm5leHQiLCJkZWVwbWVyZ2VfMSIsImlzRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJpc0Z1bmN0aW9uIiwiaXNTdHJpbmciLCJpc1VuZGVmaW5lZCIsInVuZGVmaW5lZCIsIkV2ZW50ZWQiLCJvbiIsImV2ZW50IiwiaGFuZGxlciIsImN0eCIsIm9uY2UiLCJiaW5kaW5ncyIsInB1c2giLCJvZmYiLCJiaW5kaW5nIiwiaW5kZXgiLCJzcGxpY2UiLCJ0cmlnZ2VyIiwiYXJncyIsImNvbnRleHQiLCJhcHBseSIsImF1dG9CaW5kIiwic2VsZiIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25zdHJ1Y3RvciIsImkiLCJsZW5ndGgiLCJiaW5kIiwiX3NldHVwQWR2YW5jZU9uSGFuZGxlciIsInNlbGVjdG9yIiwic3RlcCIsImlzT3BlbiIsInRhcmdldElzRWwiLCJlbCIsImN1cnJlbnRUYXJnZXQiLCJ0YXJnZXRJc1NlbGVjdG9yIiwibWF0Y2hlcyIsInRvdXIiLCJiaW5kQWR2YW5jZSIsImFkdmFuY2VPbiIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImUiLCJjb25zb2xlIiwiZXJyb3IiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImJvZHkiLCJ0b3AiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJhdXRvIiwiYmFzZVBsYWNlbWVudHMiLCJzdGFydCIsImVuZCIsImNsaXBwaW5nUGFyZW50cyIsInZpZXdwb3J0IiwicG9wcGVyIiwicmVmZXJlbmNlIiwidmFyaWF0aW9uUGxhY2VtZW50cyIsImFjYyIsInBsYWNlbWVudCIsInBsYWNlbWVudHMiLCJiZWZvcmVSZWFkIiwicmVhZCIsImFmdGVyUmVhZCIsImJlZm9yZU1haW4iLCJtYWluIiwiYWZ0ZXJNYWluIiwiYmVmb3JlV3JpdGUiLCJ3cml0ZSIsImFmdGVyV3JpdGUiLCJtb2RpZmllclBoYXNlcyIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsImdldFdpbmRvdyIsIm5vZGUiLCJ3aW5kb3ciLCJvd25lckRvY3VtZW50IiwiZGVmYXVsdFZpZXciLCJPd25FbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwiX3JlZiIsInN0YXRlIiwiZWxlbWVudHMiLCJuYW1lIiwic3R5bGUiLCJzdHlsZXMiLCJhdHRyaWJ1dGVzIiwiYXNzaWduIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZWZmZWN0IiwiX3JlZjIiLCJpbml0aWFsU3R5bGVzIiwicG9zaXRpb24iLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwiYXR0cmlidXRlIiwiZW5hYmxlZCIsInBoYXNlIiwiZm4iLCJyZXF1aXJlcyIsImdldEJhc2VQbGFjZW1lbnQiLCJzcGxpdCIsIm1heCIsIk1hdGgiLCJtaW4iLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImluY2x1ZGVTY2FsZSIsInJlY3QiLCJzY2FsZVgiLCJzY2FsZVkiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwiaGVpZ2h0IiwieCIsInkiLCJnZXRMYXlvdXRSZWN0IiwiY2xpZW50UmVjdCIsImFicyIsIm9mZnNldExlZnQiLCJvZmZzZXRUb3AiLCJjb250YWlucyIsInBhcmVudCIsImNoaWxkIiwicm9vdE5vZGUiLCJnZXRSb290Tm9kZSIsImlzU2FtZU5vZGUiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldENvbXB1dGVkU3R5bGUiLCJpc1RhYmxlRWxlbWVudCIsImluZGV4T2YiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwid2l0aGluIiwibWF0aE1heCIsIm1hdGhNaW4iLCJ3aXRoaW5NYXhDbGFtcCIsInYiLCJnZXRGcmVzaFNpZGVPYmplY3QiLCJtZXJnZVBhZGRpbmdPYmplY3QiLCJwYWRkaW5nT2JqZWN0IiwiZXhwYW5kVG9IYXNoTWFwIiwiaGFzaE1hcCIsInRvUGFkZGluZ09iamVjdCIsInBhZGRpbmciLCJyZWN0cyIsIl9zdGF0ZSRtb2RpZmllcnNEYXRhJCIsImFycm93RWxlbWVudCIsInBvcHBlck9mZnNldHMiLCJtb2RpZmllcnNEYXRhIiwiYmFzZVBsYWNlbWVudCIsImF4aXMiLCJpc1ZlcnRpY2FsIiwibGVuIiwiYXJyb3dSZWN0IiwibWluUHJvcCIsIm1heFByb3AiLCJlbmREaWZmIiwic3RhcnREaWZmIiwiYXJyb3dPZmZzZXRQYXJlbnQiLCJjbGllbnRTaXplIiwiY2xpZW50SGVpZ2h0IiwiY2xpZW50V2lkdGgiLCJjZW50ZXJUb1JlZmVyZW5jZSIsImNlbnRlciIsIm9mZnNldCIsImF4aXNQcm9wIiwiY2VudGVyT2Zmc2V0IiwiX29wdGlvbnMkZWxlbWVudCIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsInZpc3VhbFZpZXdwb3J0Iiwib2Zmc2V0WCIsImNvbW1vblN0eWxlcyIsIl9yZWY0IiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjUiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsImRhdGEiLCJwYXNzaXZlIiwiaW5zdGFuY2UiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwiaGFzaCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwicmVwbGFjZSIsIm1hdGNoZWQiLCJnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCIsImdldFdpbmRvd1Njcm9sbCIsInNjcm9sbExlZnQiLCJwYWdlWE9mZnNldCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0IiwiZ2V0V2luZG93U2Nyb2xsQmFyWCIsImdldFZpZXdwb3J0UmVjdCIsImh0bWwiLCJ0ZXN0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJkaXJlY3Rpb24iLCJpc1Njcm9sbFBhcmVudCIsIl9nZXRDb21wdXRlZFN0eWxlIiwib3ZlcmZsb3ciLCJvdmVyZmxvd1giLCJvdmVyZmxvd1kiLCJnZXRTY3JvbGxQYXJlbnQiLCJsaXN0U2Nyb2xsUGFyZW50cyIsImxpc3QiLCJpc0JvZHkiLCJ1cGRhdGVkTGlzdCIsInJlY3RUb0NsaWVudFJlY3QiLCJnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFRvcCIsImNsaWVudExlZnQiLCJnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZSIsImNsaXBwaW5nUGFyZW50IiwiZ2V0Q2xpcHBpbmdQYXJlbnRzIiwiY2FuRXNjYXBlQ2xpcHBpbmciLCJjbGlwcGVyRWxlbWVudCIsImdldENsaXBwaW5nUmVjdCIsImJvdW5kYXJ5Iiwicm9vdEJvdW5kYXJ5IiwibWFpbkNsaXBwaW5nUGFyZW50cyIsImZpcnN0Q2xpcHBpbmdQYXJlbnQiLCJjbGlwcGluZ1JlY3QiLCJhY2NSZWN0IiwiY29tcHV0ZU9mZnNldHMiLCJjb21tb25YIiwiY29tbW9uWSIsIm1haW5BeGlzIiwiZGV0ZWN0T3ZlcmZsb3ciLCJfb3B0aW9ucyIsIl9vcHRpb25zJHBsYWNlbWVudCIsIl9vcHRpb25zJGJvdW5kYXJ5IiwiX29wdGlvbnMkcm9vdEJvdW5kYXJ5IiwiX29wdGlvbnMkZWxlbWVudENvbnRlIiwiZWxlbWVudENvbnRleHQiLCJfb3B0aW9ucyRhbHRCb3VuZGFyeSIsImFsdEJvdW5kYXJ5IiwiX29wdGlvbnMkcGFkZGluZyIsImFsdENvbnRleHQiLCJjbGlwcGluZ0NsaWVudFJlY3QiLCJjb250ZXh0RWxlbWVudCIsInJlZmVyZW5jZUNsaWVudFJlY3QiLCJwb3BwZXJDbGllbnRSZWN0IiwiZWxlbWVudENsaWVudFJlY3QiLCJvdmVyZmxvd09mZnNldHMiLCJvZmZzZXREYXRhIiwibXVsdGlwbHkiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsImZsaXBWYXJpYXRpb25zIiwiX29wdGlvbnMkYWxsb3dlZEF1dG9QIiwiYWxsb3dlZEF1dG9QbGFjZW1lbnRzIiwiYWxsUGxhY2VtZW50cyIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImEiLCJiIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImZsaXAiLCJfc2tpcCIsIl9vcHRpb25zJG1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsIl9vcHRpb25zJGFsdEF4aXMiLCJhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicmVmZXJlbmNlUmVjdCIsImNoZWNrc01hcCIsIk1hcCIsIm1ha2VGYWxsYmFja0NoZWNrcyIsImZpcnN0Rml0dGluZ1BsYWNlbWVudCIsIl9iYXNlUGxhY2VtZW50IiwiaXNTdGFydFZhcmlhdGlvbiIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwiY2hlY2siLCJzZXQiLCJudW1iZXJPZkNoZWNrcyIsIl9sb29wIiwiX2kiLCJmaXR0aW5nUGxhY2VtZW50IiwiZmluZCIsImdldCIsInNsaWNlIiwiX3JldCIsInJlc2V0IiwiZ2V0U2lkZU9mZnNldHMiLCJwcmV2ZW50ZWRPZmZzZXRzIiwiaXNBbnlTaWRlRnVsbHlDbGlwcGVkIiwic29tZSIsInNpZGUiLCJoaWRlIiwicHJldmVudE92ZXJmbG93IiwicmVmZXJlbmNlT3ZlcmZsb3ciLCJwb3BwZXJBbHRPdmVyZmxvdyIsInJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyIsInBvcHBlckVzY2FwZU9mZnNldHMiLCJpc1JlZmVyZW5jZUhpZGRlbiIsImhhc1BvcHBlckVzY2FwZWQiLCJkaXN0YW5jZUFuZFNraWRkaW5nVG9YWSIsImludmVydERpc3RhbmNlIiwic2tpZGRpbmciLCJkaXN0YW5jZSIsIl9vcHRpb25zJG9mZnNldCIsIl9kYXRhJHN0YXRlJHBsYWNlbWVudCIsImdldEFsdEF4aXMiLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbGVuIiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsImdldEhUTUxFbGVtZW50U2Nyb2xsIiwiZ2V0Tm9kZVNjcm9sbCIsImlzRWxlbWVudFNjYWxlZCIsImdldENvbXBvc2l0ZVJlY3QiLCJlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCIsImlzT2Zmc2V0UGFyZW50QW5FbGVtZW50Iiwib2Zmc2V0UGFyZW50SXNTY2FsZWQiLCJvcmRlciIsIm1vZGlmaWVycyIsInZpc2l0ZWQiLCJTZXQiLCJyZXN1bHQiLCJtb2RpZmllciIsImFkZCIsImRlcCIsImhhcyIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwiZGVib3VuY2UiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJjdXJyZW50IiwiZXhpc3RpbmciLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwiYXJndW1lbnRzIiwiX2tleSIsInBvcHBlckdlbmVyYXRvciIsImdlbmVyYXRvck9wdGlvbnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZiIsImRlZmF1bHRNb2RpZmllcnMiLCJfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyIiwiZGVmYXVsdE9wdGlvbnMiLCJjcmVhdGVQb3BwZXIiLCJlZmZlY3RDbGVhbnVwRm5zIiwiaXNEZXN0cm95ZWQiLCJzZXRPcHRpb25zIiwic2V0T3B0aW9uc0FjdGlvbiIsImNsZWFudXBNb2RpZmllckVmZmVjdHMiLCJtIiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwiZXZlbnRMaXN0ZW5lcnMiLCJfZ2V0Q2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyIiwiZ2VuZXJhdGVGb2N1c0FmdGVyUmVuZGVyTW9kaWZpZXIiLCJzZXRUaW1lb3V0IiwiZm9jdXNPcHRpb25zIiwicHJldmVudFNjcm9sbCIsImZvY3VzIiwibWFrZUNlbnRlcmVkUG9wcGVyIiwiY2VudGVyZWRTdHlsZVBvcHBlck1vZGlmaWVyIiwicG9wcGVyT3B0aW9ucyIsImZyb20iLCJub3JtYWxpemVQcmVmaXgiLCJwcmVmaXgiLCJjaGFyQXQiLCJwYXJzZUF0dGFjaFRvIiwiYXR0YWNoVG8iLCJyZXR1cm5PcHRzIiwic2hvdWxkQ2VudGVyU3RlcCIsInJlc29sdmVkQXR0YWNoVG9PcHRpb25zIiwic2V0dXBUb29sdGlwIiwidG9vbHRpcCIsImF0dGFjaFRvT3B0aW9ucyIsIl9nZXRSZXNvbHZlZEF0dGFjaFRvT3B0aW9ucyIsImdldFBvcHBlck9wdGlvbnMiLCJjb250ZW50Iiwic2hlcGhlcmRFbGVtZW50Q29tcG9uZW50IiwiZ2V0RWxlbWVudCIsImNsYXNzTGlzdCIsInV1aWQiLCJkIiwiRGF0ZSIsIm5vdyIsImMiLCJyIiwicmFuZG9tIiwiZmxvb3IiLCJkZWZhdWx0U3RlcE9wdGlvbnMiLCJfbWVyZ2VNb2RpZmllcnMiLCJzdGVwT3B0aW9ucyIsIm1lcmdlZFBvcHBlck9wdGlvbnMiLCJuYW1lcyIsIm1vZCIsImZpbHRlcmVkTW9kaWZpZXJzIiwiaW5jbHVkZXMiLCJub29wIiwidGFyIiwic3JjIiwiayIsInJ1biIsImJsYW5rX29iamVjdCIsImNyZWF0ZSIsInJ1bl9hbGwiLCJmbnMiLCJpc19mdW5jdGlvbiIsInRoaW5nIiwic2FmZV9ub3RfZXF1YWwiLCJpc19lbXB0eSIsIm9iaiIsImFwcGVuZCIsImFwcGVuZENoaWxkIiwiaW5zZXJ0IiwiYW5jaG9yIiwiaW5zZXJ0QmVmb3JlIiwiZGV0YWNoIiwicmVtb3ZlQ2hpbGQiLCJkZXN0cm95X2VhY2giLCJpdGVyYXRpb25zIiwiZGV0YWNoaW5nIiwiY3JlYXRlRWxlbWVudCIsInN2Z19lbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwidGV4dCIsImNyZWF0ZVRleHROb2RlIiwic3BhY2UiLCJlbXB0eSIsImxpc3RlbiIsImF0dHIiLCJnZXRBdHRyaWJ1dGUiLCJzZXRfYXR0cmlidXRlcyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsIl9fcHJvdG9fXyIsImNzc1RleHQiLCJjaGlsZHJlbiIsImNoaWxkTm9kZXMiLCJ0b2dnbGVfY2xhc3MiLCJ0b2dnbGUiLCJjdXJyZW50X2NvbXBvbmVudCIsInNldF9jdXJyZW50X2NvbXBvbmVudCIsImNvbXBvbmVudCIsImdldF9jdXJyZW50X2NvbXBvbmVudCIsIm9uTW91bnQiLCIkJCIsIm9uX21vdW50IiwiYWZ0ZXJVcGRhdGUiLCJhZnRlcl91cGRhdGUiLCJkaXJ0eV9jb21wb25lbnRzIiwiYmluZGluZ19jYWxsYmFja3MiLCJyZW5kZXJfY2FsbGJhY2tzIiwiZmx1c2hfY2FsbGJhY2tzIiwicmVzb2x2ZWRfcHJvbWlzZSIsInVwZGF0ZV9zY2hlZHVsZWQiLCJzY2hlZHVsZV91cGRhdGUiLCJmbHVzaCIsImFkZF9yZW5kZXJfY2FsbGJhY2siLCJzZWVuX2NhbGxiYWNrcyIsImZsdXNoaWR4Iiwic2F2ZWRfY29tcG9uZW50IiwicG9wIiwiY2FsbGJhY2siLCJjbGVhciIsImZyYWdtZW50IiwiYmVmb3JlX3VwZGF0ZSIsImRpcnR5IiwicCIsIm91dHJvaW5nIiwib3V0cm9zIiwiZ3JvdXBfb3V0cm9zIiwiY2hlY2tfb3V0cm9zIiwidHJhbnNpdGlvbl9pbiIsImJsb2NrIiwibG9jYWwiLCJkZWxldGUiLCJ0cmFuc2l0aW9uX291dCIsIm8iLCJnZXRfc3ByZWFkX3VwZGF0ZSIsImxldmVscyIsInVwZGF0ZXMiLCJ0b19udWxsX291dCIsImFjY291bnRlZF9mb3IiLCIkJHNjb3BlIiwibiIsImNyZWF0ZV9jb21wb25lbnQiLCJtb3VudF9jb21wb25lbnQiLCJjdXN0b21FbGVtZW50Iiwib25fZGVzdHJveSIsIm5ld19vbl9kZXN0cm95IiwiZGVzdHJveV9jb21wb25lbnQiLCJtYWtlX2RpcnR5IiwiZmlsbCIsImluaXQiLCJjcmVhdGVfZnJhZ21lbnQiLCJub3RfZXF1YWwiLCJwcm9wcyIsImFwcGVuZF9zdHlsZXMiLCJwYXJlbnRfY29tcG9uZW50IiwiYm91bmQiLCJvbl9kaXNjb25uZWN0IiwiY2FsbGJhY2tzIiwic2tpcF9ib3VuZCIsInJvb3QiLCJyZWFkeSIsInJldCIsImh5ZHJhdGUiLCJub2RlcyIsImwiLCJpbnRybyIsIlN2ZWx0ZUNvbXBvbmVudCIsIiRkZXN0cm95IiwiJG9uIiwidHlwZSIsIiRzZXQiLCIkJHByb3BzIiwiJCRzZXQiLCJhY3Rpb24iLCJjbGFzc2VzIiwiZGlzYWJsZWQiLCJsYWJlbCIsInNlY29uZGFyeSIsIm9wdGlvbiIsIiQkaW52YWxpZGF0ZSIsImNvbmZpZyIsImdldENvbmZpZ09wdGlvbiIsImNyZWF0ZV9pZl9ibG9jayIsIiQiLCJidXR0b25zIiwiaGFuZGxlQ2FuY2VsQ2xpY2siLCJwcmV2ZW50RGVmYXVsdCIsImNhbmNlbCIsImxhYmVsSWQiLCJ0aXRsZSIsImlubmVySFRNTCIsImNyZWF0ZV9pZl9ibG9ja18xIiwiY2FuY2VsSWNvbiIsImRlc2NyaXB0aW9uSWQiLCJjbGFzc05hbWUiLCJmaXJzdEZvY3VzYWJsZUVsZW1lbnQiLCJmb2N1c2FibGVFbGVtZW50cyIsImxhc3RGb2N1c2FibGVFbGVtZW50IiwiZGF0YVN0ZXBJZCIsImhhc0NhbmNlbEljb24iLCJoYXNUaXRsZSIsImNsYXNzUHJlZml4IiwiaWQiLCJxdWVyeVNlbGVjdG9yQWxsIiwidXBkYXRlRHluYW1pY0NsYXNzZXMiLCJyZW1vdmVDbGFzc2VzIiwiYWRkQ2xhc3NlcyIsIm9sZENsYXNzZXMiLCJnZXRDbGFzc2VzQXJyYXkiLCJyZW1vdmUiLCJuZXdDbGFzc2VzIiwiaGFuZGxlS2V5RG93biIsImtleUNvZGUiLCJLRVlfVEFCIiwic2hpZnRLZXkiLCJhY3RpdmVFbGVtZW50IiwiS0VZX0VTQyIsImV4aXRPbkVzYyIsIkxFRlRfQVJST1ciLCJrZXlib2FyZE5hdmlnYXRpb24iLCJiYWNrIiwiUklHSFRfQVJST1ciLCJwb2x5ZmlsbCIsInciLCJfX2ZvcmNlU21vb3RoU2Nyb2xsUG9seWZpbGxfXyIsIlNDUk9MTF9USU1FIiwib3JpZ2luYWwiLCJzY3JvbGxUbyIsInNjcm9sbEJ5IiwiZWxlbWVudFNjcm9sbCIsInNjcm9sbEVsZW1lbnQiLCJzY3JvbGxJbnRvVmlldyIsInBlcmZvcm1hbmNlIiwiaXNNaWNyb3NvZnRCcm93c2VyIiwidXNlckFnZW50UGF0dGVybnMiLCJSZWdFeHAiLCJqb2luIiwiUk9VTkRJTkdfVE9MRVJBTkNFIiwiZWFzZSIsImNvcyIsIlBJIiwic2hvdWxkQmFpbE91dCIsImZpcnN0QXJnIiwiYmVoYXZpb3IiLCJUeXBlRXJyb3IiLCJoYXNTY3JvbGxhYmxlU3BhY2UiLCJjYW5PdmVyZmxvdyIsIm92ZXJmbG93VmFsdWUiLCJpc1Njcm9sbGFibGUiLCJpc1Njcm9sbGFibGVZIiwiaXNTY3JvbGxhYmxlWCIsImZpbmRTY3JvbGxhYmxlUGFyZW50IiwidGltZSIsImN1cnJlbnRYIiwiY3VycmVudFkiLCJlbGFwc2VkIiwic3RhcnRUaW1lIiwic3RhcnRYIiwic3RhcnRZIiwibWV0aG9kIiwic2Nyb2xsYWJsZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNtb290aFNjcm9sbCIsInNjcm9sbFgiLCJzY3JvbGxZIiwiU3ludGF4RXJyb3IiLCJzY3JvbGxhYmxlUGFyZW50IiwicGFyZW50UmVjdHMiLCJjbGllbnRSZWN0cyIsIm1vZHVsZSIsInNtb290aHNjcm9sbCIsIlN0ZXAiLCJfcmVzb2x2ZWRBdHRhY2hUbyIsIl9zZXRPcHRpb25zIiwiY29tcGxldGUiLCJfdXBkYXRlU3RlcFRhcmdldE9uSGlkZSIsImdldFRvdXIiLCJtb2RhbCIsImhpZGRlbiIsIl9yZXNvbHZlQXR0YWNoVG9PcHRpb25zIiwiQm9vbGVhbiIsInNob3ciLCJiZWZvcmVTaG93UHJvbWlzZSIsIl9zaG93IiwidXBkYXRlU3RlcE9wdGlvbnMiLCJnZXRUYXJnZXQiLCJfY3JlYXRlVG9vbHRpcENvbnRlbnQiLCJTaGVwaGVyZEVsZW1lbnQiLCJzdGVwc0NvbnRhaW5lciIsIl9zY3JvbGxUbyIsInNjcm9sbFRvT3B0aW9ucyIsInNjcm9sbFRvSGFuZGxlciIsIl9nZXRDbGFzc09wdGlvbnMiLCJzdGVwQ2xhc3NlcyIsImRlZmF1bHRTdGVwT3B0aW9uc0NsYXNzZXMiLCJhbGxDbGFzc2VzIiwidW5pcUNsYXNzZXMiLCJ0cmltIiwidG91ck9wdGlvbnMiLCJtZXJnZSIsIndoZW4iLCJfc2V0dXBFbGVtZW50cyIsIl9zZXR1cE1vZGFsIiwic2V0dXBGb3JTdGVwIiwiX3N0eWxlVGFyZ2V0RWxlbWVudEZvclN0ZXAiLCJ0YXJnZXRFbGVtZW50IiwiaGlnaGxpZ2h0Q2xhc3MiLCJjYW5DbGlja1RhcmdldCIsImNsZWFudXBTdGVwcyIsInN0ZXBzIiwibWFrZU92ZXJsYXlQYXRoIiwiaW5uZXJXaWR0aCIsImgiLCJpbm5lckhlaWdodCIsImlzSHRtbEVsZW1lbnQiLCJfZ2V0U2Nyb2xsUGFyZW50IiwicGFyZW50RWxlbWVudCIsIl9nZXRWaXNpYmxlSGVpZ2h0IiwiZWxlbWVudFJlY3QiLCJzY3JvbGxSZWN0Iiwic2Nyb2xsQm90dG9tIiwib3BlbmluZ1Byb3BlcnRpZXMiLCJwYXRoRGVmaW5pdGlvbiIsImNsb3NlTW9kYWxPcGVuaW5nIiwiX2NsZWFudXBTdGVwRXZlbnRMaXN0ZW5lcnMiLCJwb3NpdGlvbk1vZGFsIiwibW9kYWxPdmVybGF5T3BlbmluZ1BhZGRpbmciLCJtb2RhbE92ZXJsYXlPcGVuaW5nUmFkaXVzIiwidXNlTW9kYWxPdmVybGF5IiwiX3N0eWxlRm9yU3RlcCIsIl9wcmV2ZW50TW9kYWxCb2R5VG91Y2giLCJfcHJldmVudE1vZGFsT3ZlcmxheVRvdWNoIiwic3RvcFByb3BhZ2F0aW9uIiwiX2FkZFN0ZXBFdmVudExpc3RlbmVycyIsInJhZklkIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJyYWZMb29wIiwiU2hlcGhlcmQiLCJUb3VyIiwiZGVmYXVsdFRvdXJPcHRpb25zIiwiYWRkU3RlcHMiLCJldmVudHMiLCJvcHRzIiwiX3NldFRvdXJJRCIsImFkZFN0ZXAiLCJjdXJyZW50U3RlcCIsImNvbmZpcm1DYW5jZWwiLCJjYW5jZWxNZXNzYWdlIiwiY29uZmlybUNhbmNlbE1lc3NhZ2UiLCJzdG9wVG91ciIsImNvbmZpcm0iLCJfZG9uZSIsImdldEJ5SWQiLCJnZXRDdXJyZW50U3RlcCIsImlzQWN0aXZlIiwiYWN0aXZlVG91ciIsInJlbW92ZVN0ZXAiLCJmb3J3YXJkIiwiX3VwZGF0ZVN0YXRlQmVmb3JlU2hvdyIsInNob3VsZFNraXBTdGVwIiwic2hvd09uIiwiX3NraXBTdGVwIiwicHJldmlvdXMiLCJmb2N1c2VkRWxCZWZvcmVPcGVuIiwiX3NldHVwQWN0aXZlVG91ciIsIm1vZGFsQ29udGFpbmVyIiwiU2hlcGhlcmRNb2RhbCIsIm5leHRJbmRleCIsInRvdXJOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/shepherd.js/dist/js/shepherd.js\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./wwwroot/vendor/libs/shepherd/shepherd.js");
/******/ 	var __webpack_export_target__ = window;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;